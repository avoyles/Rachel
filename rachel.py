#!/usr/bin/env python

VERSION = "1.3.1"
RECOVERY_MODE = False
DEBUGGING_MODE = False
SCRIPT_MODE = False

def import_error(library_name):

    print "Rachel could not import the library \"" + library_name + ".\""
    print "  You can install this library by typing one of the following:"
    print "  sudo pip install " + library_name 
    print "  sudo apt-get install " + library_name + " (on linux systems)"
    print "  sudo port install " + library_name + " (on OS X systems, if you have MacPorts installed)"
    print "  (You usually need sudo privilege.)"

import_error_count = 0


try:
    from pprint import pprint # Mostly for debugging
                    
except:
    import_error("pprint")
    import_error_count += 1

try:
    import readline  # Importing this makes up/down arrow, right/left, ctrl-a, ctrl-e, etc. work on the eval expression prompt.
                     # No calls to readline are necessary for up/down arrow completion; it is sufficient to import it.
except:
    import_error("readline")
    import_error_count += 1

try:
    import re        # This is used in conjuntion with os and readline to complete filenames and other commands.

except:
    import_error("re")
    import_error_count += 1

try:
    import copy      # For making deep copies of complex objects.
except:
    import_error("copy")
    import_error_count += 1

try:
    import pickle
except:
    import_error("pickle")
    import_error_count += 1

try:
    import time
except:
    import_error("time")
    import_error_count += 1

try:
    import math
except:
    import_error("math")
    import_error_count += 1

try:
    import bisect
except:
    import_error("bisect")
    import_error_count += 1
try:
    import numpy
except:
    import_error("numpy")
    import_error_count += 1

try:
    import pylab
except:
    import_error("pylab")
    import_error_count += 1

try:
    import matplotlib     
except:
    import_error("matplotlib")
    import_error_count += 1

try:
    import matplotlib.pyplot as plt
except:
    import_error("matplotlib")
    import_error_count += 1

try:
    import pygtk
except:
    import_error("pygtk")
    import_error_count += 1

try:
    pygtk.require('2.0')  # This command really only requires pygtk version 2.* (any sub-version).
except:
    print "The installed version of pygtk is not 2.0 or greater."
    print "You will need to install a newer version of pygtk."
    print "See your administrator for help."
    import_error_count += 1

try:
    import gtk
except:
    import_error("gtk")
    import_error_count += 1

try:
    import gobject
except:
    import_error("gobject")
    import_error_count += 1

try:
    import os
except:
    import_error("os")
    import_error_count += 1

try:
    import signal
except:
    import_error("signal")
    import_error_count += 1

try:
    import pango
except:
    import_error("pango")
    import_error_count += 1

try:
    import sys
except:
    import_error("sys")
    import_error_count += 1

try:
    import subprocess
except:
    import_error("subprocess")
    import_error_count += 1

try:
    import random
except:
    import_error("random")
    import_error_count += 1

try:
    import string
except:
    import_error("string")
    import_error_count += 1

try:
    import textwrap
except:
    import_error("textwrap")
    import_error_count += 1

try:
    import traceback
except:
    import_error("traceback")
    import_error_count += 1

try:
    import StringIO
except:
    import_error("StringIO")
    import_error_count += 1

try:
    import urllib
except:
    import_error("urllib")
    import_error_count += 1

try:
    import urllib2
except:
    import_error("urllib2")
    import_error_count += 1

try:
    from termios import tcflush, TCIOFLUSH  # Right now, just for clearing the input buffer.

except:
    import_error("termios")
    import_error_count += 1

# See if there were import errors.  If there were vital ones (all are vital at
# this point), then quit.

if import_error_count > 0:
    print "***There were " + str(import_error_count) + " import errors***"
    print "Rachel cannot be run until the missing libraries are installed."
    print "See above."
    quit()

# A global reference to the last popup tip window created.
global LAST_POPUP_TIP

TEXTVIEW_COLUMNS = 50  # the default number of columns to display in the textview of the control panel.

# Setup for command and filename completion:
COMMANDS = [] # e.g. ['extra', 'extension', 'stuff', 'errors', 'email', 'foobar', 'foo']
RE_SPACE = re.compile('.*\s+$', re.M)

# Undo settings.
UNDOBASEFILENAME = ".rachel_undo_information."
global MAXIMUMUNDOSTEPS
MAXIMUMUNDOSTEPS = 20  # Each undo step requires a maximum of about 200kB on disk.
UNDO_STACK = []        # A stack to keep track of what operations have been added to the undo files.
# configuration for logrotate to save several versions of the pickle file.
ROTATE_CONFIG_FILE_NAME = "rotate_config"
LOGROTATE_CONFIG = [\
                    '"pickle.jar" {\n',\
                    '    rotate 5\n',\
                    '    nocompress\n',\
                    '    size=1\n',\
                    '    notifempty\n',\
                    '    missingok\n',\
                    '}\n',\
                    ]


# Constants defined 
ASMIDGE = 0.1                    # a small number to use for >,< comparisons where rounding
                                 # to base 2 could be a problem.  0.1 is fine
                                 # for comparing spins This is only used now
                                 # for internal plotting with matplotlib, since
                                 # the round(number,1) function effectively
                                 # rounds to half-spin.

MAXIMUMLEVELS = 99                           # This is not used yet, except in reporting to the user.
MAXIMUM_NUMBER_OF_MATRIX_ELEMENTS = 999      # This is not used yet, except in reporting to the user.

MAXALLOWEDSPIN = 60              # To be used for the general K-forbidden Mikhailov formula where large
                                 # factorials are calculated.

MAX2DARRAYSIZE = 200*200         # This is the maximum number of elements in the array,
                                 # regardless of the length:width ratio.  It is used in ned().

NOCOUPLING = "Fixed"             # This is the marker in nucleus.matrix_data that indicates
                                 # that the matrix element is not a slave to another.  Using
                                 # this constant to ensure consistency.  

DEFAULT_MAGNETIC_SUBSTATES = 8   # The default number of magnetic substates for the full
                                 # Coulex calculations

MAXENERGYMESHPOINTS = 100   
DEFAULT_ENERGY_MESHPOINTS = 20   
MINENERGYMESHPOINTS = 5
MAXTHETAMESHPOINTS = 100
MINIMUM_THETA_MESHPOINTS        = 5  # The minimum acceptable number (should be at least 3 to allow the use of spline interpolation).
DEFAULT_THETA_MESHPOINTS  = 20
RUTHERFORD_CHANGE_CRITERION = 0.05   # The default fractional change in Ruth. c.s. above which a new meshpoint is needed.

MAXENERGYSUBDIVISIONS = 100        # The maximum allowed in gosia. Should be an even integer.
MAXTHETASUBDIVISIONS  = 100        # The maximum allowed in gosia. Should be an even integer.
MINENERGYSUBDIVISIONS = 6          # The minimum allowed in the gui. Should be an even integer.
MINTHETASUBDIVISIONS  = 6          # The minimum allowed in the gui. Should be an even integer.
DEFAULTENERGYSUBDIVISIONS = 50     # Should be an even integer.
DEFAULTTHETASUBDIVISIONS  = 50     # Should be an even integer.
MAXIMUM_DETECTORS_PER_EXPERIMENT = 32  # The maximum number of detectors (data sets) in one experiment.
MAXIMUM_EXPERIMENTS = 50               # The most experiments allowed in Gosia.

# Default stopping power points
DEFAULT_NUMBER_OF_STOPPING_POWERS = 20  # 20 is the maximum allowed by Gosia.
MINIMUM_NUMBER_OF_STOPPING_POWERS = 6   # At least 6 for reasonable spline interpolation.

# Default minimization parameters.  The value for each key is a list of
# [default value, description, parameter number for easy user
# entry,type,lower_limit,upper_limit]

DEFAULTMINIMIZATIONPARAMETERDICT = {\
    "fast_approximation":[False,"If True, then fast approximation is used to calculate chi-squared derivatives.",1,"boolean"],\
    "steepest_descent":[False,"If True, use steepest-descent method; if False, use gradient-derivative.",2,"boolean"],\
    "absolute_change":[True,"If True, then absolute changes in matrix elements are used to improve the minimum; if False, then relative changes are used.",3,"boolean"],\
    "linear_yields":[True,"If True, then yields and other data are used to calculate chi-squared; if False, then a logarithmic scale is used.",4,"boolean"],\
    "max_steps":[10,"The maximum number of minimization steps.",5,"integer",0,10000],\
    "chi_squared_limit":[0.9,"The lower limit on the reduced chi-squared to stop the minimization.",6,"float",0,1.0e6],\
    "convergence_criterion":[1.0e-4,"The minimum change in the vector of matrix elements below which minimization is stopped.",7,"float",0.0,1.0e6],\
    "recalc_test":[1.01,"Internal correction factors are recalculated if the reduced chi-squared drops by a factor of recalc_test.  A faster option to setting \"fast_approximation\" to False is to set this value <1.  See the Gosia manual entry on TEST in OP,MINI.",8,"float",0.0,1.0e6],\
    "lockf":[False,"If lockf is False, then minimization is terminated when the convergence_criterion is satisfied; lockf = True causes Gosia to lock the nlock number of matrix elements having the most significant chi-squared derivatives.  This is useful for escaping a local minimum.",9,"boolean"],\
    "nlock":[0,"The number of matrix elements having the largest derivatives of chi-squared to be locked if lockf = 1 and the convergence_criterion is satisfied.",10,"integer",0,1000],\
    "forward_backward":[True,"If True, then derivatives of chi-squared are calculated using the forward-backward difference method; if False, then only the forward difference is used.",11,"boolean"],\
    "lock_less_effective":[False,"If True, then at the first step of minimization, Gosia locks all matrix elements for which the partial derivative of chi-squared is less than dlocks.",12,"boolean"],\
    "dlocks":[0,"The limit of the partial derivatives of chi-squared with respect to a matrix element, below which it will be fixed if lock_less_effective is True.",13,"float",0.0,1.0e6]\
    }

# A dict to lookup the parameter number for each possible VAC, entry.
VAC_PARAMETER_NUMBER_DICT = {1:"J1",2:"Gamma",3:"Lambda",4:"tau_c",5:"g",6:"K",7:"x"}

# All allowed multipole codes in a dict that points to lambda.
MULTIPOLE_LAMBDA = {'E1':1,'E2':2,'E3':3,'E4':4,'E5':5,'E6':6,'M1':1,'M2':2,\
                   'e1':1,'e2':2,'e3':3,'e4':4,'e5':5,'e6':6,'m1':1,'m2':2}  
                                                                               
UNITS_DICT = {'E1':"eb^(1/2)",'E2':"eb",'E3':"eb^(3/2)",'E4':"eb^2",'E5':"eb^(5/2)",'E6':"eb^3",'M1':"n.m.",'M2':"n.m.^2",\
              'e1':"eb^(1/2)",'e2':"eb",'e3':"eb^(3/2)",'e4':"eb^2",'e5':"eb^(5/2)",'e6':"eb^3",'m1':"n.m.",'m2':"n.m.^2"}

# The dictionary to translate E2, M1, etc. to the codes stored in matrixdata.  
MULTIPOLE = {'e1':1,'e2':2,'e3':3,'e4':4,'e5':5,'e6':6,'m1':7,'m2':8,\
             'E1':1,'E2':2,'E3':3,'E4':4,'E5':5,'E6':6,'M1':7,'M2':8} 

# Use multipole code (number) where possible.  When translating from the user,
# printing output, use text code.
REVERSE_MULTIPOLE   = {1:'E1',2:'E2',3:'E3',4:'E4',5:'E5',6:'E6',7:'M1',8:'M2'}

# File extension definitions and default status and format keyed by file number.
FILE_DEF_DICT = {\
                 22:{"extension":"out","status":"3","format":1},\
                 25:{"extension":"inp","status":"3","format":1},\
                 9:{"extension":"gdt","status":"3","format":1},\
                 3:{"extension":"yld","status":"3","format":1},\
                 4:{"extension":"cor","status":"3","format":1},\
                 7:{"extension":"map","status":"3","format":1},\
                 12:{"extension":"bst","status":"3","format":1},\
                 15:{"extension":"err","status":"3","format":1},\
                 29:{"extension":"icc","status":"3","format":1},\
                 99:{"extension":"amp","status":"3","format":1}
                 }

# Default file names when making or using dummy files to avoid overwriting real data.
DUMMY_FILE_DEF_DICT = {\
                 22:{"extension":"dummy_out","status":"3","format":1},\
                 25:{"extension":"dummy_inp","status":"3","format":1},\
                 9:{"extension":"dummy_gdt","status":"3","format":1},\
                 3:{"extension":"dummy_yld","status":"3","format":1},\
                 4:{"extension":"dummy_cor","status":"3","format":1},\
                 7:{"extension":"dummy_map","status":"3","format":1},\
                 12:{"extension":"dummy_bst","status":"3","format":1},\
                 15:{"extension":"dummy_err","status":"3","format":1},\
                 29:{"extension":"dummy_icc","status":"3","format":1},\
                 99:{"extension":"dummy_amp","status":"3","format":1}
                 }

# The DEORIENTATION_FILE_DEF_DICT uses temporary files for the .cor and .map
# calculations, so that we don't overwrite real data.
DEORIENTATION_FILE_DEF_DICT = {\
                 22:{"extension":"out","status":"3","format":1},\
                 25:{"extension":"inp","status":"3","format":1},\
                 9:{"extension":"gdt","status":"3","format":1},\
                 3:{"extension":"yld","status":"3","format":1},\
                 4:{"extension":"temporary_cor","status":"3","format":1},\
                 7:{"extension":"temporary_map","status":"3","format":1},\
                 12:{"extension":"bst","status":"3","format":1},\
                 15:{"extension":"err","status":"3","format":1},\
                 29:{"extension":"icc","status":"3","format":1},\
                 99:{"extension":"amp","status":"3","format":1}
                 }

# The default file name for all nuclear data tagged by symbols in beta v. 2.0.0
# and ff.
NUCLEAR_DATA_FILE_NAME = "rachel_nuclear_data.txt"   

PROMPTSTRING = "~ "

# Graphics parameters for the level scheme in matplotlib.
LEVELWIDTH = 0.5
LEVELCOLOR = 'k'            # color of levels
RMEARROWCOLOR = 'r'         # color of individual reduced matrix element arrows
MASTERMECOLOR = 'g'         # color of master matrix elements
FIXEDMECOLOR = 'k'          # color of master matrix elements
INTRINSICARROWCOLOR = 'b'   # color of intrinsic m.e. arrows (band-->band)
SPINLABELFONTSIZE = 8
LEVELSCHEMEFIGURE = 1
LSFIGSIZE = (10,8)          # default size in inches for the level scheme figure

# Math constants
M1CONSTANT = math.sqrt(3./(4.*math.pi))  # factor in M1 matrix elements
RUTHERFORD_CONSTANT = 1.29596  # Constant for the differential cross section formulas in mb,MeV.

# Constants related to calculations and fitting:
CALCULATED_YIELD_LOWER_LIMIT = 1.0E-10  # Calculated yields lower than this limit
                                        # (in mb*(mg/cm^2)/sr in integrated
                                        # yields), will not be read from Gosia
                                        # calculations.  This also applies to
                                        # simulated yield data.
    
HELP_DICTIONARY = {}     # A globally accessible dictionary of help strings. This will be read from a file.
TIPS_DICTIONARY = {}     # A globally accessible dictionary of tips strings for popup help. This will be read from a file.
DEFAULT_EDITOR_COMMAND = "vim"  # The text editor to be called from the GUI.

DEFAULT_EFFICIENCY_PARAMETERS = [5.7021, 4.83491, 0., 6.20016, -6.06E-01, -5.36E-03, 4.5934, 0.000219]
#                                A       B        C   D        E          F          G       N 
# The parameters A--G are those used by Radware.  [See def absolute_efficiency()]   
# N is the overall factor for the absolute efficiency.

class updater:

    def __init__(self):

        pass

    def check_server(self):
        """Checks the Rochester server for current version data.

        We are using a dictionary so that more fields can be added without
        major changes in rachel to parse the page.

        {"version":"1.4.0", "notes":"", "message":"", etc.}

        We use eval, here, but it is unlikely that the page will be spoofed.

        """

        print "Checking for new Rachel versions...",
        sys.stdout.flush()

        # Make the server call to get stopping powers.
        url_text  = "http://www-user.pas.rochester.edu/~gosia/rachel_version/version.py"
        try:
            response  = urllib2.urlopen(url=url_text,timeout = 5)
            full_page = response.read()
        except:
            print "\b...failed."
            return False

        self.version_dict = eval(full_page.strip())
        self.message = self.version_dict["message"]
        self.message = self.message.replace("LINEBREAK","\n")

        print "\b...success."

        return True

    def report_all(self):
        """Gives the user all of the information from the web server.

        Returns False in case of an error, True if the server responded.

        """

        try:
            received = self.check_server()
            if not received:
                text = "The Rochester server did not return version and update information.\nIf this error persists, check\nhttp://www-user.pas.rochester.edu/~gosia/mediawiki\nfor the current Rachel version.  You could also notify Rochester about this problem using the Gosia Forum:\nhttp://www-user.pas.rochester.edu/~gosia/phpBB3/"
                lines = block_print_with_line_breaks(text,line_length=60,silent=True,paragraphs=True)
                create_dialog_popup({"text_lines":lines, "title":"Updater Failed", "force_popup":True})
                return False

            
            if not self.version_dict["version"] == VERSION:

                text = "A new version of Rachel is available.\nYou can download version " + self.version_dict["version"] + " from the Gosia Wiki:\n\nhttp://www-user.pas.rochester.edu/~gosia/mediawiki\n\n" + self.message

                lines = block_print_with_line_breaks(text,line_length=60,silent=True,paragraphs=True)
                create_dialog_popup({"text_lines":lines, "title":"Message from Rochester"})
                return True

            elif "special message" in self.version_dict.keys():
                if not self.version_dict["special message"] == "":

                    self.special_message = self.version_dict["special message"]
                    self.special_message = self.special_message.replace("LINEBREAK","\n")
                    text = self.special_message

                    lines = block_print_with_line_breaks(text,line_length=60,silent=True,paragraphs=True)
                    create_dialog_popup({"text_lines":lines, "title":"Update from Rochester"})
                return True

        except:
            pass
            return False
            # Notify Rochester of the bug.


class Completer(object):
    # This is just a modified version of the snippet here:
    # http://stackoverflow.com/questions/5637124/tab-completion-in-pythons-raw-input
    # The original author is http://stackoverflow.com/users/538718/samplebias

    def _listdir(self, root):
        "List directory 'root' appending the path separator to subdirs."
        res = []
        for name in os.listdir(root):
            path = os.path.join(root, name)
            if os.path.isdir(path):
                name += os.sep
            res.append(name)
        return res

    def _complete_path(self, path=None):
        "Perform completion of filesystem path."
        if not path:
            listing = self._listdir('./')
            return listing
        # Added by ABH: If the user typed "~", expand to the user's home directory.
        # (Then continue to return choices.
        elif "~" in path:
            expanded_home_dir = os.path.expanduser("~")
            path = path.replace("~",expanded_home_dir)
            return [path]
        dirname, rest = os.path.split(path)
        tmp = dirname if dirname else '.'
        res = [os.path.join(dirname, p)
            for p in self._listdir(tmp) if p.startswith(rest)]
        # more than one match, or single match which does not exist (typo)
        if len(res) > 1 or not os.path.exists(path):
            return res
        # resolved to a single directory, so return list of files below it
        if os.path.isdir(path):
            return [os.path.join(path, p) for p in self._listdir(path)]
        # exact file match terminates this completion
        return [path]  # was return [path + ' '], but we don't want to put a space after the file name, or it will start repeating the path.

    def complete_file(self, args=None):
        "Completions for the 'extra' command."
        if not args:
            return self._complete_path('./')
        # treat the last arg as a path and complete it
        return self._complete_path(args[-1])

    def complete(self, text, state):
        "Generic readline completion entry point."
        buffer = readline.get_line_buffer()
        line = readline.get_line_buffer().split()
        impl = getattr(self, 'complete_file')
        if line == []:
            args = ["./"]  # Default to the working directory.
        else:
            cmd = line[0].strip()
            args = line # was line[1:]
        if args:
            return (impl(args) + [None])[state]
        return [cmd ][state]


    def nullcomplete(self, text, state):
        return None



def prompt_for_file_name(prompt_string = ""):
    """Uses tab-completion to prompt for file names.

    This is done in a separate def so that tab-completion does not suggest file
    paths at prompts that do not expect a file name.

    """



    # Set up tab-completion using the Completer class.
    # We want to treat '/' as part of a word, so override the delimiters.
    # (See class Completer for credit to "samplebias.")
    readline.set_completer_delims(' \t\n;')
    readline.parse_and_bind("tab: complete")
    # Create a completer object if none exists
    try:
        comp
    except:
        comp = Completer()

    readline.set_completer(comp.complete)

    try:
        file_name = raw_input(prompt_string)
    except:
        file_name = None

    # Now unset the readline file name completer.
    readline.set_completer(comp.nullcomplete)  

    return file_name 

def ignore_break():
    """Uses the signal module to prevent the user from aborting the GUI with CTRL-C.

    If the GUI is in debugging mode, CTRL-C remains enabled.

    """

    if not DEBUGGING_MODE:
        try:
            signal.signal(signal.SIGINT, signal.SIG_IGN)
        except:
            # This is not vital, so if it fails on some platforms we can just
            # let the GUI run with CTRL-C enabled.
            pass
    else:
        # Debugging mode only:
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        

def enable_break():
    """Uses the signal module to enable keyboard interrupts (CTRL-C)

    """

    try:
        signal.signal(signal.SIGINT, signal.SIG_DFL)
    except:
        # This is not vital, so if it fails on some platforms we can just
        # let the GUI run with CTRL-C enabled.
        pass

def create_popup_tip(tip_keyword):
    """A global method to create a popup tip, so that we can close it from anywhere.

    """

    global LAST_POPUP_TIP
    # Close the last popup tip.
    try:
        close_last_popup_tip()
    except:
        pass

    # Now create the new one.
    LAST_POPUP_TIP = popup_tips(tip_keyword)

def close_last_popup_tip():
    """A global method to close the last popup tip.

    Only tips created by def create_popup_tip() will be closed by this method.
    If they are created by a direct reference to class popup_tips, they will
    remain until the user closes them.

    """

    global LAST_POPUP_TIP
    LAST_POPUP_TIP.close_window(" ")

def create_dialog_popup(arguments):
    """A global method to create a dialog popup, so that we can close it from anywhere.

    """

    global LAST_DIALOG_POPUP
    # Close the last popup tip.
    try:
        close_last_dialog_popup()
    except:
        pass

    # Now create the new one.
    LAST_DIALOG_POPUP = dialog_popup(arguments)

def matplotlib_dialog():
    """Creates an information popup about the matplotlib backend.

    """

    ls_window_help_lines = block_print_with_line_breaks("If the level scheme window does not appear, click \"Examine fig. window.\"\nThe GUI performs best using the matplotlib backend \"GTKAgg\" on linux or \"macosx\" on OS X machines.  Refer to http://matplotlib.sourceforge.net/users/customizing.html for help with the matplotlib backends.",50,True)
    create_dialog_popup({"title":"Graphics","force_popup":True,"text_lines":ls_window_help_lines})

def close_last_dialog_popup():
    """A global method to close the last dialog popup.

    Only popups created by def create_dialog_popup() will be closed by this
    method.  If they are created by a direct reference to class dialog_popup,
    they will remain until the user closes them.

    """

    global LAST_DIALOG_POPUP
    LAST_DIALOG_POPUP.close_window(" ")


def top_level_testing():
    """A testing method to call objects and methods that are not yet implemented in the GUI buttons.

    """

    # Check the version updater.
    up = updater()
    up.report_all()

    return 

    setup_globals("reset") # to make sure we don't have old data hanging around in the original objects
    unpickle_return_code,textview_summary = setup_globals(action="unpickle",force=True)
    #print investigated_nucleus.matrix_data

    desc = the_experiment_manager.allexperiments[0].long_description()
    pprint(desc)
    desc = the_experiment_manager.allexperiments[1].long_description()
    pprint(desc)

    raw_input("Press enter.")

    simulation_dict = { \
                        "days_of_beam":5.0, \
                        "beam_intensity":1.0, \
                        "minimum_counts":10, \
                        "estimated_additional_error":0.05, \
                        "user_energy_threshold":50.0, \
                        "inspect_change_efficiency":False, \
                        "add_scatter":False, \
                      }
    the_experiment_manager.write_simulated_yld_file(force_write=False,all_parameters=simulation_dict)


    # Load the session
    #setup_globals("reset") # to make sure we don't have old data hanging around in the original objects
    #unpickle_return_code,textview_summary = setup_globals("unpickle")

    #call_rochester_srim_server(beam_Z=54, beam_mass=136, target_density=10., target_Z=72, target_name="hf", target_mass=178, initial_energy=650., target_thickness_or_exit_energy=50., fractional_padding_on_energy_meshpoints=0.01, number_of_meshpoints=10, thickness_or_exit_energy_flag="-t-")

def largest_float_on_this_machine():
    """Returns approximately the largest machine-size number on this machine.

    This should be re-run any time op,erro is run, and not stored, in case the
    previous calculations were on another machine.

    """
    
    f = 1.0e10
    while True:
        last_f = f
        f = last_f * 10.
        if str(f) == "inf":
            break

    return last_f


def print_separator():
    print ""
    print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    print ""

def eliminate_characters(character_string,text_string,replacement = ""):
    """Removes all instances of the characters in character_string from text_string.

    If the optional argument "replacement" is given, then the string in
    "replacement" is used instead of a null string.

    """

    new_string = ""

    number_of_characters = len(text_string)
    for place_number in range(number_of_characters):
        original_character = text_string[place_number]
        if not original_character in character_string:
            new_string = new_string + original_character
        else:
            new_string = new_string + replacement

    # Return the stripped string
    return new_string


def block_print_with_line_breaks(text,line_length=60,silent=False,paragraphs=True):
    """Prints in nice blocks, but keeps forced line breaks ("\n").

    If silent, return the list of lines, but do not print.

    """

    separate_lines = []

    paragraphs_to_block = text.split("\n")
    for one_paragraph in paragraphs_to_block:
        wrapped_lines = textwrap.wrap(one_paragraph,line_length) 
        for one_line in wrapped_lines:
            if silent:
                separate_lines.append(one_line)
            else:
                print one_line
        if paragraphs:
            # Separate paragraphs with another newline
            if silent:
                separate_lines.append("")
            else:
                print ""

    if silent:
        return separate_lines
    else:
        return 0

def check_for_gosia_error(gosia_output_lines):
    """Checks the gosia output for error reports and explains them.

    If processing probably will not continue after this error (it is fatal), then return -1

    If processing MAY continue after this error (it may not be fatal), then return -2

    If no errors are found in the gosia output, then return 0

    """

    errors_list = [\
                    ["ERROR-INSUFFICIENT SPACE FOR E-THETA INTEGR ATION","The level scheme you are calculating for may have too many levels and/or matrix elements, or you may have too many theta meshpoints, or interpolation subdivisions.  Can you eliminate some weakly populated bands, or some unimportant matrix elements?  Deleting one or more experiments may help as well.  If you do not want to change the calculation, select option \"i\" from the button \"Gosia controls\" and reduce the number of E-theta interpolation subdivisions for all experiments.  Usually, 20 energy subdivisions and 20 theta subdivisions is sufficient.  When you get a successful calculation with no errors, you can use the test \"ti\" under the button \"Tools\" to check that the reduced number of subdivisions has not caused an inaccuracy."],\
                    ["ERROR-M.E. DOES NOT BELONG TO THE UPPER TRIANGLE","Rachel did not write the matrix in the proper order for gosia.  Please report this error to A. Hayes (hayes@pas.rochester.edu).  You can probably fix this by deleting all matrix elements and adding them again.  This is usually caused by importing a bad stored matrix file."],\
                    ["ERROR-WRONG SEQUENCE OF MULTIPOLARITIES","This is probably caused by a bug in Rachel.  Please report this error to A. Hayes (hayes@pas.rochester.edu)."],\
                    ["ERROR-REPEATED APPEARANCE OF THE STATE","This is probably a bug in Rachel.  Please report this error to A. Hayes (hayes@pas.rochester.edu)."],\
                    ["ERROR - NUMBER OF ELEMENTS IN ZETA ARRAY EXCEEDS","This may be caused by a very large level scheme.  Can you delete some weakly populated bands?"],\
                    ["ERROR-ISMAX EXCEEDS MAGMAX","You have requested too many magnetic substates for this calculation.  Reduce the number of substates under the Gosia controls button.  The sum of all magnetic substates for all levels must not exceed 1200."],\
                    ["ERROR- MAXIMUM SCATTERING ANGLE IS","You have exceeded the maximum beam scattering angle (calculated inelastically) for this experiment.  There are several ways that you might fix this problem: (1) Define the experiment(s) so that the target particle is detected in the case of inverse kinematics, or (2) For a thick target, recalculate the stopping power and range using the Rochester SRIM server (button \"Stopping power\"), or (3) Set the state for calculation of the scattering kinematics to the ground state using the Gosia Controls button, option k."],\
                    ["ERROR- MAXIMUM EXCITATION ENERGY IS","The excitation energy for this state exceeds the maximum for this Coulex experiment."],\
                    ["ERROR-NO MATRIX ELEMENT BETWEEN STATES","You should add the matrix element(s) coupling these states."],\
                    ["ERROR IN ROTATION","Please report this bug to A. Hayes (hayes@pas.rochester.edu)."],\
                    ["TAPE READ ERROR","This could be caused by running the gosia operations in the improper order.  Consult the Rachel manual or use the Help button."],\
                    ["TOO FAR FROM THE MINIMUM TO CARRY OUT THE ERROR ESTIMATION!","You should continue fitting to find a better minimum before running the error calculation."],\
                    ["ERROR - No data found for this Z","Gosia cannot calculate internal conversion coefficients for this nucleus.  You will have to write the gosia input to a file and enter conversion data manually after removing the OP,BRIC section."]\
                  ]

    overflow_detected = False
    for i in range(len(gosia_output_lines)-1):
        one_line = gosia_output_lines[i]
        next_line = gosia_output_lines[i+1]
        if "ERROR" in one_line:
            for one_error in errors_list:
                if one_error[0] in one_line:
                    print "Gosia reported an error:"
                    print one_line,"\n",next_line
                    print_error_block(one_error[1])
                    if i == len(gosia_output_lines)-2:
                        return -1
                    else:
                        print "Processing MAY continue after this error."
                        return -2

        elif ("INF" in one_line or \
             "Inf" in one_line or \
             "Infinity" in one_line or \
             "NaN" in one_line or \
             "NAN" in one_line) and not overflow_detected:
            print "There was an overflow on this line:"
            print one_line
            block_print_with_line_breaks("Processing WILL NOT continue properly after this error.  Possible causes:\n  You may not have rewritten the gosia.yld yield data file after making some change to the level scheme, matrix or laboratory setup.  You can rewrite the gosia.yld file by clicking \"Write Gosia yld file,\" unless you are certain that this is not the cause.  This will overwrite it with all applicable yields stored in Rachel.\n  You may not have made the gosia.gdt Ge detector definition file after defining all detector types.  Recreating this file is harmless, and it can be done by selecting \"Make Ge det file\" and \"Run gosia input\" from the pull-down tabs at the bottom and clicking Go.\nYou may have set the normalization transition incorrectly.  This can be set with option \"t\" in the Gosia controls button menu.\nPlease read the full explanation above.\nFurther warnings of this type will be supressed.")
            overflow_detected = True

    if overflow_detected:
        return -1
    else:
        return 0

def print_error_block(error_text):
    
    full_text = "\n---------------------------Error----------------------------\n" + error_text + "\n------------------------------------------------------------\nDone."
    block_print_with_line_breaks(full_text)

def load_tips_data():
    """Loads popup tips data from disk.

    This is a dict for now...

    """


    # Read the help file from disk.
    rachel_tips_file = GLOBAL_SETUP_DICT["RACHEL_DIRECTORY"] + "/necessary_files/popup_tips_dictionary.txt"
    with open(rachel_tips_file,'r') as tips_file:
        tips_lines = tips_file.readlines()

    # Put the help strings in the dictionary by keyword.
    for one_line in tips_lines:
        # Skip blank lines:
        if not len(one_line) == 0 and not one_line.isspace():
            # Split the line on "&".  The former element is the keyword, and the latter is the help string.
            keyword     = one_line.split("&")[0].strip()
            tips_string = one_line.split("&")[1].strip().replace("\\n","\n")  # Replace \n with newlines.  
            TIPS_DICTIONARY[keyword] = tips_string
        
def load_help_data():
    """Loads help data from disk.

    This is a dict for now...

    """


    # Read the help file from disk.
    rachel_help_file = GLOBAL_SETUP_DICT["RACHEL_DIRECTORY"] + "/necessary_files/help_file.txt"
    with open(rachel_help_file,'r') as help_file:
        help_lines = help_file.readlines()

    # Put the help strings in the dictionary by keyword.
    for one_line in help_lines:
        # Skip blank lines:
        if not len(one_line) == 0 and not one_line.isspace():
            # Split the line on "&".  The former element is the keyword, and the latter is the help string.
            keyword     = one_line.split("&")[0].strip()
            help_string = one_line.split("&")[1].strip().replace("\\n","\n")  # Replace \n with newlines.  
            HELP_DICTIONARY[keyword] = help_string
        
def prompt_default(prompt_string,default_value,type_to_return):
    """Returns the number entered or the default value if only return is pressed.

    type_to_return can be "f" (float), "i" (int), "r" (round), where "round"
    will return a float rounded to the one decimal place.

    """

    satisfied = False
    while not satisfied:
        text_input = raw_input(prompt_string)
        # If the user only hit return, return the default value.
        if text_input == "":
            return default_value
        try:
            if type_to_return == "f":
                return_number = float(text_input)
            elif type_to_return == "i":
                return_number = int(text_input)
            elif type_to_return == "r":
                return_number = round(float(text_input),1)
            satisfied = True
        except:
            print "Try again."
            
    return return_number 


def prompt_number(prompt_string,type_to_return):
    """ Helps to prompt for a number without repeating this loop code throughout the program.

    If the user enters "q****" or "Q****" then "quit" is returned.  Otherwise,
    the requested type is returned.

    type_to_return can be "f" (float), "i" (int), "r" (round), where "round"
    will return a float rounded to the one decimal place.

    """
    while True:
        text_input = raw_input(prompt_string)
        if len(text_input) == 0:
            print "Enter a number or \"q\" to quit."
        else:
            if text_input[0].lower() == "q":
                print "Quitting."
                return "quit"
            else:
                try:
                    if type_to_return == "f":
                        return_number = float(text_input)
                    elif type_to_return == "i":
                        return_number = int(text_input)
                    elif type_to_return == "r":
                        return_number = round(float(text_input),1)
                    break
                except:
                    print "Enter a number or \"q\" to quit."

    return return_number 
                    


def yes_no_prompt(prompt_string,default=False):
    """Prompts for a y/n response.

    Returns True if the response was 'y', otherwise False.

    """

    yes_or_no = raw_input(prompt_string).lower()
    try:
        if yes_or_no[0] == 'y':
            return True
        elif yes_or_no[0] == 'n':
            return False
    except:
        # User probably hit return without typing a response.
        return default


def require_yes_no(prompt_string):
    """Same as yes_no_prompt, but no default; an answer is required.

    """

    response = None
    while response == None:
        response = yes_no_prompt(prompt_string,None)

    return response
    
def write_lines_to_file(file_name,list_of_lines,force=False):
    """Writes to text files, primarily for the gosia input files.

    """


    # Test to see if the file exists.
    def internal_write(file_name,list_of_lines):
        """Write routine for use by the write_lines_to_file def only.

        This writes to a file without questioning the user.  The 
        higher-level def write_lines_to_file asks permission for
        existing files.
        """
        with open(file_name,'w') as output_file:
            for one_line in list_of_lines:
                one_line = one_line + "\n"
                output_file.write(one_line)
        output_file.close()

    if not force:
        try:
            some_file = open(file_name,'r')
            some_file.close()
            # If the flow goes to here, then the file exists.  Don't allow a write
            # unless the user approves.
            safe_to_write = False
        except:
            safe_to_write = True

        sure = False
        if safe_to_write:
            print "Writing to file ",file_name,"...  ",
            internal_write(file_name,list_of_lines)
            print "Done."
            return  0
        else:
            print "File ",file_name," exists!  It will be overwritten!"
            sure = yes_no_prompt("Are you sure [y/N]? ",False)
            if sure:
                print "Writing to file ",file_name,"...  ",
                internal_write(file_name,list_of_lines)
                print "Done."
                return  0
            else:
                print "Write operation cancelled."
                return 0
    else:
        # Force writing, even if it overwrites the file.
        print "Writing to file ",file_name,"...  ",
        internal_write(file_name,list_of_lines)
        print "Done."
        return 0


        
def get_system_time_stamp():
    """Makes a call to the o.s. to get the date.

    This has been changed to use the time library, instead of calling the shell.

    """

    time_stamp = time.ctime()

    return time_stamp

def quick_plot_n_sets(dict_of_lists):
    """Calls gnuplot to make a plot of y values vs. x values.

    dict_of_lists = {"legend 1":[[x1,x2,...],[y1,y2,...]],"legend 2":[[],[]],...}
    This is a general purpose plot routine for making quick test plots,
    probably by a script.

    """

    lines_to_write = []
    plot_data_file_name = "temp.dat"

    legend = []

    # Now go through the data sets to construct the lines for gnuplot.
    sorted_keys = dict_of_lists.keys()
    sorted_keys.sort()
    for one_key in sorted_keys:
        temporary_lines_to_write = []
        legend_entry = str(one_key)
        legend.append(legend_entry)
        # Put the legend info in comments in the data file as well
        title_comment = "#"+legend_entry+"\n"
        lines_to_write.append(title_comment)
        x_values = dict_of_lists[one_key][0]
        y_values = dict_of_lists[one_key][1]
        for i in range(len(x_values)):
            this_text_line = str(x_values[i]) + "     " + str(y_values[i]) + "\n"
            temporary_lines_to_write.append(this_text_line)
        lines_to_write.extend(temporary_lines_to_write)
        lines_to_write.append("\n\n")  # two blank lines to separate sets

    with open(plot_data_file_name,"w") as plot_data_file: 
        plot_data_file.writelines(lines_to_write)

    # Call a routine to launch gnuplot
    x_label = "x"
    y_label = "y"
    better_gnu_plot_launch(plot_data_file_name,legend,x_label,y_label,None)

    return 0


def quick_plot(x_list,y_list):
    """Calls gnuplot to make a plot of y values vs. x values.

    This is a general purpose plot routine for making quick test plots,
    probably by a script.

    """

    lines_to_write = []
    plot_data_file_name = "temp.dat"
    x_plot_list = []
    y_plot_list = []

    undefined_points = False
    # Step through energy from 1 keV to 2 MeV.
    for i in range(len(x_list)):
        x = x_list[i]
        y = y_list[i]
        if not y == None:
            this_text_line = str(x) + "     " + str(y) + "\n"
            x_plot_list.append(x)
            y_plot_list.append(y)
            lines_to_write.append(this_text_line)
        else:
            undefined_points = True
            this_text_line = str(x) + "     " + " ? " + "\n"

    lines_to_write.append("\n\n")  # two blank lines to separate sets
            

    with open(plot_data_file_name,"w") as plot_data_file: 
        plot_data_file.writelines(lines_to_write)

    title_string = ""
    x_label = "x"
    y_label = "y"
    calculated_legend = ["y"]

    try:
        low_x = 0.
        high_x = max(x_plot_list)
        low_y = min(y_plot_list)
        high_y = max(y_plot_list)
    except:
        print "\nNot enough plot data for a \"quick_plot\".\n"
        return -1

    experimental_legend = None

    if undefined_points:
        raw_input("\ny(x) was undefined for some x values.\n")

    better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend)

    return 0


def plot_efficiency_curve(energies,efficiencies):
    """Calls gnuplot to make a plot of efficiency vs. gamma energy.

    """

    lines_to_write = []
    plot_data_file_name = "rachel_absolute_efficiency.dat"
    plot_energies = []
    plot_efficiencies= []

    undefined_points = False
    # Step through energy from 1 keV to 2 MeV.
    for i in range(len(energies)):
        gamma_energy = energies[i]
        efficiency   = efficiencies[i]
        if not efficiency == None:
            this_text_line = str(gamma_energy) + "     " + str(efficiency) + "\n"
            plot_energies.append(gamma_energy)
            plot_efficiencies.append(efficiency)
            lines_to_write.append(this_text_line)
        else:
            undefined_points = True
            this_text_line = str(gamma_energy) + "     " + " ? " + "\n"

    lines_to_write.append("\n\n")  # two blank lines to separate sets
            

    with open(plot_data_file_name,"w") as plot_data_file: 
        plot_data_file.writelines(lines_to_write)
    print "Data for this plot were written to the file \"" + plot_data_file_name + "\"."

    title_string = "Absolute efficiency for simulations"
    x_label = "E_gamma [keV]"
    y_label = "Efficiency (1 for 4pi blackbody)"
    calculated_legend = ["efficiency"]

    try:
        low_x = 0.
        high_x = max(plot_energies)
        low_y = min(plot_efficiencies)
        high_y = max(plot_efficiencies)
    except:
        print "\nNo efficiency curve can be generated using the present parameters!\n"
        raw_input("Press enter to continue.")
        return -1

    experimental_legend = None

    if undefined_points:
        raw_input("\nThe efficiency was undefined for some energies using the current efficiency parameters!\nPress enter to continue.")

    better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend)

    return 0


def gnuplot_draw(plot_data_file_name,calculated_legend,x_label,y_label,title_string,withpoints=False,x_range=None,y_range=None,log_y=True):
    """Launch gnuplot to draw shapes

    For now, just x,y plotting
    
    The legend lists must have the same number of entries as the number of data
    sets in the corresponding file.

    """

    if withpoints:
        gnu_commands = ["set zero 1e-20\n","set style line 1 lt 1 pt 2 lw 1 \n",\
            "set style line 2 lt 2 pt 2 lw 1\n",\
            "set style line 3 lt 3 pt 2 lw 1\n",\
            "set style line 4 lt 4 pt 2 lw 1\n",\
            "set style line 5 lt 5 pt 2 lw 1\n",\
            "set style line 6 lt 6 pt 2 lw 1\n",\
            "set style line 7 lt 7 pt 2 lw 1\n",\
            "set style line 8 lt 8 pt 2 lw 1\n",\
            "set style line 9 lt 9 pt 2 lw 1\n",\
            "set style line 10 lt 10 pt 2 lw 1\n",\
            "set style line 11 lt 1 pt 7\n",\
            "set style line 12 lt 2 pt 8\n",\
            "set style line 13 lt 3 pt 9\n",\
            "set style line 14 lt 4 pt 10\n",\
            "set style line 15 lt 5 pt 11\n",\
            "set style line 16 lt 6 pt 12\n",\
            "set style line 17 lt 7 pt 13\n",\
            "set style line 18 lt 8 pt 14\n",\
            "set style line 19 lt 9 pt 15\n",\
            "set style line 20 lt 10 pt 16\n"]
    else:
        gnu_commands = ["set zero 1e-20\n","set style line 1 lt 1 lw 1 \n",\
            "set style line 2 lt 2 lw 1\n",\
            "set style line 3 lt 3 lw 1\n",\
            "set style line 4 lt 4 lw 1\n",\
            "set style line 5 lt 5 lw 1\n",\
            "set style line 6 lt 6 lw 1\n",\
            "set style line 7 lt 7 lw 1\n",\
            "set style line 8 lt 8 lw 1\n",\
            "set style line 9 lt 9 lw 1\n",\
            "set style line 10 lt 10 pt 2 lw 1\n",\
            "set style line 11 lt 1 pt 7\n",\
            "set style line 12 lt 2 pt 8\n",\
            "set style line 13 lt 3 pt 9\n",\
            "set style line 14 lt 4 pt 10\n",\
            "set style line 15 lt 5 pt 11\n",\
            "set style line 16 lt 6 pt 12\n",\
            "set style line 17 lt 7 pt 13\n",\
            "set style line 18 lt 8 pt 14\n",\
            "set style line 19 lt 9 pt 15\n",\
            "set style line 20 lt 10 pt 16\n"]

    # Set the x and y axes labels.
    x_axis_label_command = "set xlabel \"" + x_label + "\" \n"
    y_axis_label_command = "set ylabel \"" + y_label + "\" \n"
    gnu_commands.append(x_axis_label_command)
    gnu_commands.append(y_axis_label_command)
    title_command = "set title \"" + title_string + "\"\n"
    gnu_commands.append(title_command)

    # If the x,y ranges were specified, set them to the requested values.
    if not x_range == None:
        x_range_string = "set xrange[" + str(round(x_range[0],2)) + ":" + str(round(x_range[1])) + "]\n"
        gnu_commands.append(x_range_string)

    if not y_range == None:
        y_range_string = "set yrange[" + str(round(y_range[0],2)) + ":" + str(round(y_range[1])) + "]\n"
        gnu_commands.append(y_range_string)

    # Calculated data (no errors).
    # Step through the filename list and plot with the specified legends.
    # Plotting commands look like
    # plot "plotexp.dat" ind 0:0 usi 1:2:3 ti "A. Smith (1992)" w yerr linestyle 11,\
    # "plotexp.dat" ind 1:1 usi 1:2:3 ti "B. Smith (1993)" w yerr linestyle 12,\
    # "plotexp.dat" ind 2:2 usi 1:2:3 ti "C. Smith (1999)" w yerr linestyle 13
    plot_command = "plot "
    for n in range(len(calculated_legend)):
        # If this is not the first iteration, then a comma is needed after the last command in the plot list
        # if not n == 0 and should_plot_experimental_data:
        # plot_command = plot_command + ", "
        this_legend_title    = calculated_legend[n]
        this_set_index = n
        if withpoints:
            plot_command = plot_command + "\"" + plot_data_file_name + "\" ind " + str(this_set_index) + ":" + str(this_set_index) + " title \"" + this_legend_title + "\" with linespoints linestyle "  + str(n+1)  # original
        else:
            plot_command = plot_command + "\"" + plot_data_file_name + "\" ind " + str(this_set_index) + ":" + str(this_set_index) + " title \"" + this_legend_title + "\" with lines linestyle "  + str(n+1) 
        if not n == (len(calculated_legend) - 1):
            # more to follow.  Put on a line continuation "\"
            plot_command = plot_command + ", \\\n"

    plot_command = plot_command + "\n" + "   \n"

    if log_y:
        scale_command  = "set logscale y \n"
        gnu_commands.append(scale_command)

    # Add the plot command
    gnu_commands.append(plot_command)

    with open("gnuplot_commands.rachel","w") as gnuplot_command_file:
        #gnuplot_command_file.write("plot \"testing.txt\" with yerrorbars\n")
        gnuplot_command_file.writelines(gnu_commands)
    command_line = "gnuplot gnuplot_commands.rachel -"
    gnuplot_subprocess = subprocess.call(command_line,shell=True) # Must run this way, or the gnuplot window disappears (with os.popen)

    return 0



def better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend,chi_squared_string="",withpoints=False,x_range=None,y_range=None,log_y=True):
    """Launch gnuplot to display some data.

    NOTE: THIS NEEDS WORK.  IF ALL POINTS ARE NEGATIVE FOR ONE SET, GNUPLOT WILL GIVE AN ERROR:
    plot "rachel_collision.txt" ind 0:0 title "Q(w)" with lines linestyle 1
                                                                           ^
                                                                           "gnuplot_commands.rachel", line 26: all points y value undefined!

    because it deletes negative points on the default log scale used below.

    For now, just x,y plotting
    
    The legend lists must have the same number of entries as the number of data
    sets in the corresponding file.

    In this method, the experimental data legend must be passed in as None, if
    it shouldn't be plotted.

    Empty sets are plotted as a yield of 1.0 at a spin of -1.  This is a quick
    fix for empty sets and will be improved later.


    """

    if not experimental_legend == None:
        should_plot_experimental_data = True
    else:
        should_plot_experimental_data = False

    print "Errors may occur for more than 10 sets!"
    # Define line and point styles for the plot
    # Set zero to 10**(-20).  August 7, 2010.
    # gnu_commands = ["set zero 1e-20\n","set xrange[0:]\n","set style line 1 lt 1 pt 2 lw 1 \n",\
    # Not setting xrange now, because skipping sets is working properly (no dummy points plotted).
    if withpoints:
        gnu_commands = ["set zero 1e-20\n","set style line 1 lt 1 pt 2 lw 1 \n",\
            "set style line 2 lt 2 pt 2 lw 1\n",\
            "set style line 3 lt 3 pt 2 lw 1\n",\
            "set style line 4 lt 4 pt 2 lw 1\n",\
            "set style line 5 lt 5 pt 2 lw 1\n",\
            "set style line 6 lt 6 pt 2 lw 1\n",\
            "set style line 7 lt 7 pt 2 lw 1\n",\
            "set style line 8 lt 8 pt 2 lw 1\n",\
            "set style line 9 lt 9 pt 2 lw 1\n",\
            "set style line 10 lt 10 pt 2 lw 1\n",\
            "set style line 11 lt 1 pt 7\n",\
            "set style line 12 lt 2 pt 8\n",\
            "set style line 13 lt 3 pt 9\n",\
            "set style line 14 lt 4 pt 10\n",\
            "set style line 15 lt 5 pt 11\n",\
            "set style line 16 lt 6 pt 12\n",\
            "set style line 17 lt 7 pt 13\n",\
            "set style line 18 lt 8 pt 14\n",\
            "set style line 19 lt 9 pt 15\n",\
            "set style line 20 lt 10 pt 16\n"]
    else:
        gnu_commands = ["set zero 1e-20\n","set style line 1 lt 1 lw 1 \n",\
            "set style line 2 lt 2 lw 1\n",\
            "set style line 3 lt 3 lw 1\n",\
            "set style line 4 lt 4 lw 1\n",\
            "set style line 5 lt 5 lw 1\n",\
            "set style line 6 lt 6 lw 1\n",\
            "set style line 7 lt 7 lw 1\n",\
            "set style line 8 lt 8 lw 1\n",\
            "set style line 9 lt 9 lw 1\n",\
            "set style line 10 lt 10 pt 2 lw 1\n",\
            "set style line 11 lt 1 pt 7\n",\
            "set style line 12 lt 2 pt 8\n",\
            "set style line 13 lt 3 pt 9\n",\
            "set style line 14 lt 4 pt 10\n",\
            "set style line 15 lt 5 pt 11\n",\
            "set style line 16 lt 6 pt 12\n",\
            "set style line 17 lt 7 pt 13\n",\
            "set style line 18 lt 8 pt 14\n",\
            "set style line 19 lt 9 pt 15\n",\
            "set style line 20 lt 10 pt 16\n"]

    # Set the x and y axes labels.
    x_axis_label_command = "set xlabel \"" + x_label + "\" \n"
    y_axis_label_command = "set ylabel \"" + y_label + "\" \n"
    gnu_commands.append(x_axis_label_command)
    gnu_commands.append(y_axis_label_command)
    title_command = "set title " + chi_squared_string + "\n"
    gnu_commands.append(title_command)

    # If the x,y ranges were specified, set them to the requested values.
    if not x_range == None:
        x_range_string = "set xrange[" + str(round(x_range[0],2)) + ":" + str(round(x_range[1])) + "]\n"
        gnu_commands.append(x_range_string)

    if not y_range == None:
        y_range_string = "set yrange[" + str(round(y_range[0],2)) + ":" + str(round(y_range[1])) + "]\n"
        gnu_commands.append(y_range_string)

    # Calculated data (no errors).
    # Step through the filename list and plot with the specified legends.
    # Plotting commands look like
    # plot "plotexp.dat" ind 0:0 usi 1:2:3 ti "A. Smith (1992)" w yerr linestyle 11,\
    # "plotexp.dat" ind 1:1 usi 1:2:3 ti "B. Smith (1993)" w yerr linestyle 12,\
    # "plotexp.dat" ind 2:2 usi 1:2:3 ti "C. Smith (1999)" w yerr linestyle 13
    plot_command = "plot "
    for n in range(len(calculated_legend)):
        # If this is not the first iteration, then a comma is needed after the last command in the plot list
        if not n == 0 and should_plot_experimental_data:
            plot_command = plot_command + ", "
        this_legend_title    = calculated_legend[n]
        if should_plot_experimental_data:
            this_set_index = 2*n
        else:
            this_set_index = n
        if withpoints:
            plot_command = plot_command + "\"" + plot_data_file_name + "\" ind " + str(this_set_index) + ":" + str(this_set_index) + " title \"" + this_legend_title + "\" with linespoints linestyle "  + str(n+1)  # original
        else:
            plot_command = plot_command + "\"" + plot_data_file_name + "\" ind " + str(this_set_index) + ":" + str(this_set_index) + " title \"" + this_legend_title + "\" with lines linestyle "  + str(n+1) 
        if not n == (len(calculated_legend) - 1):
            # more to follow.  Put on a line continuation "\"
            plot_command = plot_command + ", \\\n"
        if should_plot_experimental_data:
            if n == (len(calculated_legend) - 1):
                plot_command = plot_command + ", \\\n"
            this_legend_title = experimental_legend[n] 
            plot_command = plot_command +  "\"" + plot_data_file_name + "\" ind " + str(2*n + 1) \
              + ":" + str(2*n + 1) + " usi 1:2:3 title \"" + this_legend_title \
              + "\" with yerrorbars linestyle " + str(11 + n)
            if not n == (len(calculated_legend) - 1):
                # More to follow.  Put on a comma and line continuation. "\"
                plot_command = plot_command + " \\\n"

    plot_command = plot_command + "\n" + "   \n"

    if log_y:
        scale_command  = "set logscale y \n"
        gnu_commands.append(scale_command)

    # Experimental data (error column included).
    # Step through the filename list and plot with the specified legends.

    # Add the plot command
    gnu_commands.append(plot_command)

    with open("gnuplot_commands.rachel","w") as gnuplot_command_file:
        gnuplot_command_file.writelines(gnu_commands)
    command_line = "gnuplot gnuplot_commands.rachel -"
    gnuplot_subprocess = subprocess.call(command_line,shell=True) # Must run this way, or the gnuplot window disappears (with os.popen)



def welcome(hide=False):
    """Display splash screen for the user.

    Displays primary credits in a jpg format.

    """

    global splash

    if hide:
        splash.hide()
        return
        
    # Create a window called splash.
    splash = gtk.Window(gtk.WINDOW_TOPLEVEL) 
    splash.set_decorated(False)
    splash.set_position(gtk.WIN_POS_CENTER)

    hbox = gtk.HBox()
    hbox.show()
    splash.add(hbox)

    # Load image.
    logo = gtk.Image()
    the_logo_file = GLOBAL_SETUP_DICT["RACHEL_DIRECTORY"] + "/necessary_files/rachel-logo.jpg"
    logo.set_from_file(the_logo_file)
    hbox.add(logo)
    logo.show()

    # Display the window.
    splash.show()

def call_rochester_srim_server(beam_Z=None, beam_mass=None, target_density=None, target_Z=None, target_name=None, target_mass=None, initial_energy=None, target_thickness_or_exit_energy=None, fractional_padding_on_energy_meshpoints=None, number_of_meshpoints=None, thickness_or_exit_energy_flag=None):
    """Gets SRIM stopping power, exit energy, range.

    Replaces old methods on Nov. 1 2012

    """

    def internal_find_all_in_list(listtosearch,stringstomatch):
        """Finds the index of all instances matching stringstomatch
        
        Finds the index in the list 'listtosearch' that contains all of the items
        in 'stringstomatch'.  

        Both arguments should be lists of strings.
        It separates at whitespaces.
        Don't leave whitespaces in 'stringstomatch'!

        """

        matching_lines = []
        i = 0
        while i < len(listtosearch):
            linematchessofar = False   # Added this 2010/06/04 because the variable was 
                                       # undefined if early lines were too short.
            wordsinline = listtosearch[i].split()
            if len(wordsinline) >= len(stringstomatch):
                j = 0  # reset the word counter
                linematchessofar = True
                while j < len(stringstomatch) and linematchessofar:
                    if wordsinline.count(stringstomatch[j]) < 1:
                        linematchessofar = False  # one miss means the whole line is not a match
                    j = j + 1

                # Now that all words are tested, if linematchessofar is True
                # then the line is found
            if linematchessofar: 
                matching_lines.append(i)

            i = i + 1

        return matching_lines

    def get_errors(page_lines):
        """Gets string error messages from the lines returned from the server.

        Returns the error strings as a list.

        """

        error_strings = []
        for line in page_lines:
            if "error" in line:
                error_strings.append(line)

        return error_strings

    def is_stopped(page_lines):
        """Returns True if the beam is stopped; otherwise False.

        """

        search_terms = ["Beam","is","stopped","in","target."]
        matching_line_numbers = internal_find_all_in_list(page_lines,search_terms)
        if len(matching_line_numbers) == 0:
            return False
        else:
            return True

    def get_range(page_lines):
        """Returns the calculated range, if it is in the server response; otherwise None

        """

        search_terms = ["Range:","mg/cm^2"]
        matching_line_numbers = internal_find_all_in_list(page_lines,search_terms)
        if len(matching_line_numbers) == 0:
            return None
        else:
            # Assumes that only one line contains the tags in search_terms.
            line_fields = page_lines[matching_line_numbers[0]].split()
            calculated_range = float(line_fields[1])
            return calculated_range

    def get_calculated_target_thickness(page_lines):
        """Returns the calculated target thickness, if it is in the server response; otherwise None

        This is used as a check that the calculated exit energy corresponds to the
        user's known target thickness.

        """

        search_terms = ["Thickness","that","gives","this","energy:"]
        matching_line_numbers = internal_find_all_in_list(page_lines,search_terms)
        if len(matching_line_numbers) == 0:
            return None
        else:
            # Assumes that only one line contains the tags in search_terms.
            line_fields = page_lines[matching_line_numbers[0]].split()
            calculated_target_thickness = float(line_fields[5])
            return calculated_target_thickness

    def get_calculated_exit_energy(page_lines):
        """Returns the calculated exit energy, if it is in the server response; otherwise None

        """

        search_terms = ["Exit","energy:","MeV"]
        matching_line_numbers = internal_find_all_in_list(page_lines,search_terms)
        if len(matching_line_numbers) == 0:
            return None
        else:
            # Assumes that only one line contains the tags in search_terms.
            line_fields = page_lines[matching_line_numbers[0]].split()
            calculated_exit_energy = float(line_fields[2])
            return calculated_exit_energy 

    # Check that all quantities were defined.
    if None in [beam_Z, beam_mass, target_density, target_Z, target_mass, initial_energy, target_thickness_or_exit_energy, fractional_padding_on_energy_meshpoints, number_of_meshpoints, thickness_or_exit_energy_flag]:
        # One or more quantities were not defined.  Return only an error and None for all other calculated quantities.
        return {"error_strings":["error - invalid query"], "calculated_exit_energy":None, "calculated_range":None, "calculated_target_thickness":None, "energies":None,"stopping_powers":None}

    if thickness_or_exit_energy_flag == "-e-":
        exit_energy_is_known = True
    else:
        exit_energy_is_known = False
    # Define the things that must be returned.  These will be returned empty, if there are fatal errors
    energies = []
    stopping_powers = []
    calculated_exit_energy = None
    calculated_range = None
    calculated_target_thickness = None

    # Get a random request number to send to the server.  This will provide one of the checks that the returned page is from this request.
    request_number = random.randint(100000000,999999999)

    # Make the server call to get stopping powers.
    url_text = "http://www-user.pas.rochester.edu/~gosia/stoppingpowerqueue/queuecall.py/call/?beam_Z=" + str(beam_Z) + "&beam_mass=" + str(beam_mass) + "&target_density=" + str(target_density) + "&target_Z=" + str(target_Z) + "&target_mass=" + str(target_mass) + "&initial_energy=" + str(initial_energy) + "&target_thickness_or_exit_energy=" + str(target_thickness_or_exit_energy) + "&fractional_padding_on_energy_meshpoints=" + str(fractional_padding_on_energy_meshpoints) + "&number_of_meshpoints=" + str(number_of_meshpoints) + "&thickness_or_exit_energy_flag=" + str(thickness_or_exit_energy_flag) + "&request_number=" + str(request_number)

    response = urllib.urlopen(url_text)
    full_page = response.read()

    page_lines = full_page.split("\n")

    # Check for an error on the last line.
    if "error" in page_lines[-2]:
        # An error was returned from the server.
        error_occurred = True
    else:
        error_occurred = False

    # Get all error messages from server.
    error_strings = get_errors(page_lines)

    # See if the server said the beam is stopped.
    stopped_beam = is_stopped(page_lines)

    if stopped_beam:
        # Get the range determined by the server.
        calculated_range = get_range(page_lines)
    else:
        # If the beam is not stopped, and the exit energy was not defined by the user, then get the server's calculated exit energy.
        if not exit_energy_is_known:
            calculated_exit_energy = get_calculated_exit_energy(page_lines)
            calculated_target_thickness = get_calculated_target_thickness(page_lines)

    # Find the request number in the page, and check that it matches.
    try:
        request_tags_list = ["Filled","request","number"]
        matching_lines = internal_find_all_in_list(page_lines,request_tags_list)
        request_line_number = matching_lines[0]
        request_line = page_lines[request_line_number]
        returned_request_number = int(request_line.split()[3])
        if request_number == returned_request_number:
            good_request_number = True
            #print "Request number matches."
        else:
            good_request_number = False
            error_strings.append("error - request number does not match")
            #print "REQUEST NUMBER DOESN'T MATCH."

        if good_request_number:

            header_tags_list = ["Beam","Stopping", "power","meshpoints)"]
            matching_lines = internal_find_all_in_list(page_lines,header_tags_list)
            #print "matching line numbers: ",matching_lines
            meshpoint_header_line_number = matching_lines[0]
            #print "Header line numbers: ",meshpoint_header_line_number

            header_line_fields = page_lines[meshpoint_header_line_number].split()
            #print "header line fields: ",header_line_fields 
            expected_number_of_meshpoints = int(page_lines[meshpoint_header_line_number].split()[3].strip("("))
            #print expected_number_of_meshpoints, "meshpoints expected"

            # Get the line number where the stopping power data should begin.
            stopping_power_line_number = meshpoint_header_line_number + 4

            more_data = True
            while more_data:
                line = page_lines[stopping_power_line_number]
                line_fields = line.split()
                if not len(line_fields) == 2:
                    # No more data 
                    more_data = False
                else:
                    # Looks like another line of stopping power data.
                    try:
                        energy_meshpoint = float(line_fields[0])
                        energies.append(energy_meshpoint)
                        stopping_power_meshpoint = float(line_fields[1])
                        stopping_powers.append(stopping_power_meshpoint)
                    except:
                        more_data = False
                    stopping_power_line_number += 1

            # Check that we have found the correct number of energies and stopping powers.
            if not (len(energies) == len(stopping_powers) == expected_number_of_meshpoints):
                new_error_message = "Did not get the expected " + str(expected_number_of_meshpoints) + " meshpoints from the Rochester server!"
                error_strings.append(new_error_message)

        print "Stopping power meshpoints:"
        for i in range(len(energies)):
            print energies[i], stopping_powers[i]

        return {"error_strings":error_strings, "calculated_exit_energy":calculated_exit_energy, "calculated_range":calculated_range, "calculated_target_thickness":calculated_target_thickness, "energies":energies,"stopping_powers":stopping_powers}

    except:
        # Could not process output, or server error was fatal.
        return {"error_strings":error_strings, "calculated_exit_energy":calculated_exit_energy, "calculated_range":calculated_range, "calculated_target_thickness":calculated_target_thickness, "energies":energies,"stopping_powers":stopping_powers}
 


class notes:
    """A class to save user notes in each session file.

    This is saved in the session file, so that notes files won't be confused
    when changing pickled sessions.

    """

    def __init__(self):
        """Create spaces for user notes.

        Eventually, the procedure_log will be updated with every action that is
        included in the "undo" stack.

        Each log is a list of strings added to a dictionary.  The dictionary
        structure makes it simpler to add types of logs.

                    "user_notes" - Any notes the user adds with a call to an editor.
                 "procedure_log" - Will include time-stamped actions, errors, etc.  Also record results, e.g. chi-squared.

        """
        
        self.temporary_editor_file_name = ".rachel_temporary_editor_file"

        creation_time_stamp = "Log created " + get_system_time_stamp()
        self.all_logs = {                                    \
                    "user_notes":[creation_time_stamp], \
                 "procedure_log":[creation_time_stamp]  \
                   }

    def edit_log(self,log_name):
        """Edit a log.

        If the log is not in memory, print and return an error string to help the user.
        Success, return None.

        """

        # Make sure that the log exists.
        try:
            self.all_logs[log_name]
        except:
            # Log not found
            print "Log \"" + str(log_name) + "\" not found."
            go_ahead = None
            while go_ahead == None:
                go_ahead = yes_no_prompt("Create log? [y/n]: ",None)
            if go_ahead:
                self.all_logs[log_name] = []
            else:
                return "Log \"" + str(log_name) + "\" not found."

        try:
            GLOBAL_SETUP_DICT["TEXT_EDITOR"]
            self.editor_command = GLOBAL_SETUP_DICT["TEXT_EDITOR"]
        except:
            # No editor is named in the .rachel_setup file.  Has one been set previously in this notes object?
            try:
                self.editor_command
            except:
                # No editor has been set in this object.
                editor_command = DEFAULT_EDITOR_COMMAND
                print "You can add the line \n  TEXT_EDITOR = vim\n(or the name of any other available editor)\nto the .rachel_setup file."
                new_editor = raw_input("Enter the editor command (no file name) or press enter to use \"" + editor_command + "\": ")
                if not new_editor.lstrip() == "":
                    self.editor_command = new_editor
                else:
                    self.editor_command = editor_command


        # Write the current state of this log to a temp file:
        with open(self.temporary_editor_file_name,"w") as temp_file:
            temp_file.writelines(self.all_logs[log_name])

        try:
            command_line = self.editor_command + " " + self.temporary_editor_file_name
            subprocess.call(command_line,shell=True)
        except:
            print "Editor failed.  Changes were not saved."
            print "Error: " + str(sys.exc_info())
            return "Editor not found or error exiting editor."

        # Now read the edited log from the temp file.
        with open(self.temporary_editor_file_name,"r") as temp_file:
            self.all_logs[log_name] = temp_file.readlines()

        return None
            

    def return_log(self,log_name):
        """Return the list of strings in a log.

        If the log name is invalid (not in memory), return None.

        A deep copy is made, so that modifications elsewhere do not change the log. 

        """

        # Make a deep copy, so that modifications elsewhere do not change the log!
        try:
            dereferenced_log = copy.deepcopy(self.all_logs[log_name])
            return dereferenced_log 
        except:
            # Log not found.
            return None

    def print_log(self,log_name):
        try:
            log_copy = copy.deepcopy(self.all_logs[log_name])
            log_copy.append("End of log \"" + log_name + "\"")
            arguments_dict = {"text_lines":log_copy,"title":"Log: " + log_name}
            create_dialog_popup(arguments_dict)
            return None
        except:
            return "Unknown error in log, or log not found."

    def append_log(self,log_name,log_entry):
        """Will get time stamp, add the line with the time stamp first.

        This is for automated internal use, so no errors are printed.

        """

        try:
            self.all_logs[log_name]
        except:
            # Log not found
            return -1
            
        time_stamp = get_system_time_stamp() + "  "
        entry = time_stamp + log_entry
        self.all_logs[log_name].append(entry)

        return None


class popup_tips:
    """A class with methods for popup tips.

    init format: popup_tips(arguments_dict)

    where arguments_dict contains the keys:
    
    "tip_text" is a single string with \n to separate lines.
    "title" is a string for the title of the window
    "x_size" 
    "y_size"

    This will NOT handle control panels--only dialog types of popups.
    
    If the popups are allowed by a global variable, then it will make one.
    Otherwise, it will do nothing.

    """

    how_to_turn_off = "(To turn off popup tips add \"POPUP_TIPS = False\"\n to the .rachel_setup file.)\n"

    def close_window(self, widget):
        self.window.hide()
        return gtk.FALSE  # Returns a gtk FALSE signal so that the hidden window will be destroyed.

    def __init__(self,tip_keyword):

        # Load the help file data, if not already in memory.
        if TIPS_DICTIONARY.keys() == []:
            load_tips_data()

        try:
            tip_text   = TIPS_DICTIONARY[tip_keyword]
        except:
            tip_text = "The popup tip for this function cannot be found.\nYou can download the latest Rachel version from the Gosia Wiki:\nhttp://www-user.pas.rochester.edu/~gosia/mediawiki"

        title      = ""
        # text_lines is a list of strings, already formatted for length.

        # See if the tips popups are allowed.  If not, then nothing will be done.
        if GLOBAL_SETUP_DICT["POPUP_TIPS"]:

            self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)

            # A popup instead of a top-level window would need more work.  It
            # does not default to have a handle to grab and move it, and it
            # cannot be reset to the top after clicking another window (won't
            # take focus).

            self.window.set_default_size(600,500)
            self.window.set_resizable(True)  
            self.window.connect("destroy", self.close_window)
            self.window.set_title(title)
            self.window.set_border_width(0)

            box1 = gtk.VBox(False, 0)
            self.window.add(box1)
            box1.show()

            box2 = gtk.VBox(False, 10)
            box2.set_border_width(10)
            box1.pack_start(box2, True, True, 0)
            box2.show()

            sw = gtk.ScrolledWindow()
            sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
            textview = gtk.TextView()
            textbuffer = textview.get_buffer()
            # Set the font.
            the_font = pango.FontDescription("Courier 12")
            textview.modify_font(the_font)
            sw.add(textview)
            sw.show()
            textview.show()

            box2.pack_start(sw)

            # Print the text in the parameter "text_lines" in the box.
            full_text = ""
            full_text = full_text + self.how_to_turn_off
            text_lines = block_print_with_line_breaks(tip_text,50,True)
            for one_line in text_lines:
                full_text = full_text + "\n" + one_line
            textbuffer.set_text(full_text)

            hbox = gtk.HButtonBox()
            box2.pack_start(hbox, False, False, 0)
            hbox.show()

            vbox = gtk.VBox()
            vbox.show()
            hbox.pack_start(vbox, False, False, 0)

            separator = gtk.HSeparator()
            box1.pack_start(separator, False, True, 0)
            separator.show()

            box2 = gtk.VBox(False, 10)
            box2.set_border_width(10)
            box1.pack_start(box2, False, True, 0)
            box2.show()

            button = gtk.Button("Close")
            button.connect("clicked", self.close_window)
            box2.pack_start(button, True, True, 0)
            button.set_flags(gtk.CAN_DEFAULT)
            button.grab_default()
            button.show()
            self.window.show()

            textview.set_editable(False)
            textview.set_cursor_visible(False)
            textview.set_wrap_mode(gtk.WRAP_NONE)
            textview.set_justification(gtk.JUSTIFY_LEFT)

            # It is vital to return None.  If there is no return None line,
            # then the first popup created will be frozen and won't be active
            # or die until the method that spawned it is finished.  (Subsequent
            # windows created in the same execution of the code will work,
            # making it difficult to track down the problem.

            return None


class dialog_popup:
    """A class with methods for various kinds of textview popups.  

    init format: dialog_popup(arguments_dict)

    where arguments_dict contains the keys:
    
    "text_lines" is a list of lines, e.g. ["Hello","World"]
    "title" is a string for the title of the window
    "x_size" 
    "y_size"

    This will NOT handle control panels--only dialog types of popups.
    
    If the popups are allowed by a global variable, then it will make one.
    Otherwise, it will print to the standard output (terminal).

    """

    def close_window(self, widget):
        self.window.hide()
        return gtk.FALSE  # Returns a gtk FALSE signal so that the hidden window will be destroyed.

    def __init__(self,arguments_dictionary):

        text_lines = arguments_dictionary["text_lines"]
        title      = arguments_dictionary["title"]
        # text_lines is a list of strings, already formatted for length.

        # Optional arguments:
        if "x_size" in arguments_dictionary:
            user_set_x_size = True
            x_size = arguments_dictionary["x_size"]
        else:   
            user_set_x_size = False
        
        if "y_size" in arguments_dictionary:
            user_set_y_size = True
            y_size = arguments_dictionary["y_size"]
        else:   
            user_set_y_size = False

        # See if we need to force the popup against the user's settings:
        force_popup = False
        if "force_popup" in arguments_dictionary:
            if arguments_dictionary["force_popup"]:
                # This will force a popup if it is set to True, regardless of
                # whether the global pop-up setting is True.  This is useful for
                # things that (eventually) must be sent to a large popup, such as
                # quantities of numerical output that are too large for the
                # terminal to display clearly.
                force_popup = True
            else:
                force_popup = False

        # See if the popups are allowed.  If not, then just print to the
        # terminal.  This option is contained in the global rachel setup
        # dictionary, which can be modified in the .rachel_setup file.  The
        # code can override this global setting if some output must always go
        # to a popup.
        if GLOBAL_SETUP_DICT["POPUPS"] or force_popup:

            self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
            if user_set_x_size and user_set_y_size:
                self.window.set_default_size(x_size,y_size)
            else:
                self.window.set_default_size(600,500)
            self.window.set_resizable(True)  
            self.window.connect("destroy", self.close_window)
            self.window.set_title(title)
            self.window.set_border_width(0)

            box1 = gtk.VBox(False, 0)
            self.window.add(box1)
            box1.show()

            box2 = gtk.VBox(False, 10)
            box2.set_border_width(10)
            box1.pack_start(box2, True, True, 0)
            box2.show()

            sw = gtk.ScrolledWindow()
            sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
            textview = gtk.TextView()
            textbuffer = textview.get_buffer()
            # Set the font.
            the_font = pango.FontDescription("Courier 12")
            textview.modify_font(the_font)
            sw.add(textview)
            sw.show()
            textview.show()

            box2.pack_start(sw)

            # Print the text in the parameter "text_lines" in the box.
            full_text = ""
            for one_line in text_lines:
                full_text = full_text + "\n" + one_line
            textbuffer.set_text(full_text)

            hbox = gtk.HButtonBox()
            box2.pack_start(hbox, False, False, 0)
            hbox.show()

            vbox = gtk.VBox()
            vbox.show()
            hbox.pack_start(vbox, False, False, 0)

            separator = gtk.HSeparator()
            box1.pack_start(separator, False, True, 0)
            separator.show()

            box2 = gtk.VBox(False, 10)
            box2.set_border_width(10)
            box1.pack_start(box2, False, True, 0)
            box2.show()

            button = gtk.Button("Close")
            button.connect("clicked", self.close_window)
            box2.pack_start(button, True, True, 0)
            button.set_flags(gtk.CAN_DEFAULT)
            button.grab_default()
            button.show()
            self.window.show()

            textview.set_editable(False)
            textview.set_cursor_visible(False)
            textview.set_wrap_mode(gtk.WRAP_NONE)
            textview.set_justification(gtk.JUSTIFY_LEFT)

            # It is vital to return None.  If there is no return None line,
            # then the first popup created will be frozen and won't be active
            # or die until the method that spawned it is finished.  (Subsequent
            # windows created in the same execution of the code will work,
            # making it difficult to track down the problem.

            return None


        else:
            # pop-ups are not allowed.  Just print to std out.
            for one_line in text_lines:
                print one_line
            print  # Add a blank line to separate output to the terminal.
            return None


class data_storage:
    """A temporary data dump for large amounts of data, 
    
    such as amplitude vs. time calculations.
    
    This object is not saved, because it is too large.

    """

    def __init__(self):
        self.all_data = {}

    def set(self,key,data):
        self.all_data[key] = copy.deepcopy(data)

    def get(self,key):
        return copy.deepcopy(self.all_data[key])

def line_is_comment(text_line):
    """Returns True if the text line begins with a #.

    Whitespace is removed from the beginning of the line.

    "   #  " would still be a comment.

    """

    line_fields = text_line.split()
    if len(line_fields) == 0:
        # Blank line
        return False
    elif line_fields[0][0] == "#":
        return True
    else:
        return False

def line_is_whitespace(text_line):
    """Returns True if there is only whitespace on the line.

    string "" returns True also.

    """

    text_line = text_line.strip()
    if len(text_line) == 0:
        return True
    else:
        return False

def find_all_in_list(listtosearch,stringstomatch):
    """Finds the index of all instances matching stringstomatch
    
    Finds the index in the list 'listtosearch' that contains all of the items
    in 'stringstomatch'.  

    Both arguments should be lists of strings.
    It separates at whitespaces.
    Don't leave whitespaces in 'stringstomatch'!

    """

    matching_lines = []
    i = 0
    while i < len(listtosearch):
        linematchessofar = False   # Added this 2010/06/04 because the variable was 
                                   # undefined if early lines were too short.
        wordsinline = listtosearch[i].split()
        if len(wordsinline) >= len(stringstomatch):
            j = 0  # reset the word counter
            linematchessofar = True
            while j < len(stringstomatch) and linematchessofar:
                if wordsinline.count(stringstomatch[j]) < 1:
                    linematchessofar = False  # one miss means the whole line is not a match
                j = j + 1

            # Now that all words are tested, if linematchessofar is True
            # then the line is found
        if linematchessofar: 
            matching_lines.append(i)

        i = i + 1

    return matching_lines

def findinlist(listtosearch,stringstomatch):
    """Finds the index of the desired string in a list strings.
    
    Finds the index in the list 'listtosearch' that contains all of the items
    in 'stringstomatch'.  

    Both arguments should be lists of strings.
    It separates at whitespaces.
    Don't leave whitespaces in 'stringstomatch'!
    """

    found = False
    linematchessofar = False   # Added this 2010/06/04 because the variable was 
                               # undefined if early lines were too short.
    i = 0
    while i < len(listtosearch) and not found:
        wordsinline = listtosearch[i].split()
        if len(wordsinline) >= len(stringstomatch):
            j = 0  # reset the word counter
            linematchessofar = True
            while j < len(stringstomatch) and linematchessofar:
                if wordsinline.count(stringstomatch[j]) < 1:
                    linematchessofar = False  # one miss means the whole line is not a match
                j = j + 1

            # Now that all words are tested, if linematchessofar is True
            # then the line is found
        if linematchessofar: 
            found = True
        else:
            i = i + 1

    if found:
        return i
    else:
        return -1  # -1 indicates that no match was found in the whole list
            
def factorial_term(I_1,K_1,n):
    """Calculates the sqrt(...) factorial term in B&M eqn. 4-95, 4-98.

    This is taken from getgoing.for and translated into python.
    """
    a_plus  = int(I_1 + K_1)
    a_minus = int(I_1 - K_1)
    b_plus  = int(I_1 + K_1 + n)
    b_minus = int(I_1 - K_1 - n)
    big_number = 1.   # That's kinda funny.

    for i in range(b_minus + 1, b_plus + 1):
        big_number = big_number * i

    for i in range(a_minus + 1, a_plus + 1):
        big_number = big_number / i

    sqrt_factorial_term = math.sqrt(big_number)
    return sqrt_factorial_term

def kronecker(a,b):
    """Returns the Kronecker delta(a,b) = integer 1 or 0
    
    Works with reals and ints, but rounds to the nearest tenth so that float
    spins will be matched to the nearest half-integer spin.

    """
    new_a = round(a,1)
    new_b = round(b,1)
    if a == b:
        return 1
    else:
        return 0

def equivalent_half_integer(float_1,float_2):
    """Returns True if the two floats are equal to the nearest half-integer.

    """
    #print float_1,float_2
    two_times_float_1 = int(round(2. * float_1))
    two_times_float_2 = int(round(2. * float_2))
    if two_times_float_1 == two_times_float_2:
        return True
    else:
        return False

class undo_class:
    def __init__(self,option=None):
        if option == "recover":
            # Recover from a force-quit the last undo file
            command_line = "ls .rachel_undo_information.* > .recovery_list"
            subprocess.call(command_line,shell=True)
            with open(".recovery_list","r") as recovery_file:
                undo_files = recovery_file.readlines()
            self.undo_numbers = []
            self.undo_stack = []
            for one_line in undo_files:
                self.undo_numbers.append(int(one_line.split(".")[2].strip("\n")))
            self.undo_numbers.sort()
            self.next_undo_number = self.undo_numbers[-1] 
            for one_number in self.undo_numbers:
                self.undo_stack.append([one_number,"Recovered action"])
            try:
                self.maximum_undo_steps = GLOBAL_SETUP_DICT["MAXIMUMUNDOSTEPS"]
            except:
                self.maximum_undo_steps = MAXIMUMUNDOSTEPS
            setup_globals("unpickle",undo_files[-1].strip("\n"),True)
        else:
            self.wipe()
            self.next_undo_number = 0 # the index in the undo_stack; not the file number.
            self.undo_stack = []
            try:
                self.maximum_undo_steps = GLOBAL_SETUP_DICT["MAXIMUMUNDOSTEPS"]
            except:
                self.maximum_undo_steps = MAXIMUMUNDOSTEPS


    def save(self,description):

        # If we have reached the maximum number of undo steps, delete the first
        # file and the first entry in the undo_stack.
        if len(self.undo_stack) == self.maximum_undo_steps + 1:
            self.next_undo_number = self.next_undo_number - 1
            command_line = "rm " + UNDOBASEFILENAME + str(self.undo_stack[0][0])
            subprocess.call(command_line,shell=True)
            del self.undo_stack[0]


        # If the next undo number is not the final undo number in the stack,
        # then that means that undo operations have been done, and the later
        # undo files and stack entries should be deleted first.
        if self.next_undo_number  < len(self.undo_stack):
            for one_entry in self.undo_stack[self.next_undo_number:]:
                undo_file_number = one_entry[0]
                command_line = "rm " + UNDOBASEFILENAME + str(undo_file_number)
                subprocess.call(command_line,shell=True)
            del self.undo_stack[self.next_undo_number:]
            self.next_undo_number = len(self.undo_stack) 

        # Add the undo information to the stack for this save operation.
        if self.next_undo_number == 0:
            next_file_number = 0
        else:
            next_file_number = self.undo_stack[self.next_undo_number-1][0] + 1
        self.undo_stack.append([next_file_number,description])

        # Pickle the undo information.
        pickle_file_name = UNDOBASEFILENAME + str(next_file_number)
        setup_globals("pickle",pickle_file_name,True)  # True means not to prompt yes/no or give output.

        # Increment the next undo number
        self.next_undo_number = self.next_undo_number + 1

        investigated_nucleus.notes.append_log("procedure_log",description + " completed")

    def undo(self,silent=False,force=False):
        """Set the GUI back to the previous state.

        If silent = True, then don't print anything.
        If force = True, then force re-reading the only undo file, if there is no more undo information

        """
            
        if len(self.undo_stack) == 0:
            if not silent:
                print "No more undo information."
                print ""
            return -1

        if not silent:
            print ""
            message = "UNDO: "
            print message,

        # Get the next-to-last file number in the undo files.
        if (not force) and self.next_undo_number == 0:
            if not silent:
                message = message + "No more undo information."
                print "No more undo information."
                print ""
            return -1

        if not silent:
            print "\"",self.undo_stack[self.next_undo_number - 1][1],"\""
            message = message + "\"" + self.undo_stack[self.next_undo_number - 1][1] + "\""
            print ""

        # Compose file name for the undo operation.
        if self.next_undo_number <= 1:
            # If this is the earliest undo file.
            undo_file_number = self.undo_stack[0][0]
        else:
            undo_file_number = self.undo_stack[self.next_undo_number - 2][0]
        undo_file_name = UNDOBASEFILENAME +  str(undo_file_number)

        setup_globals("reset")  # Trying this.
        setup_globals("unpickle",undo_file_name,True)  # True tells the setup_globals function not to prompt yes/no.


        # Now set the undo step to the current one.
        self.next_undo_number = self.next_undo_number -1  # The index of the undo_stack.

        # Write the undo message to the log.
        investigated_nucleus.notes.append_log("procedure_log",message + "(removed from log above)")

        return 0

    def wipe(self):
        """Deletes all undo files.

        """

        command_line = "rm " + UNDOBASEFILENAME + "*"
        # subprocess.call waits for the process to complete.
        with open(".rachel_garbage","w") as garbage_file:
            ls_subprocess = subprocess.call(command_line,shell=True,stderr=garbage_file)
        # Clear the undo information stack
        self.undo_stack = []
        self.next_undo_number = 0 


    def redo(self,silent=False):
        """Sets the GUI state to the next higher undo state if it exists.

        """

        # If the undo steps went back all the way to the first saved undo step,
        # then the next undo number would have been set to 0.  Reset it to 1.
        if self.next_undo_number == 0:
            self.next_undo_number = 1

        if self.next_undo_number + 1 > len(self.undo_stack):
            if not silent:
                print ""
                print "No more redo information."
                print ""
            return -1
        else:

            # Compose file name for the undo operation.
            redo_file_name = UNDOBASEFILENAME +  str(self.undo_stack[self.next_undo_number][0])
            # Redo the operation
            setup_globals("reset")  # trying to fix a bug in some undo/redo operations.
            setup_globals("unpickle",redo_file_name,True)  # True tells the setup_globals function not to prompt yes/no.

            message = "REDO: \"" + self.undo_stack[self.next_undo_number][1] + "\""
            # Report the operation redone.
            if not silent:
                print ""
                print message 
                print ""

            # Make a log entry that it was undone.
            investigated_nucleus.notes.append_log("procedure_log",message)

            # Set the new undo step number for the next undo/redo step.
            self.next_undo_number = min(self.next_undo_number + 1,self.maximum_undo_steps+1)

            return 0

class matrix_element:
    """This class replaces only the matrix element indices, R1, R2, etc.

    The new object format allows storage of a rule and a set of parameter
    names, so that matrix elements can be updated by changing rule parameters.

    """

    def __init__(self,current_value = None, rule_string = "", \
      is_master = False, master_initial_band_name = None, master_final_band_name = None, \
      master_initial_spin = None, master_final_spin = None, master_multipole_string = None, \
      lower_limit = None, upper_limit = None):
        """Creates the matrix element value and coupling information.

        The multipole number (1--6, 7 and 8 for M1, M2) and the initial and
        final band names and spins should be used in the keys to these objects.
        The matrix element does not store them.  They are used to look up the
        matrix element object.

        Example of creation of a matrix element object:
        matrix_element(current_value = 1.0, rule_string = "par[0] + par[1]*(ii*(ii+1.0) - fi*(fi+1.0))", \
          is_master = True, upper_limit = 10., lower_limit = 0.1, \
          master_initial_band_name = None, master_final_band_name = None, \
          master_initial_spin = None, master_final_spin = None, master_multipole_string = None):

        The number of parameters is calculated from the number of unique "par[0]", "par[1]",...
        entries in the rule_string.  

        If the matrix element is not defined as a master or a dependent, then
        it is set as fixed (self.is_fixed = True) to start.

        """

        # Store the values given at initialization.
        self.current_value = current_value
        self.rule_string = rule_string 
        self.is_master = is_master
        self.upper_limit = upper_limit
        self.lower_limit = lower_limit
        self.master_initial_band_name = master_initial_band_name 
        self.master_final_band_name = master_final_band_name
        self.master_initial_spin = master_initial_spin 
        self.master_final_spin = master_final_spin 
        if not master_multipole_string == None:
            self.master_multipole_string = master_multipole_string.upper()
            self.is_dependent = True
            self.is_fixed = False
        else:
            self.master_multipole_string = None
            self.is_dependent = False
            self.is_fixed = True

        # Zero the upper/lower diagonal and correlated errors.  (Set to None to avoid confusion with zero.)
        self.lower_diagonal_error = None
        self.upper_diagonal_error = None
        self.lower_correlated_error = None
        self.upper_correlated_error = None

    def zero_diagonal_errors(self):
        self.lower_diagonal_error = None
        self.upper_diagonal_error = None

    def zero_correlated_errors(self):
        self.lower_correlated_error = None
        self.upper_correlated_error = None

    def set_diagonal_errors(self,lower_error,upper_error):
        """The "upper" and "lower" error bars are defined such that they lie

        here on the number line, regardless of whether the "best value" is
        positive or negative.

                                           |<--a-->|
                             |<-----b----->|                |
          -x axis  <---------|=============X=======|--------0-----> +x axis
                                                            |
        and

                                           |<--a-->|
                       |     |<-----b----->|
          -x axis  <---0-----|=============X=======|--------------> +x axis
                       |

        both represent the number X with error bars, written as "X +a,-b" or "X (+a, -b)".

        """

        self.lower_diagonal_error = lower_error
        self.upper_diagonal_error = upper_error

    def set_correlated_errors(self,lower_error,upper_error):
        """The "upper" and "lower" error bars are defined such that they lie

        here on the number line, regardless of whether the "best value" is
        positive or negative.

                                           |<--a-->|
                             |<-----b----->|                |
          -x axis  <---------|=============X=======|--------0-----> +x axis
                                                            |
        and

                                           |<--a-->|
                       |     |<-----b----->|
          -x axis  <---0-----|=============X=======|--------------> +x axis
                       |

        both represent the number X with error bars, written as "X +a,-b" or "X (+a, -b)".

        """

        self.lower_correlated_error = lower_error
        self.upper_correlated_error = upper_error

    def get_diagonal_errors(self):
        """Returns a list of [lower,upper] diagonal errors.

        If they are not set, then return [None,None]

        """
        return [self.lower_diagonal_error, self.upper_diagonal_error]

    def get_correlated_errors(self):
        """Returns a list of [lower,upper] correlated errors.

        If they are not set, then return [None,None]

        """
        return [self.lower_correlated_error, self.upper_correlated_error]

    def hit_upper_limit(self):
        """Returns true if this matrix element appears to have hit the upper limit.

        Returns False by default, if this is not a master matrix element.

        """

        if not self.get_is_master():
            return False

        if self.current_value >= self.upper_limit:
            return True
        else:
            return False

    def hit_lower_limit(self):
        """Returns true if this matrix element appears to have hit the lower limit.

        Returns False by default, if this is not a master matrix element.

        """

        if not self.get_is_master():
            return False

        if self.current_value <= self.lower_limit:
            return True
        else:
            return False


    def calculate_number_of_user_parameters(self):
        number_of_parameters = 0
        while True:
            search_string = "par[" + str(number_of_parameters) + "]"
            # See if this search string is in the rule string.
            if search_string in self.rule_string:
                number_of_parameters += 1
            else:
                # This search string is not found.  Quit counting.
                break

        return number_of_parameters

    def get_current_value(self):
        return self.current_value

    def set_current_value(self, new_value):
        try:
            new_value = float(new_value)
            self.current_value = new_value
            return 0
        except:
            print "def set_current_value needs a float or int value.  Please report this bug."
            return "Error in class matrix_element, method set_current_value."

    def get_rule_string(self):
        return self.rule_string

    def set_rule_string(self,new_rule_string):
        if not "str" in type(new_rule_string):
            print "def set_rule_string requires a string.  Please report this bug."
            return "Error in class matrix_element, method set_rule_string."
        else:
            self.rule_string = new_rule_string
            return 0

    def get_is_master(self):
        return self.is_master

    def set_is_master(self,new_master_status):
        if new_master_status in [True,False]:
            self.is_master = new_master_status
            self.is_fixed = False
            self.is_dependent = False
            return 0
        else:
            print "def set_is_master needs a Boolean value.  Please report this bug."
            return "Error in class matrix_element, method set_is_master."

    def set_is_fixed(self):
        """Sets this as a fixed matrix element.

        """

        self.is_fixed = True
        self.is_dependent = False
        self.is_master = False

    def set_is_dependent(self):
        """Sets this as a dependent matrix element.

        The master information is set separately.

        """

        self.is_dependent = True
        self.is_fixed = False
        self.is_master = False

    def get_upper_limit(self):
        return self.upper_limit

    def set_upper_limit(self, new_upper_limit):
        try:
            float(new_upper_limit)
            self.upper_limit = new_upper_limit
            self.is_fixed = False
            self.is_dependent = False
            self.is_master = True
            return 0
        except:
            print "def set_upper_limit requires a float.  Please report this bug."
            return "Error in class matrix_element, method set_upper_limit."

    def get_lower_limit(self):
        return self.lower_limit

    def set_lower_limit(self, new_lower_limit):
        try:
            float(new_lower_limit)
            self.lower_limit = new_lower_limit
            self.is_fixed = False
            self.is_dependent = False
            self.is_master = True
            return 0
        except:
            print "def set_lower_limit requires a float.  Please report this bug."
            return "Error in class matrix_element, method set_lower_limit."

    def get_is_fixed(self):
        """Returns True if this is a fixed matrix element.

        """

        return self.is_fixed

    def get_is_dependent(self):
        """Returns True if this is a dependent matrix element.

        """

        return self.is_dependent

    def get_master_matrix_element_key(self):
        """Returns the matrix key for the master of this dependent.

        If this is not a dependent, then None is returned.

        """

        if not self.get_is_dependent():
            return None

        # Get the master multipole number, and construct the master's matrix key.
        master_multipole_number = self.get_master_multipole_number()
        master_matrix_key = (master_multipole_number, self.master_initial_band_name, self.master_initial_spin,\
          self.master_final_band_name, self.master_final_spin)
        return master_matrix_key


    def get_master_initial_band_name(self):
        """Returns the master initial band name.

        If this is not a dependent matrix element, then None is returned.

        """

        return self.master_initial_band_name

    def set_master_initial_band_name(self, new_name):
        """Sets the initial band name of the master to which this matrix element is coupled.

        """

        if not "str" in str(type(new_name)):
            print "def set_master_initial_band_name requires a string.  Please report this bug."
            return "Error in class matrix_element, method set_master_initial_band_name."
        else:
            self.master_initial_band_name = new_name
            return 0

    def get_master_final_band_name(self):
        return self.master_final_band_name

    def set_master_final_band_name(self, new_name):
        """Sets the final band name of the master to which this matrix element is coupled.

        """
        if not "str" in str(type(new_name)):
            print "def set_master_final_band_name requires a string.  Please report this bug."
            return "Error in class matrix_element, method set_master_final_band_name."
        else:
            self.master_final_band_name = new_name
            return 0

    def get_master_initial_spin(self):
        return self.master_initial_spin

    def set_master_initial_spin(self, new_spin):
        try:
            float(new_spin)
            self.master_initial_spin = new_spin
            return 0
        except:
            print "def set_master_initial_spin requires a float.  Please report this bug."
            return "Error in class matrix_element, method set_master_initial_spin."

    def get_master_final_spin(self):
        return self.master_final_spin

    def set_master_final_spin(self, new_spin):
        try:
            float(new_spin)
            self.master_final_spin = new_spin
            return 0
        except:
            print "def set_master_final_spin requires a float.  Please report this bug."
            return "Error in class matrix_element, method set_master_final_spin."

    def get_master_multipole_string(self):
        return self.master_multipole_string

    def set_master_multipole_string(self, new_multipole_string):
        # change to upper case.
        if not new_multipole_string in MULTIPOLE.keys():
            print "def set_master_multipole_string requires a string in ",MULTIPOLE.keys(),".  Please report this bug."
            return "Error in class matrix_element, method set_master_multipole_string."
        else:
            new_multipole_string = new_multipole_string.upper()
            self.master_multipole_string = new_multipole_string
            return 0

    def get_master_multipole_number(self):
        if self.master_multipole_string in MULTIPOLE.keys():
            return MULTIPOLE[self.master_multipole_string]
        else:
            return None

    def get_is_good(self):
        """Returns True if the matrix element is defined properly; False otherwise.

        """

        if (self.is_master and self.is_dependent) or (self.is_master and self.is_fixed) or\
           (self.is_dependent and self.is_fixed):
            return False
        else:
            return True


class level:
    """A new class for nuclear levels.  

    Each object of this class will hold a small amount of information, such as

    lifetime   - in ps, like in Gosia
    level_can_be_excited - (Boolean, True iff. the level can be populated from the ground state)
    spin       - This will be duplicate information, since the level objects
                 should be keyed by band name and spin, or may not be used.
    parity     - +1 or -1 (integer)
    is_valid   - True iff. the level was created properly.  This is needed
                 because the init method cannot return a value.
    K          - the level's K quantum number.  This will be set to None to start.
    The deorientation G2--G6 (if user calculated them):
    G2
    G4
    G6

    """

    def __init__(self, level_can_be_excited = False, parity = None, spin = None, energy = None):
        """Creates an object of the class level.

        For now, the spin and parity are the only required variables in the
        call to create the object.

        """

        # Mark this level invalid until the initialization is completed successfully.
        self.valid = False

        # Try to understand the parity.
        try:
            self.parity = int(parity)
        except:
            return  # Leaving is_valid set to False.

        # Check that the parity is an integer equal to 1 or -1.
        if not self.parity in [-1,1]:
            return  # Leaving is_valid set to False.

        # Try to understand the spin by converting it to a float rounded to the
        # nearest tenth.
        try:
            self.spin = round(float(spin),1)        
        except:
            return  # Leaving is_valid set to False.

        # Try to understand and save the energy.  This should always be in keV.
        try:
            self.energy = float(energy)
        except:
            return # Leaving is_valid set to False.


        # Save the status whether this level can be excited by the current
        # matrix.
        if level_can_be_excited:
            self.level_can_be_excited = True
        else:
            self.level_can_be_excited = False

        #================================================================================ 
        # If processing reaches here, the level is valid.  Set the valid flag.
        self.valid = True

        # Set the lifetime to None to start.  This is to be the calculated lifetime.
        self.calculated_lifetime = None

        # Set the K value to None until the user or the GUI changes it.
        self.K = None

        # The deorientation G2--G6:
        self.G2 = None
        self.G4 = None
        self.G6 = None

    def zero_deorientation_Gs(self):
        self.G2 = None
        self.G4 = None
        self.G6 = None

    def set_deorientation_Gs(self,G2,G4,G6):
        self.G2 = G2
        self.G4 = G4
        self.G6 = G6

    def get_deorientation_Gs(self):
        return [self.G2,self.G4,self.G6]

    def is_valid(self):
        """Returns True only if the level was defined correctly.

        """

        return self.valid

    def get_K(self):
        """Returns the internally stored K value.

        """

        return self.K

    def set_K(self,new_K_value):
        """Silently sets K.  

        K values greater than the spin are not allowed. 

        """

        if new_K_value <= self.spin:
            try:
                K = round(float(new_K_value),1)  # Rounding to the nearest half integer (tenth, really)
            except:
                print  "level.set_K(): requested K value is not a number."
                return "level.set_K(): requested K value is not a number."

            self.K = K

        return 0

    def get_spin(self):
        """Returns the internally stored spin.

        These levels should usually be keyed in the nucleus object by spin and
        band name, so this could, in principle, return a different value of the
        spin.

        """

        return self.spin

    def get_parity(self):
        """Returns the parity stored internally.

        If the level objects are keyed by parity, this could, in principle,
        return a different value of the spin.

        """

        return self.parity

    def get_energy(self):
        """Returns the level energy.  This should always be in keV.

        """

        return self.energy

    def set_calculated_lifetime(self,lifetime):
        """Sets the level lifetime.  This should always be in ps.

        """

        self.calculated_lifetime = lifetime

        return 0

    def zero_calculated_lifetime(self):
        """Sets the level's lifetime to None (unknown).

        """

        self.calculated_lifetime = None

        return 0

    def get_calculated_lifetime(self):
        """Returns the level lifetime.  This should always be in ps.

        If the lifetime is not known, then it will be returned as None.

        """

        return self.calculated_lifetime

    def can_be_excited(self):
        """Returns True if the GUI thinks this level can be excited by the current matrix.

        """

        return self.level_can_be_excited

class nucleus:
    """The central nuclear data and methods for defining matrix elements.

    The level scheme, matrix, fit parameters for gosia are defined here.

    This will not include experiment definitions, numerical method parameters,
    etc.

    Coulomb excitation data are stored in the detector objects, but branching
    ratio data are universal for this nucleus, so they are stored here.

    Get and set methods are still under construction.

    """

    def __init__(self,atomicnumber=None,massnumber=None,nucleusname=""):

        # Adding a place for notes here, since it is more difficult to make a
        # new class to add to the saved session format.
        self.notes = notes()

        self.A = massnumber
        self.Z = atomicnumber  # This will be overwritten by the Z from the AGS file
        self.levels = {}       # A dictionary pointing to objects of the class "level".  
                               # The keys of self.levels will take the form
                               # ("gsb",0.0), ("gam",3.0), ("gamod",3.0)...,
                               # where ("gamod",3.0) is in this case a
                               # pseudonym of the band "gam."

        self.band_settings_list = [] # Bands will be displayed and passed to Gosia in the order specified here.
                                     # These are the "primary" band names, no aliases included.
                                     # This may also contain a short dictionary of other settings, such as 
                                     # "active"/"inactive" status.
                                     # [["gsb",{other settings}],["gam",{other settings}],...]
                                     # Only keep in this dictionary the band
                                     # names to be displayed.  If two bands are
                                     # merged, the original band names will be
                                     # kept as aliases in the self.levels keys.
                                     # Whenever the aliases need to be checked,
                                     # this is done by comparing names in the
                                     # level keys with the band names in this
                                     # list.

        # Matrix element data
        self.matrix_data = {} # The matrix element objects are now stored all
                              # in one dictionary keyed by a tuple of
                              # (multipole_code_number, initial_band_name,
                              # initial_spin, final_band_name, final_spin) The
                              # band names must be PRIMARY band names, not the
                              # names of level aliases.  
                              # set_matrix_keys_to_primary_levels() is a
                              # method to change matrix keys from aliases to
                              # primary names, in case bands are merged.
    

        # "major couplings" (band to band or Q0 or gk-gr for a whole band)
        # This list will be used to redraw the major couplings to the level
        # scheme window
        self.major_couplings = []


        # Make a window for the level scheme
        self.makewindow()  # All objects must exist to be filled with pickled data.

    def for_upgrade(self,restored_version):
        """Sets new variables as appropriate for an upgrade from

        version restored_version to present VERSION.

        """

        total_errors = 0
        return_text = []
        
        if restored_version in []:
            # Add to the list above to select for upgrades by session file's version number.
            pass

            # Add to the commands here to upgrade the object of this class.

            # Examples of syntactically correct error codes are below.
            #total_errors += 1
            #return_text.extend(textwrap.wrap("ipsum lorem blah blah blah",TEXTVIEW_COLUMNS))

        elif restored_version.startswith("pre-release"):
            # Upgrades for any pre-release post-beta version.  These are not supported, but we used them internally.
            try:
                # Need to create a notes (logs) object.
                self.notes = notes()
            except:
                total_errors += 1
                return_text.extend(textwrap.wrap("Could not create a notes object in class nucleus.",TEXTVIEW_COLUMNS) )
            
        elif restored_version <= "1.2.0":
            # Upgrades for any version 1.1.5 or older.
            try:
                # Need to create a notes (logs) object.
                self.notes = notes()
            except:
                total_errors += 1
                return_text.extend(textwrap.wrap("Could not create a notes object in class nucleus.",TEXTVIEW_COLUMNS) )
            
            # Examples of syntactically correct error codes are below.
            #total_errors += 1
            #return_text.extend(textwrap.wrap("ipsum lorem blah blah blah",TEXTVIEW_COLUMNS))
        else:
            pass  # no upgrade necessary
                
        if total_errors  == 0:
            success_string = "Nuclear data successfully upgraded to version " + str(VERSION) + "."
            return_text.extend(textwrap.wrap(success_string,TEXTVIEW_COLUMNS))


        return total_errors,return_text


    def activate(self):
        """Makes the figure window active until closed.

        """

        print "Figure window is active."
        print "If the GUI buttons freeze, close the level scheme window,"
        print "and a new one will be created."

        pylab.show()                   
        self.draw_level_scheme()

        text = block_print_with_line_breaks("\"Redraw LS window\" is used to clean up the diagram.\nUse \"Recreate LS window\" only if the level scheme window does not display after a level scheme is in memory.",line_length=50,silent=True)

        create_dialog_popup({"title":"Graphics","force_popup":True,"text_lines":text })


    def wipe(self,Z,A,name):
        """Deletes all information from the nucleus.

        Takes only Z,A,name to re-initialize.

        """
        self.__init__(Z,A,name)

        return 0


    def check_for_problems(self,quiet = True):
        """Returns text output and advice if there are problems with the setup.

        If the setup seems ok, 0 is returned.  If there are problems that will
        crash Gosia, returns -1.

        if quiet is True, then only problems are reported.  If quiet is False,
        then a report is printed even if there are no problems.

        """

        warning_lines = []
        warning_issued = False

        # A list of warnings with the limits of Gosia included.
        too_many_levels = "There are too many levels in memory.  The limit in Gosia is " + str(MAXIMUMLEVELS) + " levels.  You will have to delete one or more bands before running Gosia.  You can use the button \"Delete bands\" to remove some of them.\nIf you have just read a level scheme, you can also use the \"Undo\" button.\n"
        too_many_levels_text = block_print_with_line_breaks(too_many_levels,line_length=50,silent=True)

        # Check to see if there are too many levels.
        number_of_levels = self.number_of_levels()

        if number_of_levels > MAXIMUMLEVELS:
            warning_lines.extend(too_many_levels_text)
            warning_issued = True

                
        if not warning_issued:
            warning_lines.append("No problems found in the nucleus definitions.")

        if warning_issued:
            setup_problems_popup = dialog_popup({"text_lines":warning_lines,"title":"Experimental setup issues that need attention"})
        elif not quiet:
            setup_problems_popup = dialog_popup({"text_lines":warning_lines,"title":"Experimental setup issues that need attention"})

        if warning_issued:
            return -1
        else:
            return 0


    def is_ready(self):
        """Asks user for information needed to complete setup for running gosia.

        Returns True if setup is properly completed in this call, otherwise False.

        """

        # Rewritten July 2011.

        # final_status is True if the setup is complete.
        final_status = True

        if self.number_of_levels() > MAXIMUMLEVELS:
            print "Too many levels are defined.  Only 99 are allowed."
            return False

        if self.number_of_levels() == 0:
            print "No levels in memory."
            return False

        if self.matrix_data == {}:
            # Then no matrix elements are in memory.  This cannot be fixed in
            # this method, so set the final_status to False.
            print "There are no matrix elements in memory.  Define matrix elements using the GUI before attempting to run Gosia."
            return False

        try:
            self.get_normalization_transition_keys()
        except:
            # The normalization transition has not been properly defined.  Call
            # the method to set up the normalization states.
            print "The normalization transition is not properly defined."
            self.set_normalization_transition()
            try:
                self.get_normalization_transition_keys()
            except:
                print "Setting the normalization transition was unsuccessful.  This must be done before running Gosia."
                return False

        return True


    def export_level_scheme(self):
        """Writes the level scheme to a Rachel format text file.

        """

        text_columns = 20
        energy_columns = 10
        spin_columns = 6
        level_scheme_file_name = prompt_for_file_name(prompt_string = "Enter file name to export level scheme: ")
        if level_scheme_file_name == "":
            print "Cancelled."
            return 0
        
        # Get the level keys in Gosia order.
        sorted_level_keys = self.get_level_keys_in_gosia_order()
        # These are unique and don't contain pseudonyms.  We append pseudonyms to the file below.

        try:
            # Generate a list of text lines in the Rachel level scheme text format.
            lines_to_write = []
            lines_to_write.append(str(self.Z) + "  " + str(self.A))
            for level_key in sorted_level_keys:
                level_object = self.levels[level_key]
                band_name, spin = level_key
                energy = self.get_level_information(level_key,"energy")
                parity = self.get_level_information(level_key,"parity")
                if parity == 1:
                    parity_symbol = "+"
                else:
                    parity_symbol = "-"
                new_line = band_name.ljust(text_columns) + " " + str(spin).ljust(spin_columns) + " " + parity_symbol + " " + str(energy).ljust(energy_columns)

                # Check for pseudonyms.  These are appended when the gui
                # creates a txt level scheme file so that data in memory
                # referencing pseudonyms will be understood if the user reads
                # this level scheme file and then uses existing data files that
                # reference pseudonyms.

                #print "level_key", level_key
                this_level_pseudonym_keys = self.get_all_level_pseudonym_keys(level_key)
                for one_pseudonym in this_level_pseudonym_keys:
                    pseudonym_string = str(one_pseudonym[0])
                    new_line = new_line + " " + pseudonym_string
                    #print "pseud.", pseudonym_string

                lines_to_write.append(new_line)
        except:
            print "Error in generating txt level data."
            return -1
        # Write the lines to the file requested
        write_lines_to_file(level_scheme_file_name,lines_to_write)
        print "Level scheme exported.\nDone."

        return 0

                
    def export_matrix(self):
        """Writes the matrix to a Rachel format matrix file.

        band_name spin band_name spin multipole_text matrix_element "fixed"

        if this is a fixed matrix element, or 

        band_name spin band_name spin multipole_text matrix_element "coupled" master_initial_band_name master_initial_spin master_final_band_name master_final_spin master_multipole_text

        if it is a dependent matrix element, or

        band_name spin band_name spin multipole_text matrix_element "master" lower_limit upper_limit

        if it is a master matrix element.

        This text format for band names etc. is more robust if the level
        numbering changes, so that a matrix file can be read and applied to a
        modified level scheme, as long as the band names have not changed.

        """

        # The column width for string fields
        column_width = 15
        # The column width for spin fields
        spin_column_width = 6
        # Get the file name to write the matrix data to.
        matrix_file_name = prompt_for_file_name(prompt_string = "File name to write to (will be overwritten): ")
        if matrix_file_name == "":
            print "Cancelled."
            return 0
        
        # A dictionary to sort by multipole code, then by initial and final
        # level numbers (level numbers as they would be sent to Gosia).
        matrix_sorting_dict = {}

        # A list of lines to be written to the file.
        lines_to_write = []
        for matrix_key in self.matrix_data.keys():
            matrix_element_object = self.matrix_data[matrix_key]
            multipole_code, initial_band_name, initial_spin, final_band_name, final_spin = matrix_key
            matrix_element_value = matrix_element_object.get_current_value()
            # Convert these codes to the text format for the file.
            multipole_text         = REVERSE_MULTIPOLE[multipole_code]
            # Get the gosia level numbers for sorting.
            initial_gosia_level_number = self.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
            final_gosia_level_number   = self.lookup_gosia_level_by_band_spin(final_band_name,final_spin)
            # See if this matrix element is coupled to a master, or if it is a master itself.
            if matrix_element_object.get_is_master():
                is_master = True
                is_coupled = False   # Masters cannot be coupled in Gosia.
                # Get the lower and upper limits on this master.
                lower_limit = matrix_element_object.get_lower_limit()
                upper_limit = matrix_element_object.get_upper_limit()
            else:
                is_master = False
                # See if this is a dependent.
                if matrix_element_object.get_is_dependent():
                    is_coupled = True
                    # Get the master information
                    master_initial_band_name = matrix_element_object.get_master_initial_band_name()
                    master_final_band_name   = matrix_element_object.get_master_final_band_name()
                    master_initial_spin      = matrix_element_object.get_master_initial_spin()
                    master_final_spin        = matrix_element_object.get_master_final_spin()
                    master_multipole_text    = matrix_element_object.get_master_multipole_string()
                else:
                    is_coupled = False

            # Now construct the text line appropriately for a fixed, master or dependent matrix element.
            if is_master:
                # This is a master matrix element.
                line_to_write = initial_band_name.ljust(column_width) + " " + str(initial_spin).ljust(spin_column_width) + \
                  " " + final_band_name.ljust(column_width) + " " + str(final_spin).ljust(spin_column_width) + " " + \
                  multipole_text + " " + str(matrix_element_value) +\
                  "    " + "master" + "    " + str(lower_limit) + "    " + str(upper_limit) 
            elif is_coupled:
                # This is a dependent matrix element.
                line_to_write = initial_band_name.ljust(column_width) + " " + str(initial_spin).ljust(spin_column_width) + \
                  " " + final_band_name.ljust(column_width) + " " + str(final_spin).ljust(spin_column_width) + " " +\
                  multipole_text + " " + str(matrix_element_value) + "    " + "coupled" + "    " + master_multipole_text + \
                  "    " + master_initial_band_name.ljust(column_width) + \
                  str(master_initial_spin).ljust(spin_column_width) + " " + master_final_band_name.ljust(column_width) +\
                  " " + str(master_final_spin).ljust(spin_column_width) 
            else:
                # Must be fixed, if it is not a master or a dependent.
                line_to_write = initial_band_name.ljust(column_width) + " " + str(initial_spin).ljust(spin_column_width) + \
                  " " + final_band_name.ljust(column_width) + " " + str(final_spin).ljust(spin_column_width) + " " + \
                  multipole_text + " " + str(matrix_element_value) +\
                  "    " + "fixed" 

            # Add this line to the output sorting dict.
            output_sorting_key = (multipole_code,initial_gosia_level_number,final_gosia_level_number)
            matrix_sorting_dict[output_sorting_key] = line_to_write

        # The band-name pseudonym dict is no longer written to the file.

        # Sort the matrix for a more user-readable output.
        sorting_keys = matrix_sorting_dict.keys()
        sorting_keys.sort()
        for one_key in sorting_keys:
            line_to_write = matrix_sorting_dict[one_key]
            lines_to_write.append(line_to_write)

        # Write the lines to the file.
        write_lines_to_file(matrix_file_name,lines_to_write)
                      
        print "Done."
        return

    def import_matrix(self):
        """Imports a Rachel-format matrix file, optionally including a band pseudonum dictionary.

        This matrix will be added to the present matrix, overwriting duplicate
        matrix elements.

        """


        add_or_replace = raw_input("Do you want to [a]dd to the matrix, or [r]eplace the matrix (erasing the existing matrix)? ").lower()
        try:
            if add_or_replace[0] == "a":
                erase = False
            elif add_or_replace[0] == "r":
                erase = True
            else:
                print "Invalid choice.  Quitting."
                return -1
        except:
            print "Invalid choice.  Quitting."
            return -1

        if erase:
            self.matrix_data = {}
            print "Deleted the matrix in memory!"

        # Get the file name.
        matrix_file_name = prompt_for_file_name(prompt_string = "File name to read: ")
        if matrix_file_name == "":
            print "Cancelled."
            return 0

        # Read the full file in lines.
        try:
            with open(matrix_file_name,"r") as matrix_file:
                matrix_file_lines = matrix_file.readlines()
        except:
            print "Bad matrix file, or file not found.  Cancelled."
            return -1

        # A temporary list for coupled matrix elements.  These must be added
        # last, so that we can test for the existence of the masters in memory.
        # (The master could be a "fixed" matrix element.)
        coupled_matrix_elements = []

        # First, find the pseudonym_dict and process it.
        # This is a temporary pseudonym dict for hte matrix file.
        pseudonym_dict = {}  # empty, in case none are found in the file.
        for this_line in matrix_file_lines:
            if len(this_line.split()) > 2:
                if this_line.split()[0] == "pseudonym_dict":
                    pseudonym_dict = eval(this_line.split("=")[-1])
                    # Reverse the dictionary and add it to the original, so
                    # that a pseudonym lookup can work in either direction,
                    # name-->pseudonym, or pseudonym-->name.
                    for one_name in pseudonym_dict.keys():
                        pseudonym_dict[pseudonym_dict[one_name]] = one_name

        # If there is a pseudonym dictionary, then this matrix file is from a
        # pre-release version.  Issue a notice and add level pseudonyms for all
        # members of the bands that need pseudonyms.  This will create more
        # than necessary, but it should not cause problems.
        if not pseudonym_dict == {}:
            # Add a pseudonym for every level in the bands that had pseudonyms in this matrix file.
            for level_key in self.levels.keys():
                band_name, spin = level_key
                if band_name in pseudonym_dict.keys():
                    band_pseudonym = pseudonym_dict[band_name]
                    self.add_level_pseudonym(old_band_name = band_name, spin = spin, new_band_name = band_pseudonym)


        # Parse the file lines, and add all matrix elements to the current
        # matrix.

        # First pass: add only masters and fixed matrix elements.  Then we can
        # make a second pass, adding dependents.  (The master must already
        # exist to add a dependent.

        print "\nFirst pass: adding fixed and master matrix elements.\n"
        for this_line in matrix_file_lines:
            # Reconstruct the matrix element, and add it to the matrix in
            # memory.
            # Process this line only if it has an entry and it's not the pseudonym_dict.
            if len(this_line.split()) > 6 and not this_line.split()[0] == "pseudonym_dict":
                # Construct a matrix entry from this line.
                this_line_fields = this_line.split()
                initial_band_name       = this_line_fields[0]
                initial_spin            = round(float(this_line_fields[1]),1)
                final_band_name         = this_line_fields[2]
                final_spin              = round(float(this_line_fields[3]),1)
                multipole_text          = this_line_fields[4]
                multipole_code        = MULTIPOLE[multipole_text]
                matrix_element_value    = float(this_line_fields[5])
                coupling_code           = this_line_fields[6]
                initial_level_key = (initial_band_name, initial_spin)
                final_level_key   = (final_band_name, final_spin)
                matrix_key = (multipole_code, initial_band_name, initial_spin, final_band_name, final_spin)
                # See if the initial state and final state are in memory.
                if initial_level_key in self.levels.keys() and final_level_key in self.levels.keys():
                    if coupling_code == "master":
                        # Only the lower and upper limits are needed for a master.
                        lower_limit = float(this_line_fields[7])
                        upper_limit = float(this_line_fields[8])
                        if lower_limit > upper_limit:
                            # Swap the limits if they were in the wrong order.
                            lower_limit, upper_limit = upper_limit, lower_limit
                        # Add this matrix element.
                        self.add_matrix_element(multipole_string = multipole_text, initial_band_name = initial_band_name,\
                          final_band_name = final_band_name,initial_spin = initial_spin, final_spin = final_spin,\
                          value = matrix_element_value)
                        self.matrix_data[matrix_key].set_is_master(True)
                        self.matrix_data[matrix_key].set_lower_limit(lower_limit)
                        self.matrix_data[matrix_key].set_upper_limit(upper_limit)
                        print "Added master matrix element ",initial_band_name," I = ",initial_spin,"-",multipole_text,"->",final_band_name," I = ",final_spin," = ",matrix_element_value," Limits: ",lower_limit,upper_limit
                    elif coupling_code == "fixed":
                        # The matrix element must be fixed.
                        # No other fields needed for a fixed matrix element.
                        self.add_matrix_element(multipole_string = multipole_text, initial_band_name = initial_band_name,\
                          final_band_name = final_band_name,initial_spin = initial_spin, final_spin = final_spin,\
                          value = matrix_element_value)
                        self.matrix_data[matrix_key].set_is_fixed()
                        print "Added fixed matrix element ",initial_band_name," I = ",initial_spin,"-",multipole_text,"->",final_band_name," I = ",final_spin," = ",matrix_element_value

                else:
                    print "Could not add matrix element from this line: \n",this_line.strip(),"\n because states are missing from the level scheme."

        # Second pass: add coupled matrix elements only.
        print "\nSecond pass: adding dependent matrix elements.\n"
        for this_line in matrix_file_lines:
            # Reconstruct the matrix element, and add it to the matrix in
            # memory.
            # Process this line only if it has an entry and it's not the pseudonym_dict.
            if len(this_line.split()) > 6 and not this_line.split()[0] == "pseudonym_dict":
                # Construct a matrix entry from this line.
                this_line_fields = this_line.split()
                initial_band_name       = this_line_fields[0]
                initial_spin            = round(float(this_line_fields[1]),1)
                final_band_name         = this_line_fields[2]
                final_spin              = round(float(this_line_fields[3]),1)
                multipole_text          = this_line_fields[4]
                multipole_code        = MULTIPOLE[multipole_text]
                matrix_element_value    = float(this_line_fields[5])
                coupling_code           = this_line_fields[6]
                initial_level_key = (initial_band_name, initial_spin)
                final_level_key   = (final_band_name, final_spin)
                matrix_key = (multipole_code, initial_band_name, initial_spin, final_band_name, final_spin)
                # See if the initial state and final state are in memory.
                if initial_level_key in self.levels.keys() and final_level_key in self.levels.keys():
                    if coupling_code == "coupled":
                        # Get the indices and multipole to couple to.
                        master_multipole_text    = this_line_fields[7]
                        master_multipole_code  = MULTIPOLE[master_multipole_text]
                        master_initial_band_name = this_line_fields[8]
                        master_final_band_name   = this_line_fields[10]
                        master_initial_spin      = round(float(this_line_fields[9]),1)
                        master_final_spin        = round(float(this_line_fields[11]),1)
                        # See if this master exists and is truly a master.
                        master_matrix_key = (master_multipole_code, master_initial_band_name, master_initial_spin, master_final_band_name, master_final_spin)
                        if master_matrix_key in self.matrix_data.keys():
                            master_exists = True
                        else:
                            master_exists = False
                        if master_exists:
                            if self.matrix_data[master_matrix_key].get_is_master():
                                is_master = True
                            else:
                                is_master = False
                        if master_exists and is_master:
                            self.add_matrix_element(multipole_string = multipole_text, initial_band_name = initial_band_name,\
                              final_band_name = final_band_name,initial_spin = initial_spin, final_spin = final_spin,\
                              value = matrix_element_value)
                            # Set this matrix element coupled to the specified master.
                            matrix_element_object = self.matrix_data[matrix_key]
                            matrix_element_object.set_is_dependent()
                            matrix_element_object.set_master_initial_band_name(master_initial_band_name)
                            matrix_element_object.set_master_initial_spin(master_initial_spin)
                            matrix_element_object.set_master_final_band_name(master_final_band_name)
                            matrix_element_object.set_master_final_spin(master_final_spin)
                            matrix_element_object.set_master_multipole_string(master_multipole_text)
                            print "Added coupled matrix element ",initial_band_name," I = ",initial_spin,"-",multipole_text,"->",final_band_name," I = ",final_spin," = ",matrix_element_value
                            print "  Coupled to ", master_initial_band_name, " I = ", master_initial_spin,"-",master_multipole_text,"->",master_final_band_name," I = ",master_final_spin
                        else:
                            # Add the coupled matrix element as a fixed one, because the master doesn't exist.
                            print "**The following matrix element was added as fixed, because the specified master does not exist."
                            print "  Added fixed matrix element ",initial_band_name," I = ",initial_spin,"-",multipole_text,"->",final_band_name," I = ",final_spin," = ",matrix_element_value

                else:
                    print "Could not add matrix element from this line: \n",this_line.strip(),"\n because states are missing from the level scheme."

        print "Changing matrix elements that reference pseudonyms to reference primary band names...",
        self.set_matrix_keys_to_primary_levels()
        print "Done."

        print "Putting matrix elements in the proper direction for Gosia...",
        self.put_matrix_elements_in_gosia_direction()
        print "Done."

        self.update_major_couplings()
        print "Finished reading matrix from ",matrix_file_name,"."

        # Issue a warning about pre-release format matrix files:
        if not pseudonym_dict == {}:
            block_print_with_line_breaks("\nThis matrix file is from a pre-release version and contains a beta-version pseudonym dictionary for band names.  The level scheme has been updated with pseudonyms for levels as necessary.  This should not cause any problems, but check that you get the same results with this version of the Rachel.  If there are problems, you will have to start from the beginning by reading your original level scheme file(s) and building the matrix by hand.",60)

        return 0

    def format_one_matrix_element(self,initial_band_name=None,initial_spin=None,final_band_name=None,final_spin=None,\
      multipole_text=None,value=None,initial_K=None,final_K=None,comment=None):
        """Formats one matrix entry with units for printing.

        This does not look up the matrix element; it prints the matrix element
        definition and value passed to it.

        If the K values are left as None, then the K labels are omitted.

        """

        units_string = UNITS_DICT[multipole_text]
        text = "<\"" + final_band_name + "\" I = " + str(final_spin)
        if not final_K == None:
            text = text + ", K = " + str(final_K)
        text = text + " || " + multipole_text + " || \"" + initial_band_name + "\" I = " + str(initial_spin) 
        if not initial_K == None:
            text = text + ", K = " + str(initial_K)
        text = text + "> "
        if not value == None:
            # If the value is positive, give an extra space to line up decimals.
            if value >= 0.0:
                text = text + "=  " + str(value) + " " +  units_string 
            else:
                text = text + "= " + str(value) + " " +  units_string 
        if not comment == None:
            text = text + " " + comment

        return text


    def pretty_print_matrix(self):
        # This needs more work
        print 
        print "\"CE\" is the correlated error from the last time it was calculated; "
        print "\"DE\" is the diagonal error."
        print "----------------------------------------------------------------------"
        sorted_keys = self.get_all_matrix_keys_in_gosia_order()
        for matrix_key in sorted_keys:
            matrix_object = self.matrix_data[matrix_key]
            # Get the variables that index the matrix element.
            multipole_code, initial_band_name, initial_spin, final_band_name, final_spin = matrix_key
            # Get the multipole_text string.
            multipole_text = REVERSE_MULTIPOLE[multipole_code]
            current_value = matrix_object.get_current_value()
            
            formatted_matrix_element = self.format_one_matrix_element(initial_band_name=initial_band_name,\
              initial_spin=initial_spin,final_band_name=final_band_name,final_spin=final_spin,\
              multipole_text=multipole_text,value=current_value)
            # If the correlated error is known, print it; same for the diagonal error.
            diagonal_errors   = str(matrix_object.get_diagonal_errors()).replace("[","(").replace("]",")")
            correlated_errors = str(matrix_object.get_correlated_errors()).replace("[","(").replace("]",")")
            formatted_matrix_element += " DE: " + diagonal_errors + " CE: " + correlated_errors
            print formatted_matrix_element 

        return 0
                
    def print_K_values(self, external_band_number):
        """Prints a list of K values for the requested band.

        """

        # Get the band name for this internal band number.
        all_band_names_list = self.get_all_band_names_in_order(include_inactive_bands = True)
        requested_band_name = all_band_names_list[external_band_number - 1]

        # Get all levels in order of increasing spin.
        all_levels_in_order = self.get_sorted_unique_levels()

        print "Current K values for band \"", requested_band_name, "\":"
        print "   I     K"
        print "--------------"
        # Step through the levels and print the K values for each level in this
        # band.
        for one_level_entry in all_levels_in_order:
            this_band_name = one_level_entry[0]
            if this_band_name == requested_band_name:
                this_spin      = one_level_entry[1]
                one_level_key  = (this_band_name, this_spin)
                this_K         = self.levels[one_level_key].get_K()
                print " ", str(this_spin).rjust(4), " ", this_K

        return 0

    def set_one_band_K_values(self,external_band_number):
        """Prints the K values in the band and prompts to change them.

        """

        print
        # Get the band name for this internal band number.
        all_band_names_list = self.get_all_band_names_in_order(include_inactive_bands = True)
        requested_band_name = all_band_names_list[external_band_number - 1]

        # Print the current K values for this band.
        self.print_K_values(external_band_number)

        # Get all levels in order of increasing spin.
        all_levels_in_order = self.get_sorted_unique_levels()

        change = yes_no_prompt("Change one or more K values [Y/n]? ",True)
        if change:
            set_all_at_once = yes_no_prompt("Set all K values equal [Y/n]: ",True)
            if set_all_at_once:
                new_K_value = prompt_number("New K value for all levels in this band: ","r")  # Returns a float rounded to nearest tenth (half-integer).
                if new_K_value == "quit":
                    print "Quitting."
                    return 0

                # Step through all levels and change K for each.
                for one_level_entry in all_levels_in_order:
                    this_band_name = one_level_entry[0]
                    if this_band_name == requested_band_name:
                        this_spin      = one_level_entry[1]
                        one_level_key  = (this_band_name, this_spin)
                        this_K         = self.levels[one_level_key]
                        # Change the K value of this state to the value entered, or leave it if the default was returned.
                        self.levels[one_level_key].set_K(new_K_value)

            else:
                # Prompt repeatedly for the new K value for each spin:
                print "Press enter for the current K value for each level."
                # Set the K value if the spin allows it.
                for one_level_entry in all_levels_in_order:
                    this_band_name = one_level_entry[0]
                    if this_band_name == requested_band_name:
                        this_spin      = one_level_entry[1]
                        one_level_key  = (this_band_name, this_spin)
                        this_K         = self.levels[one_level_key].get_K()
                        # Change the K value of this state to the value entered, or leave it if the default was returned.
                        this_prompt = "Enter K value for state " + str(this_band_name) + " I = " + str(this_spin) + ", K = " + str(this_K) + " [" + str(this_K) + "]: "
                        new_K = prompt_default(prompt_string = this_prompt,default_value = this_K, type_to_return = "r") # Return a rounded float to nearest tenth.
                        # Change the K value of this state to the value entered, or leave it if the default was returned.
                        if not new_K == this_K:
                            self.levels[one_level_key].set_K(new_K)

        self.print_K_values(external_band_number)
        print "Done."
        print

        return 0

    def parse_diagonal_errors(self,parametric):
        """Prints a pretty report from the gosia.out file after a diagonal error calculation.

        Since it is not easily determined from the gosia.out file whether a
        full or parametric error calculation was made, and the full final set
        of matrix elements is not written by gosia after a diagonal error
        calculation, the term "master" below loses meaning for a full error
        calculation.  Furthermore, the method must be told whether a parametric
        error calculation was done, so that it knows whether or not to search
        for dependent matrix elements to update.  If, and only if, a parametric
        error calculation was done, it updates the dependents manually.

        File 17 is not used in this case, because it does not contain the best
        matrix elements after a *diagonal* error calculation; the gosia main
        output file is used instead.

        """

        # Get the gosia output file name from the gosia shell.
        gosia_output_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[22]["extension"]

        # Read the gosia output file from disk.  
        with open(gosia_output_file_name,'r') as gosia_output_file:
            gosia_output_lines = gosia_output_file.readlines()

        # Check for gosia errors
        gosia_error_check_code = check_for_gosia_error(gosia_output_lines)

        if gosia_error_check_code == -1:
            print "Could not parse errors."
            print "Quitting."
            return -1

        #the_gosia_shell.check_for_reset_warnings()  # NOT WRITTEN YET.

        # Allow the user to read these regardless of whether Gosia claimed it found a better point.
        block_print_with_line_breaks("(You can examine the Gosia output file (usually \"gosia.out\") before answering the following prompt.)")
        read_best_set = yes_no_prompt("Would you like to save the new best-fit matrix elements and their errors to the GUI memory [Y/n]: ",True)

        # If the user chose to read the new matrix elements, zero the diagonal errors first.
        if read_best_set:
            self.zero_all_diagonal_errors()

        print "New best values and errors:"
        print "--------------------------------------------------------------------------------"

        # Get the matrix keys in Gosia order to match the new best values from Gosia to the appropriate keys.
        matrix_keys_in_order = self.get_all_matrix_keys_in_gosia_order()

        data_line = findinlist(gosia_output_lines,["ESTIMATED","ERRORS"]) + 5
        while True:
            this_line = gosia_output_lines[data_line]
            fields = this_line.split()
            if len(fields) < 12:
                break
            internal_matrix_element_number = int(fields[0]) - 1  # Start numbering from 0 to match to the ordered matrix keys.
            matrix_key = matrix_keys_in_order[internal_matrix_element_number]
            # Get the matrix element object.
            matrix_element_object = self.matrix_data[matrix_key]
            initial_matrix_element_value   = matrix_element_object.get_current_value()
            better_matrix_element_value    = float(fields[3])                                    # (master)
            fractional_change              = (better_matrix_element_value - initial_matrix_element_value) / initial_matrix_element_value # (master)
            # The errors can be stored in the matrix element objects and reported.
            low_absolute_error             = float(fields[5])   
            high_absolute_error            = float(fields[7].split(")")[0])
            low_percent_error              = float(fields[8])
            high_percent_error             = float(fields[10])

            # Now get the value and identity of the matrix element stored in the GUI.
            multipole_code       = matrix_key[0]
            initial_band_name    = matrix_key[1]
            initial_spin         = matrix_key[2]
            final_band_name      = matrix_key[3]
            final_spin           = matrix_key[4]
            multipole_text = REVERSE_MULTIPOLE[multipole_code]

            # Replace the former value with the new value for the master.
            if read_best_set:
                # Replace the master's value with the better value.
                self.matrix_data[matrix_key].set_current_value(better_matrix_element_value)

                # Update the matrix element's diagonal error.  This is only
                # done for the one reported, not its dependents, since they
                # were fitted together for parametric errors, and different
                # errors will be obtained for all fit parameters released.
                self.matrix_data[matrix_key].set_diagonal_errors(low_absolute_error, high_absolute_error)

                # If a parametric diagonal error calculation was done, then the
                # dependent matrix elements must be updated to follow the
                # changes in the masters.
                if parametric:
                    # For a parametric error calculation, only master matrix
                    # element errors should have been reported.  Check to make
                    # sure that this matrix element is indeed a master.  If it
                    # is not, then return an error and quit processing.

                    is_master = matrix_element_object.get_is_master()
                    if not is_master:
                        # Something went wrong.
                        print "Error parsing parametric diagonal error calculation.  Please report this bug."
                        print "You should undo this operation."
                        return -1

                    # Search all matrix elements and update dependents with the
                    # same fractional change.  The best set are not stored by
                    # gosia in the case of diagonal error calculations, so this
                    # has to be done manually.
                    all_dependent_keys = self.get_all_dependent_matrix_keys(matrix_key)
                    for one_dependent_key in all_dependent_keys:
                        # Get the dependent object
                        dependent_object = self.matrix_data[one_dependent_key]
                        # Get the current value of this dependent.
                        initial_dependent_matrix_element_value = dependent_object.get_current_value()
                        # Update this matrix element with the new, possibly better, value.
                        new_dependent_matrix_element_value     = math.copysign(abs(initial_dependent_matrix_element_value) *\
                          (1. + fractional_change),initial_dependent_matrix_element_value)  # Make the fractional change on the absolute value, 
                                                                                            # then put the sign back on.
                        dependent_object.set_current_value(new_dependent_matrix_element_value)

                        if initial_dependent_matrix_element_value > 0.0:
                            dependent_low_abs_error  =  (low_percent_error/100.) * initial_dependent_matrix_element_value 
                            dependent_high_abs_error =  (high_percent_error/100.) * initial_dependent_matrix_element_value 
                        else:
                            dependent_low_abs_error  = (high_percent_error/100.)  * initial_dependent_matrix_element_value 
                            dependent_high_abs_error = (low_percent_error/100.) * initial_dependent_matrix_element_value 

                        dependent_object.set_diagonal_errors(dependent_low_abs_error,dependent_high_abs_error)

            # Now print the results for this matrix element
            comment = "(" + str(low_absolute_error).strip() + ", " + str(high_absolute_error).strip() + ")" + "  (" + str(low_percent_error)\
              + "%, " + str(high_percent_error) + "%)"
            formatted_matrix_entry = self.format_one_matrix_element(initial_band_name=initial_band_name,\
                          initial_spin=initial_spin,final_band_name=final_band_name,final_spin=final_spin,\
                          multipole_text=multipole_text,value=better_matrix_element_value,comment=comment)
            print formatted_matrix_entry 
            data_line += 1
            
        print "--------------------------------------------------------------------------------"
        print ""


    def parse_correlated_errors(self,release=False):
        """Prints a pretty report from the gosia.out file after a correlated error calculation.

        This also reads the new best fit matrix elements if a new minimum was found.

        It saves correlated errors to each matrix element.

        """

        # Get the gosia output file name from the gosia shell.
        gosia_output_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[22]["extension"]

        # Read the gosia output file from disk.  
        with open(gosia_output_file_name,'r') as gosia_output_file:
            gosia_output_lines = gosia_output_file.readlines()

        # Check for gosia errors
        # For now, since the correlated error output can give accurate
        # values, but still report overflowed values of chi-squared, the
        # error check is not done for correlated errors.
#        gosia_error_check_code = check_for_gosia_error(gosia_output_lines)
#
#        if gosia_error_check_code == -1:
#            print "Could not parse errors."
#            print "Quitting."
#            return -1

        #the_gosia_shell.check_for_reset_warnings()  # NOT WRITTEN YET.

        # Search to see if a better minimum was found.  Search from the end to
        # the beginning to find the best chi-squared report, since "BETTER
        # POINT FOUND..." is repeated until the end of the calculation.
        gosia_output_lines.reverse()
        best_chi_squared_line = findinlist(gosia_output_lines,["BETTER", "POINT"])

        if not best_chi_squared_line == -1:
            best_chi_squared = float(gosia_output_lines[best_chi_squared_line].split()[8])
            print "\nA better minimum was found during the correlated error calculation."
            print "Reduced chi-squared = ", best_chi_squared,"\n\n"
            new_minimum = True
        else:
            print "\nNo change in the minimum chi-squared was found.\n\n"
            new_minimum = False

        block_print_with_line_breaks("(You can examine the Gosia output file (usually \"gosia.out\") before answering the following prompt.)")
        read_best_fit = yes_no_prompt("Would you like to save the best-fit matrix elements and their errors to the GUI memory [Y/n]: ",True)

        # If the user chose to read the new matrix elements, zero the correlated errors first.
        if read_best_fit:
            self.zero_all_correlated_errors()

        gosia_output_lines.reverse()  # Put back in the correct order.

        print "New best values and errors*:"
        print "--------------------------------------------------------------------------------"

        # Get the matrix keys in Gosia order to match the new best values from Gosia to the appropriate keys.
        matrix_keys_in_order = self.get_all_matrix_keys_in_gosia_order()

        data_line = findinlist(gosia_output_lines,["ESTIMATED","ERRORS"]) + 5
        while True:
            this_line = gosia_output_lines[data_line]
            fields = this_line.split()
            if len(fields) < 12:
                break
            internal_matrix_element_number = int(fields[0]) - 1
            matrix_key = matrix_keys_in_order[internal_matrix_element_number]
            # Get the matrix element object.
            matrix_element_object = self.matrix_data[matrix_key]
            original_value_of_reported_matrix_element = matrix_element_object.get_current_value()
            better_matrix_element_value    = float(fields[3])
            low_absolute_error             = float(fields[5])
            high_absolute_error            = float(fields[7].split(")")[0])
            low_percent_error              = float(fields[8])
            high_percent_error             = float(fields[10])

            # If the user chose to read the new best fit matrix elements to
            # memory, then save the correlated errors to the matrix elements.
            if read_best_fit:
                matrix_element_object.set_correlated_errors(low_absolute_error, high_absolute_error)

                # Set the new value of the matrix element.
                matrix_element_object.set_current_value(better_matrix_element_value)

                # See if this matrix element has dependents.  If it does, and
                # the user did not release couplings, then put the same
                # fractional error on all dependents.  If the user released 
                # couplings, then each matrix element will have its own
                # reported error.
                absolute_change_in_master = better_matrix_element_value - original_value_of_reported_matrix_element 
                fractional_change_in_dependent = absolute_change_in_master / original_value_of_reported_matrix_element 

                if not release:
                    for possible_dependent_key in self.matrix_data.keys():
                        possible_dependent_object = self.matrix_data[possible_dependent_key]
                        master_key = possible_dependent_object.get_master_matrix_element_key() 
                        if matrix_key == master_key:
                            # This is a dependent on the master just read.  Set
                            # its value so that it changes in proportion to the master's
                            # change.  Set its correlated errors so that it has the same fractional
                            # error as this master.
                            original_dependent_value = possible_dependent_object.get_current_value() 
                            if original_dependent_value > 0.0:
                                dependent_low_abs_error  =  (low_percent_error/100.) * original_dependent_value 
                                dependent_high_abs_error =  (high_percent_error/100.) * original_dependent_value 
                            else:
                                dependent_low_abs_error  = (high_percent_error/100.)  * original_dependent_value 
                                dependent_high_abs_error = (low_percent_error/100.) * original_dependent_value 
                            possible_dependent_object.set_correlated_errors(dependent_low_abs_error,dependent_high_abs_error)

            # Now get the value and identity of the matrix element stored in the GUI.
            multipole_code       = matrix_key[0]
            initial_band_name    = matrix_key[1]
            initial_spin         = matrix_key[2]
            final_band_name      = matrix_key[3]
            final_spin           = matrix_key[4]
            multipole_text = REVERSE_MULTIPOLE[multipole_code]

            # Now print the results for this matrix element
            comment = "(" + str(low_absolute_error).strip() + ", " + str(high_absolute_error).strip() + ")" + "  (" + str(low_percent_error)\
              + "%, " + str(high_percent_error) + "%)"
            formatted_matrix_entry = self.format_one_matrix_element(initial_band_name=initial_band_name,\
                          initial_spin=initial_spin,final_band_name=final_band_name,final_spin=final_spin,\
                          multipole_text=multipole_text,value=better_matrix_element_value,comment=comment)
            print formatted_matrix_entry 
            data_line += 1
            
        print "--------------------------------------------------------------------------------"
        print ""
        block_print_with_line_breaks("*Note that, in the case of correlated error calculations, correlations with matrix elements which you have fixed are not included.\n")

    def examine_setup_interactive(self):
        """Allows the user to display information about the nuclear level scheme.

        """

        try:
            initial_level_key, final_level_key = self.get_normalization_transition_keys()
            transition_string = initial_level_key[0] + " " + str(initial_level_key[1]) + " --> " + final_level_key[0] + " " + str(final_level_key[1])
            print "Normalization transition [initial level, final level] = ",transition_string
        except:
            block_print_with_line_breaks("The normalization transition has not been defined properly.  The nucleus is not fully defined to run Gosia.  You can define this transition using the button \"Gosia controls.\"  See help topic \"normalizationtransition.\"")

        print "Nucleus Z,A = ",self.get_value("Z"),", ",self.get_value("A")
        print "Nucleus is defined completely enough to send to Gosia: ",self.is_ready()
        if yes_no_prompt("List entire matrix [Y/n]? ",True):
            self.display_full_matrix()

        return 0

    def display_full_matrix(self):
        """Displays all master matrix elements, along with the states coupled to them.

        """

        # Clear the level scheme
        self.draw_level_scheme()
        pylab.ioff()


        lines_to_show = ["All matrix elements in memory:",\
                         "(\"DE\" is the diagonal error from the last time it was calculated; ",\
                         " \"CE\" is the correlated error.)",\
                         "----------------------------------------------------------------------------------------------------"]

        sorted_keys = self.get_all_matrix_keys_in_gosia_order()
        for matrix_key in sorted_keys:
            matrix_object = self.matrix_data[matrix_key]
            # Get the variables that index the matrix element.
            multipole_code, initial_band_name, initial_spin, final_band_name, final_spin = matrix_key
            initial_level_key = matrix_key[1:3]
            final_level_key   = matrix_key[3:5]
            # Get the multipole_text string.
            multipole_text = REVERSE_MULTIPOLE[multipole_code]
            current_value = round(matrix_object.get_current_value(),4)
            is_master = matrix_object.get_is_master()
            is_dependent = matrix_object.get_is_dependent()
            
            formatted_matrix_element = self.format_one_matrix_element(initial_band_name=initial_band_name,\
              initial_spin=initial_spin,final_band_name=final_band_name,final_spin=final_spin,\
              multipole_text=multipole_text,value=current_value).ljust(60)
            # If the correlated error is known, print it; same for the diagonal error.
            diagonal_errors   = str(matrix_object.get_diagonal_errors()).replace("[","(").replace("]",")")
            correlated_errors = str(matrix_object.get_correlated_errors()).replace("[","(").replace("]",")")
            formatted_matrix_element += " DE: " + diagonal_errors + " CE: " + correlated_errors
            lines_to_show.append(formatted_matrix_element)

            if is_master:
                this_color = 'g'
            elif is_dependent:
                this_color = 'r'
            else:
                this_color = 'k'

            units = UNITS_DICT[multipole_text]
            if not initial_level_key == final_level_key:
                # It's not a static moment
                self.drawonetransition(initial_band_name,final_band_name,initial_spin,final_spin,color=this_color,label=multipole_text,interactive=False)
            else:
                levelenergy = self.levels[initial_level_key].get_energy()
                self.drawstaticmoment(initial_band_name,levelenergy,requestedcolor=this_color,comment=multipole_text,update=False)

        # Force an update of the drawing.
        self.set_axes_nicely(self.number_of_bands(),self.maximum_level_energy())

        create_dialog_popup({"text_lines":lines_to_show,"title":"All matrix elements defined"})

        return 0

    def draw_level_data(self,plot_items_dictionary):
        """Called by examine method in experiment class.

        This method only draws level data with a circular marker.

        plot_items_dictionary has the format

        {(band_name,spin):(color,label_text)...}

        The plot information is passed as a dict so that data can be appended
        to each marker easily without a search in a list in the calling method.

        """

        # Turn off interactive updating for higher drawing speed
        pylab.ioff()

        for one_key in plot_items_dictionary.keys():
            object_to_plot = plot_items_dictionary[one_key]
            band_name,spin = one_key
            primary_level_key = self.get_primary_level_key_from_pseudonym(one_key)
            if not primary_level_key == None:
                # The level was found.
                primary_band_name, dummy = primary_level_key 
                band_number = self.get_band_number_for_display(primary_band_name)
                circle_color,yield_label = object_to_plot
                energy = self.get_level_information(primary_level_key,'energy')
                # Make the coordinages of band number and energy into floats.
                text_angle = 0.   # Not aligned for now.  This is a problem when expanding the window.
                text_coordinate_y = energy 
                text_coordinate_x = float(band_number)
                plt.scatter(band_number,energy,s=25,c=circle_color,marker=(0,3,0))
                plt.text(text_coordinate_x, text_coordinate_y, yield_label, dict(color=circle_color, multialignment="right", rotation=text_angle))
                #plt.text(text_coordinate_x, text_coordinate_y, yield_label, dict(color=circle_color, multialignment="left", rotation=text_angle, rotation_mode = "anchor"))

 
        pylab.draw()
        pylab.ion()

        return 0

    def draw_decays(self,plot_items_dictionary):
        """Called by examine method in experiment class.

        This method only draws decays.

        plot_items_dictionary has the format

        {(initial_band_name,final_band_name,initial_spin,final_spin):(color,label_text)...}

        The plot information is passed as a dict so that data can be appended
        to each marker easily without a search in a list in the calling method.

        """

        # Turn off interactive updating for higher drawing speed
        pylab.ioff()

        for one_key in plot_items_dictionary.keys():
            object_to_plot = plot_items_dictionary[one_key]
            initial_band_name, final_band_name, initial_spin, final_spin = one_key
            arrow_color,yield_label = object_to_plot
            initial_level_key = (initial_band_name, initial_spin)
            final_level_key   = (final_band_name, final_spin)
            initial_primary_level_key = self.get_primary_level_key_from_pseudonym(initial_level_key)
            final_primary_level_key   = self.get_primary_level_key_from_pseudonym(final_level_key)
            if not initial_primary_level_key == None and not final_primary_level_key == None:
                initial_primary_band_name, dummy = initial_primary_level_key 
                final_primary_band_name, dummy   = final_primary_level_key 
                initial_energy = self.get_level_information(initial_primary_level_key,'energy')
                final_energy   = self.get_level_information(final_primary_level_key,'energy')
                # Make sure the band numbers are floats now.
                initial_band_number = self.get_band_number_for_display(initial_primary_band_name)
                final_band_number   = self.get_band_number_for_display(final_primary_band_name)
                text_angle = 0.   # Not aligned for now.  This is a problem when expanding the window.
                text_coordinate_y = (initial_energy + final_energy)/2. 
                float_initial_band_number = float(initial_band_number)
                float_final_band_number   = float(final_band_number)
                plt.annotate("", xy=(float_final_band_number,final_energy),  xycoords='data', xytext=(float_initial_band_number,initial_energy),\
                  textcoords='data', horizontalalignment = 'center', verticalalignment = 'center', arrowprops=dict(arrowstyle="->",color=arrow_color))
                # Find a place for rotated text.
                text_coordinate_x = (float_initial_band_number + float_final_band_number)/2.
                plt.text(text_coordinate_x, text_coordinate_y, yield_label, dict(color=arrow_color, multialignment="center", rotation=text_angle))
 
        pylab.draw()
        pylab.ion()

        return 0

    def display_coupling_information(self,step=True):
        """Displays all master matrix elements, along with the states coupled to them.

        Also writes the matrix element values and couplings to the terminal.

        """

        # Clear the level scheme
        self.draw_level_scheme()

        # Get all matrix keys in Gosia order.
        all_matrix_keys = self.get_all_matrix_keys_in_gosia_order()

        # Cycle through the matrix element keys, picking out masters.  For each
        # master, get all of its dependents.

        block_print_with_line_breaks("The master is shown in green, and any dependents are shown in red.  The master is marked with a \"^\" if it hit the upper limit, or a \"v\" if it hit the lower limit in the last fit.  The fit is probably not at a true minimum if any limits were hit.",60)

        for matrix_key in all_matrix_keys:
            matrix_object = self.matrix_data[matrix_key]
            is_master = matrix_object.get_is_master()
            if is_master:
                # Make a new "queue" for output.  Printing in the loop is slowing everything down.
                output_lines = []
                # Get the master's matrix element information.
                master_multipole_number, master_initial_band_name, master_initial_spin, master_final_band_name, master_final_spin = matrix_key
                master_multipole_text = REVERSE_MULTIPOLE[master_multipole_number]
                # Get the level keys for the initial and final states of the master.
                master_initial_level_key = (master_initial_band_name,master_initial_spin)
                master_final_level_key   = (master_final_band_name,master_final_spin)
                master_initial_energy    = self.get_level_information(master_initial_level_key,'energy')
                master_final_energy      = self.get_level_information(master_final_level_key,'energy')
                # Get the initial and final band numbers for display.
                master_initial_band_number = self.get_band_number_from_primary_name(master_initial_band_name) + 1
                master_final_band_number   = self.get_band_number_from_primary_name(master_final_band_name)   + 1
                # Get matrix element information for display:
                master_value = matrix_object.get_current_value()
                master_upper_limit = matrix_object.get_upper_limit()
                master_lower_limit = matrix_object.get_lower_limit()

                # Get all of the keys of dependents on this master.
                dependent_matrix_keys = self.get_all_dependent_matrix_keys(matrix_key)

                # First, see if the master has hit the limits.  If it has, add a mark to the label text.
                hit_upper_limit = matrix_object.hit_upper_limit()
                hit_lower_limit = matrix_object.hit_lower_limit()

                if hit_upper_limit:
                    multipole_and_limit_hit = master_multipole_text + "^"
                    limit_comment = "HIT LOWER LIMIT."
                elif hit_lower_limit:
                    multipole_and_limit_hit = master_multipole_text + "v"
                    limit_comment = "HIT UPPWER LIMIT."
                else:
                    multipole_and_limit_hit = master_multipole_text
                    limit_comment = ""

                # Draw the master.
                if not master_initial_level_key == master_final_level_key:
                    # It's not a static moment
                    # Use False for faster drawing.
                    self.drawonetransition(master_initial_band_name,master_final_band_name,\
                      master_initial_spin,master_final_spin,'g',multipole_and_limit_hit,False)
                else:
                    # Use False for faster drawing.
                    self.drawstaticmoment(master_initial_band_name, master_initial_energy, 'g', multipole_and_limit_hit, False)

                # Print the master description.
                master_formatted_text = self.format_one_matrix_element(initial_band_name = master_initial_band_name,\
                  initial_spin = master_initial_spin, final_band_name = master_final_band_name, final_spin = master_final_spin,\
                  multipole_text = master_multipole_text, value = master_value, comment = limit_comment)
                output_lines.append(master_formatted_text)
                limits_text = "    Fit limits: " + str(master_lower_limit) + "," + str(master_upper_limit) + ".  Dependent matrix elements:"
                output_lines.append(limits_text)

                # Now cycle through all matrix elements dependent on this master and print, display them.
                number_of_dependents = 0

                # Turn off interactive updating for faster drawing.
                pylab.ioff()
                for dependent_matrix_key in dependent_matrix_keys:
                    dependent_matrix_object = self.matrix_data[dependent_matrix_key]
                    # Get the dependent's matrix element information.
                    dependent_multipole_number, dependent_initial_band_name, dependent_initial_spin, \
                      dependent_final_band_name, dependent_final_spin = dependent_matrix_key
                    dependent_multipole_text = REVERSE_MULTIPOLE[dependent_multipole_number]
                    # Get the level keys for the initial and final states of the master.
                    dependent_initial_level_key = (dependent_initial_band_name,dependent_initial_spin)
                    dependent_final_level_key   = (dependent_final_band_name,dependent_final_spin)
                    dependent_initial_energy    = self.get_level_information(dependent_initial_level_key,'energy')
                    dependent_final_energy      = self.get_level_information(dependent_final_level_key,'energy')
                    # Get the initial and final band numbers for display.
                    dependent_initial_band_number = self.get_band_number_from_primary_name(dependent_initial_band_name) + 1
                    dependent_final_band_number   = self.get_band_number_from_primary_name(dependent_final_band_name)   + 1
                    # Get matrix element information for display:
                    dependent_value = dependent_matrix_object.get_current_value()

                    # Print the dependent description.
                    dependent_formatted_text = self.format_one_matrix_element(initial_band_name = dependent_initial_band_name,\
                      initial_spin = dependent_initial_spin, final_band_name = dependent_final_band_name, final_spin = dependent_final_spin,\
                      multipole_text = dependent_multipole_text, value = dependent_value)
                    # Indent the dependents.
                    dependent_formatted_text = "    " + dependent_formatted_text 
                    output_lines.append(dependent_formatted_text)

                    # Increment the number of dependents for reporting.
                    number_of_dependents += 1

                    # Now plot the dependent on the level scheme window.
                    if not dependent_initial_level_key == dependent_final_level_key:
                        # It's not a static moment
                        # Use False for faster drawing.
                        self.drawonetransition(dependent_initial_band_name,dependent_final_band_name,\
                          dependent_initial_spin,dependent_final_spin,'r',dependent_multipole_text,False)

                        # self.drawanarrow(1,306,3,random.random()*1000.,"","r") # This is very fast.
                    else:
                        # Use False for faster drawing.
                        self.drawstaticmoment(dependent_initial_band_name, dependent_initial_energy, 'r', dependent_multipole_text, False)

                # Force an update of the drawing.
                self.set_axes_nicely(self.number_of_bands(),self.maximum_level_energy())
                # Print the summary of this set:
                for one_line in output_lines:
                    print one_line
                if number_of_dependents == 0:
                    print "    (This master has no dependents.)"
                print "--------------------------------------------------------------------------------"
                if step:
                    # Only prompt for the next one if the user didn't select all.
                    try:
                        choice = raw_input("Continue (yes,no or show all)[Y/n/a]: ")
                        choice = choice.lower().strip()[0]
                    except:
                        # User just hit enter.  Default to yes.
                        choice == "y"

                    if choice == "n":
                        print "Quitting."
                        return 0
                    elif choice == "y":
                        # Clear the level scheme again.
                        self.draw_level_scheme()
                    elif choice == "a":
                        # Set step to false so that it will continue drawing without further prompting.
                        step = False
                    else:
                        # Act as though the user hit "y".
                        # Clear the level scheme again.
                        self.draw_level_scheme()
                        

        print "These are the only fit parameters specified."
        print "Finished."

        return 0

    def set_or_fix_masters_by_rules(self,set_masters=None):
        """Sets all matrix elements to masters that satisfy Boolean rules.

        """

        if set_masters==None:
            while True:
                set_or_unset = raw_input("Choose [s]et or [u]nset (fix) masters: ").lower()
                try:
                    set_or_unset = set_or_unset[0]
                    if set_or_unset in ["s","u"]:
                        break
                    else:
                        print "Enter either \"s\" or \"u\"."
                except:
                    # The user didn't enter anything.
                    print "Enter either \"s\" or \"u\"."
        elif set_masters == True:
            set_or_unset = "s"
        elif set_masters == False:
            set_or_unset = "u"
        else:
            print "Invalid choice.\nQuitting."
            return -1

        print "Enter rules to select the matrix elements to be "
        if set_or_unset == "s":
            print "  set as masters (variable)."
        else:
            print "  fixed at their current values."
                    
        # Get a list of rules to select matrix elements
        rules_list = self.get_matrix_element_selection_rules()

        # Prompt for the fractional limits, if the choice was to set one or
        # more masters, and ask whether or not to couple static moments to the
        # lower E2 transitions.
        if set_or_unset == "s":
            while True:
                fractional_limit = prompt_number("Enter fractional +/- limit: ","f")
                if fractional_limit == "quit":
                    print "Cancelled."
                    return 0
                if fractional_limit <= 0.:
                    print "Invalid entry.  Please enter a fraction f > 0."
                else:
                    break

            couple_static = yes_no_prompt("If E2 static moments are selected, couple to E2 transition below [Y/n]? ",True)

        # Step through all matrix elements.  For matrix elements that meet all 
        # of the selection criteria in rules_list, set their coupling to the 
        # indices of the master, using the appropriate gosia code, or fix them as requested.
        for matrix_key in self.matrix_data.keys():
            # Extract all of the variables that might be referenced in the rules_list.
            # Test each rule (condition).  If all conditions are met for this matrix element,
            # couple this one to the master.  This "rules" method may be a minor nuisance to
            # the user, so maybe a "define quick dependency" button should also be included.
            # This is a good proof of principle for a method to selectively add or delete
            # matrix elements from set by writing rules in simple math, e.g.
            #   fi > ii               (final spin greater than initial spin)
            #   ib == 1               (initial band is 1)
            #   fb == 2 or fb == 3    (final band is 2 or 3)
            #   ml == 7               (multipolarity is M1)
            #   mt == "E2"            (multipolarity is E2)

            matrix_element_object = self.matrix_data[matrix_key]

            # Get the variables that index the matrix element.
            multipole_code, initial_band_name, initial_spin, final_band_name, final_spin = matrix_key
            # Get the multipole_text string.
            multipole_text = REVERSE_MULTIPOLE[multipole_code]
            # The band numbers as displayed on the level scheme diagram.
            initial_band_number = self.get_band_number_for_display(initial_band_name)
            final_band_number   = self.get_band_number_for_display(final_band_name)
            # Get the level keys to check, for example, whether the matrix_element is a static moment.
            initial_level_key = (initial_band_name,initial_spin)
            final_level_key   = (final_band_name,final_spin)
            current_value     = matrix_element_object.get_current_value()

            # Convert to simple two-character names, so the user can write simple
            # rules without long variable names.
            me = current_value   # The current value of the matrix element
            ml = multipole_code
            mt = multipole_text  # requires the user to type quotes--ml is easier.
            # Get the values of ii, bi, if, bf
            # (initial spin, initial band, final spin, final band)
            ii = initial_spin
            fi = final_spin
            ib = initial_band_number
            fb = final_band_number
            
            # Now run through all conditions to see if this matrix element meets the user's conditions.
            selected = True
            for condition in rules_list:
                try:
                    eval(condition)
                except:
                    print "The rule \"",condition,"\" is invalid."
                    print "Check the allowed variables and syntax, and try again."
                    print "Note that the equality operator is \"==\", not \"=\"."
                    print "Quitting."
                    return 0
                if not eval(condition):
                    # The matrix element does not meet one of the conditions
                    selected = False
                    break              # break out of the for loop

            # Fix or set this matrix element as a master, as requested by the user.
            if set_or_unset == "u":
                if selected:
                    # Unset (fix) this master.  For now, we leave matrix elements
                    # possibly coupled to this master.  Is this confusing to Gosia?
                    self.matrix_data[matrix_key].set_is_fixed()
                    # We don't delete the upper and lower limits.  This can be used
                    # as a basis to unlock them later.
            else:
                # The choice was to set the matrix element as a master.
                if selected:
                    # See if this is a static moment.
                    if initial_level_key == final_level_key and multipole_text == "E2":
                        is_static = True
                    else:
                        is_static = False

                    if not is_static or not couple_static:
                        # This is not a static moment, or the user chose to vary
                        # static moments.  Set it as a master with the user's
                        # specified limits.
                        # Calculate the lower and upper limits from the user's requested fractional limits
                        r1 = me * (1.0 - fractional_limit)
                        r2 = me * (1.0 + fractional_limit)
                        # Bug-fix: If the lower limit is higher than the upper limit (sign-sensitive), then swap them.
                        if r1 > r2:
                            r1, r2 = r2, r1
                        # Set the upper and lower limits.  This automatically sets these matrix elements to masters.
                        self.matrix_data[matrix_key].set_lower_limit(r1)
                        self.matrix_data[matrix_key].set_upper_limit(r2)
                        matrix_element_description = self.format_one_matrix_element(initial_band_name=initial_band_name,\
                          initial_spin=initial_spin,final_band_name=final_band_name,final_spin=final_spin,\
                          multipole_text=multipole_text,value=current_value)
                        print matrix_element_description 
                        print "  This matrix element now has limits ",r1,r2

                    elif is_static and couple_static:
                        # This is a static moment, and the user requested that it
                        # be coupled to the transition below.  Try to find the
                        # lower E2 transition from ii-2 to ii and couple to
                        # that.  Otherwise, leave it fixed.
                        lower_E2_initial_spin = round((initial_spin - 2.0),1)
                        lower_E2_final_spin   = final_spin
                        lower_E2_matrix_key = (multipole_code, initial_band_name, lower_E2_initial_spin, initial_band_name, lower_E2_final_spin)
                        # Try to find the E2 transition matrix element directly below.
                        try:
                            lower_E2_matrix_element_object = self.matrix_data[lower_E2_matrix_key]
                            # The desired E2 transition below exists.  Couple this static moment to it.
                            matrix_element_object.set_is_dependent()
                            matrix_element_object.set_master_initial_band_name(initial_band_name)
                            matrix_element_object.set_master_final_band_name(final_band_name)
                            matrix_element_object.set_master_initial_spin(lower_E2_initial_spin)
                            matrix_element_object.set_master_final_spin(lower_E2_final_spin)
                            matrix_element_object.set_master_multipole_string("E2")
                            matrix_element_description = self.format_one_matrix_element(initial_band_name=initial_band_name,\
                              initial_spin=initial_spin,final_band_name=final_band_name,final_spin=final_spin,\
                              multipole_text=multipole_text,value=current_value)
                            print matrix_element_description
                            print "  This static moment is now coupled to the E2 transition below."
                        except:
                            # The matrix element was not found.
                            # Just leave this static moment as it was.
                            matrix_element_description = self.format_one_matrix_element(initial_band_name=initial_band_name,\
                              initial_spin=initial_spin,final_band_name=final_band_name,final_spin=final_spin,\
                              multipole_text=multipole_text)
                            print matrix_element_description
                            print "  This static moment has no E2 transition below it.  "
                            print "  Its master/dependent/fixed status was not changed."

        print "Finished."
        return 0   # No error returned




    def set_normalization_transition(self):
        """Prompts the user for the bands and states of the normalizing transition for yield data.

        """

        # Report the current normalization transition.
        try:
            current_initial_level, current_final_level = self.get_normalization_transition_keys()
            print "Current transition for normalization is " + str(current_initial_level) + " --> " + str(current_final_level)
        except:
            block_print_with_line_breaks("The normalization transition is not defined.  You will need to define it before adding an experiment.")

        if yes_no_prompt("Change normalization [y/N]? ",False) == False:
            print "Normalization transition not changed."
            return 0

        block_print_with_line_breaks("Define the transition for normalization of all yields.  This must be a transition whose yield is measured accurately in all data sets and which is directly coupled by a matrix element in your matrix.  If you choose a transition which is not measured in one or more data sets, then those data sets cannot be used in Gosia.",70)
        initial_band_name_for_normalization = raw_input("Enter band NAME of initial state: ")
        final_band_name_for_normalization   = raw_input("Enter band NAME of final state: ")

        initial_spin_for_normalization = prompt_number("Enter spin of initial (HIGHER energy) state: ","r")
        if initial_spin_for_normalization == "quit":
            return 0
        final_spin_for_normalization = prompt_number("Enter spin of final (LOWER energy) state: ","r")
        if final_spin_for_normalization == "quit":
            return 0

        initial_level_key = (initial_band_name_for_normalization, initial_spin_for_normalization)
        final_level_key   = (final_band_name_for_normalization, final_spin_for_normalization)

        # Check that this is a DECAY transition (initial energy is greater than final energy).
        initial_energy = self.levels[initial_level_key].get_energy()
        final_energy   = self.levels[final_level_key].get_energy()
        if initial_energy > final_energy:
            is_decay_transition = True
        else:
            is_decay_transition = False
            block_print_with_line_breaks("The initial state energy is not greater than the final state energy.  You need to specify a *decay* transition whose yield is measured in all data sets used.",70)
            return -1
            
        if self.are_coupled(initial_level_key,final_level_key) and is_decay_transition:
            self.initial_band_name_for_normalization = initial_band_name_for_normalization
            self.final_band_name_for_normalization   = final_band_name_for_normalization
            self.initial_spin_for_normalization      = initial_spin_for_normalization
            self.final_spin_for_normalization        = final_spin_for_normalization 
        else:
            block_print_with_line_breaks("The states you have chosen are not coupled.\nAdd matrix elements coupling these two states and try again.\nQuitting.")
            return -1

        print "Normalization transition set to ",self.initial_band_name_for_normalization, self.initial_spin_for_normalization,\
          " --> ", self.final_band_name_for_normalization, self.final_spin_for_normalization
        return 0

    def zero_all_diagonal_errors(self):
        """Zeros all matrix elements' diagonal errors.

        """
        for matrix_key in self.matrix_data.keys():
            self.matrix_data[matrix_key].zero_diagonal_errors()
        return 0

    def zero_all_correlated_errors(self):
        """Zeros all matrix elements' correlated errors.

        """
        for matrix_key in self.matrix_data.keys():
            self.matrix_data[matrix_key].zero_correlated_errors()
        return 0

    def zero_calculated_lifetimes(self):
        """Sets all levels' calculated lifetimes to None.

        """

        for one_level_key in self.levels.keys():
            self.levels[one_level_key].zero_calculated_lifetime()

        return 0

    def zero_deorientation_Gs(self):
        """Sets all levels' calculated G2, G4, G6 to None.

        """
        for one_level_key in self.levels.keys():
            self.levels[one_level_key].zero_deorientation_Gs()

        return 0



    def get_non_isomer_levels(self):
        """Returns a list of level keys (band_name, spin) that are not isomeric.

        This is tested by checking that the calculated lifetime is finite
        within the range of Gosia calculated lifetimes.

        If the lifetimes have not been calculated yet by Gosia, then no level
        keys are returned.  (An empty list is returned.)

        """

        # Create the list for level keys.
        non_isomer_levels = []

        for level_key in self.levels.keys():
            band_name, spin = level_key

            # See if this is the ground state.  The ground state is never an
            # considered an isomer.  The ground state must be the first state
            # in the sorted unique level keys.  The internal level number is
            # *calculated* in this version of the code, since level objects are
            # stored by (band_name,spin) tuple keys.

            if not self.levels[level_key].get_calculated_lifetime() == None:
                non_isomer_levels.append(level_key)
            else:
                internal_level_number = self.lookup_internal_level_by_band_spin(band_name,spin)
                if internal_level_number == 0:
                    # This is the ground state.  Add it to the list of non-isomer levels.
                    non_isomer_levels.append(level_key)

        return non_isomer_levels

    def set_default_normalization_transition(self):
        """Defaults to state "2" to state "1" decay.

        """

        # See if it has already been set.  If not, set the default.

        try:
            self.initial_band_name_for_normalization
            self.initial_spin_for_normalization 
            self.final_band_name_for_normalization
            self.final_spin_for_normalization   
        except:
            # It has not been set.  Set the default (state 1-->0).

            all_keys = self.get_level_keys_in_gosia_order(include_inactive_bands = True)
            level_2 = all_keys[1]
            level_1 = all_keys[0]

            self.initial_band_name_for_normalization, self.initial_spin_for_normalization = level_2
            self.final_band_name_for_normalization,   self.final_spin_for_normalization   = level_1
            print "Default normalization transition is ",self.initial_band_name_for_normalization, self.initial_spin_for_normalization,\
              " --> ", self.final_band_name_for_normalization, self.final_spin_for_normalization
            print "You can change the normalization transition using the button \"Gosia controls.\""
            print "Use the \"Help\" button topic \"normalizationtransition\" for more information."

        return 0
            
    def get_normalization_transition_keys(self):
        """Returns the initial and final level keys of the normalizing transition.

        Returns two level dictionary keys (initial_band_name, initial_spin),
        (final_band_name, final_spin)

        """

        # Rewritten July 2011.

        return_keys = (self.initial_band_name_for_normalization, self.initial_spin_for_normalization),\
                      (self.final_band_name_for_normalization, self.final_spin_for_normalization)

        return return_keys

    def get_gosia_normalization_state_indices(self):
        """Returns the gosia level indices (two integers) of the normalization transition.

        If the state indices can't be found, returns None, None.

        """

        # August 2011

        try:
            initial_normalization_state_key, final_normalization_state_key = self.get_normalization_transition_keys()
            initial_band_name, initial_spin = initial_normalization_state_key
            final_band_name, final_spin     = final_normalization_state_key
            initial_gosia_level_index       = self.lookup_gosia_level_by_band_spin(initial_band_name, initial_spin)
            final_gosia_level_index         = self.lookup_gosia_level_by_band_spin(final_band_name, final_spin)
            return initial_gosia_level_index, final_gosia_level_index
        except:
            return None, None



    def get_all_band_names_in_order(self,include_inactive_bands = True):
        """Returns the band names in the order in which they are to be displayed.

        If include_inactive_bands is True, then all bands are returned.
        Otherwise, only active bands are returned.

        """

        names_to_return = []
        for i in range(len(self.band_settings_list)):
            band_entry = self.band_settings_list[i]
            band_name = band_entry[0]
            band_settings = band_entry[1]
            should_return = band_settings["active"]
            if include_inactive_bands or should_return:
                # Either all levels are requested, or this one can be displayed.
                # Add the level entry with data that can be used to sort the levels
                # into the proper order for display or for Gosia.
                names_to_return.append(band_name)
            
        return names_to_return

    def get_all_level_keys_in_band_name(self,requested_band_name):
        """Returns sorted level keys of all levels in this band.

        level keys are (primary band name, spin)

        """

        level_keys_to_return = []

        for one_level_key in self.levels.keys():
            this_band_name = one_level_key[0]
            if this_band_name == requested_band_name:
                level_keys_to_return.append(one_level_key)

        return level_keys_to_return


    def get_all_levels_list_in_display_order(self,include_inactive_bands):
        """Returns all levels in a list in the order in which they should be displayed.

        The returned data are in a list of the format 
            [[band_number_for_display, energy, spin, parity, band_name, can_be_excited],...]

        The band number is not permanent.  The user may reorder the bands.

        """


        sorted_unique_levels = self.get_level_keys_in_gosia_order(include_inactive_bands = True)
        level_list = []

        for one_level_key in sorted_unique_levels:
            band_name = one_level_key[0]
            spin      = one_level_key[1]
            band_number_for_display = self.get_band_number_for_display(band_name)
            level = self.levels[one_level_key]
            parity = level.get_parity()
            energy = level.get_energy()
            can_be_excited = level.can_be_excited()
            this_level_data = [band_number_for_display, energy, spin, parity, band_name, can_be_excited]
            level_list.append(this_level_data)

        # Sort the levels.  This will sort first by the band number, then by energy...
        # The user can only choose the band order, not the level order, so this
        # will sort according to the user's chosen order.
        level_list.sort()


        return level_list

    def get_band_number_for_display(self,band_name):
        """Returns the band number as it should appear in the display.

        If the band is not found, then -1 is returned as an error.

        """

        all_band_names = self.get_all_band_names_in_order(include_inactive_bands = True)
        try:
            this_band_number = all_band_names.index(band_name)
            return this_band_number + 1  # Returns the band number starting from 1 for the display.
        except:
            return -1
        

    def get_value(self,what):
        """Returns simple information from nuclear data.

        """
        if what == "A":
            return self.A
        elif what == "Z":
            return self.Z
        else:
            return "nucleus.get error - unknown quantity"

    def set_value(self,what,value):
        """Sets simple information from nuclear data.

        """
        if what == "A":
            self.A = value
        elif what == "Z":
            self.Z = value
        else:
            return "nucleus.set error - unknown quantity"

    def get_band_and_spin_from_gosia_level_number(self,gosia_level_number):
        """Returns a tuple (band_name, spin).

        band_name is the primary band name (not an alias).

        The gosia_level_number corresponds to the level number that would be
        given to gosia for this state by the def generate_gosia_input() method
        in this nucleus class.

        """

        # Change the gosia base-1 level number to the base-0 index used internally.
        internal_level_number = gosia_level_number - 1  

        # Get the levels in the order that they would be sent to Gosia.
        level_list = self.get_sorted_unique_levels()
        band_name, spin, parity, energy_in_keV = level_list[internal_level_number]

        return (band_name, spin)


    def matrix_element_exists(self,matrix_element_key):
        """Returns True if the matrix element exists.

        Time is saved in this method by only getting the keys in the stored
        order in the matrix element dictionary.

        """

        all_matrix_keys = self.matrix_data.keys()

        if matrix_element_key in all_matrix_keys:
            return True
        else:
            return False


    def get_all_matrix_keys_in_gosia_order(self):
        """Returns a list of all matrix keys in the order sent to Gosia.

        """

        # Get and sort all matrix keys into multipole order, then by band
        # number and spin.  This requires re-keying by band numbers instead of
        # names for the sort.  We use this matrix_sorting_dict for the sorting
        # operation.
        all_matrix_keys = self.matrix_data.keys()
        matrix_sorting_dict = {}  # keyed by (multipole_number, initial_band_number, initial_spin, final_band_number, final_spin)
                                  # Each key points to the corresponding orginal key in all_matrix keys:
                                  #          (multipole_number, initial_band_name, initial_spin, final_band_name, final_spin)
        for one_matrix_key in all_matrix_keys:
            multipole_number, initial_band_name, initial_spin, final_band_name, final_spin = one_matrix_key
            initial_band_number = self.get_band_number_from_primary_name(initial_band_name)
            final_band_number   = self.get_band_number_from_primary_name(final_band_name)
            sorting_key = (multipole_number, initial_band_number, initial_spin, final_band_number, final_spin)
            matrix_sorting_dict[sorting_key] = one_matrix_key
        # Now sort the matrix by band number, spin values to get the original
        # matrix keys in the proper order for Gosia.
        sorting_keys = matrix_sorting_dict.keys()
        sorting_keys.sort()
        matrix_keys_in_gosia_order = []
        for sorting_key in sorting_keys:
            matrix_keys_in_gosia_order.append(matrix_sorting_dict[sorting_key])
            

        return matrix_keys_in_gosia_order


    def get_sorted_unique_level_keys(self):
        """Returns the primary (not pseudonym) keys of all levels in the order they will go to Gosia.

        This calls get_sorted_unique_levels to get the list of level data in
        the proper order, then reduces this list to a list of level key tuples.

        """
        
        sorted_unique_levels = self.get_sorted_unique_levels()

        # Unzip the level entries into four tuples: band names, spins, parities, energies.
        bands, spins, parities, energies = zip(*sorted_unique_levels)

        # Zip together the (band,spin) tuples in the sorted order.
        band_spin_tuples = zip(bands,spins)

        return band_spin_tuples

    def get_sorted_unique_levels(self):
        """Gets all levels that reference the primary band names.

        These "primary band names" are the ones used in the
        bands_settings_list, not the aliases.  This will generate only one
        level entry if bands have been merged.

        The returned format is [[band_name, spin, parity, energy],[""],...]

        """

        primary_band_names = self.get_all_primary_band_names()

        # A list of entries to sort by band number, spin.
        # [[band_number, spin, energy, parity],["],...]
        level_sorting_list = []

        for one_key in self.levels.keys():
            band_name, spin = one_key
            if band_name in primary_band_names:  
                # If it isn't a pseudonym for another band.
                level_object = self.levels[one_key]  # This is the basis for deselecting individual levels as well as getting parity, etc.
                band_number = self.get_band_number_for_display(band_name)
                energy = level_object.get_energy()
                parity = level_object.get_parity()
                level_sorting_list.append([band_number, spin, energy, parity, band_name])

        # Now that we have all levels, we can sort by band number, then spin:
        level_sorting_list.sort()

        # Now, in the sorted order, make a list of 
        # [[band_name, spin, parity, energy],[""],...]
        output_level_list = []
        for one_level in level_sorting_list:
            band_number, spin, energy, parity, band_name = one_level
            output_level_list.append([band_name, spin, parity, energy])

        return output_level_list


    def get_primary_band_name_from_band_number(self,band_number):
        """Returns the primary band name from the band number as displayed.

        If the band number is out of range, then None is returned.

        """

        all_band_names = self.get_all_primary_band_names()
        internal_band_number = band_number - 1
        try:
            band_name = all_band_names[internal_band_number]
            return band_name
        except:
            # The requested band number must be out of range.  Return None.
            return None
            
    def get_band_number_from_primary_name(self,band_name):
        """Returns the band number or None if it can't be found.

        August 2011.

        """

        all_primary_band_names = self.get_all_primary_band_names()
        try:
            band_number = all_primary_band_names.index(band_name)
            return band_number
        except:
            return None



    def get_all_primary_band_names(self):
        """This returns all current band names.

        Former names (pseudonyms) of merged donor bands are not included.

        """

        # Unzip the band name and settings dictionary.
        try:
            band_names, settings_dictionary = zip(*self.band_settings_list)
            return band_names
        except:
            return None

    def generate_gosia_input(self,fix_all=False):
        """Generates the lines for OP,GOSI's LEVE and ME

        """


        output_lines = ['OP,GOSI','LEVE']

        # A list of the band names already annotated in the gosia input.
        band_names_already_annotated = []

        # Get the sorted level entries for Gosia
        level_list = self.get_sorted_unique_levels()
        for i in range(len(level_list)):
            gosia_level_number = i + 1  # Base 1 for gosia.
            band_name, spin, parity, energy_in_keV = level_list[i]
            energy_in_MeV = energy_in_keV / 1000.  # Energy in MeV for Gosia

            # Might want to add band names eventually for annotating the gosia input
            this_level_line = str(gosia_level_number)+' '+str(parity)+' '+str(spin)+' '+str(energy_in_MeV)

            # If this band was not already annotated, append it as a comment,
            # and add its name to the list of annotated bands.
            if not band_name in band_names_already_annotated:
                this_level_line = this_level_line + "  !  Band: " + band_name
                band_names_already_annotated.append(band_name)

            output_lines.append(this_level_line)

        # Add the "0 0 0 0" marker for the end of the LEVE section, and add the
        # marker for the section "ME."
        output_lines.extend(['0 0 0 0','ME'])

        # Put all matrix elements in the "upper triangle" required by Gosia.
        # This means that all matrix elements must go from an initial level to
        # (itself or) a higher-numbered level.
        self.put_matrix_elements_in_gosia_direction()

        # This list temporarily stores a list of the multipoles that were
        # already marked with the required
        # "multipole_code,0,0,0,0"
        # label in the ME section.
        multipoles_already_marked = []

        # Get all matrix keys in the proper order for Gosia.
        matrix_keys_in_gosia_order = self.get_all_matrix_keys_in_gosia_order()

        # Now process the matrix into Gosia format using the properly sorted keys.
        for matrix_element_key in matrix_keys_in_gosia_order:
            multipole_code = matrix_element_key[0]
            initial_band_name = matrix_element_key[1]
            initial_spin      = matrix_element_key[2]
            final_band_name   = matrix_element_key[3]
            final_spin        = matrix_element_key[4]
            multipole_text    = REVERSE_MULTIPOLE[multipole_code]

            # Make sure the matrix object thinks it is well-defined.  If not, print an error and quit.
            if not self.matrix_data[matrix_element_key].get_is_good():
                print "One or more matrix elements is not properly defined.  Please report this bug."
                matrix_element_description = self.format_one_matrix_element(initial_band_name=initial_band_name,\
                  initial_spin=initial_spin,final_band_name=final_band_name,final_spin=final_spin,\
                  multipole_text=multipole_text)
                print "Error in the definition of ",matrix_element_description
                print "The calculation cannot continue."
                return -1

            initial_gosia_level = self.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
            final_gosia_level   = self.lookup_gosia_level_by_band_spin(final_band_name,final_spin)
            matrix_element_value = self.matrix_data[matrix_element_key].get_current_value()

            if fix_all:
                # Fix all matrix elements in the gosia input only.
                # This can be used for example to generate a phoney fit input (op,mini)
                # for calculating the deorientation coefficients.
                r1 = 1
                r2 = 1
                comment = "   ! fixed"

            # Determine appropriate flags and indices for coupled matrix elements,
            # fixed or master matrix element.
            elif self.matrix_data[matrix_element_key].get_is_dependent():
                is_dependent = True
                final_gosia_level = -final_gosia_level  # set negative flag indicating that this is a dependent matrix element
                master_multipole_number    = self.matrix_data[matrix_element_key].get_master_multipole_number()
                master_initial_band_name   = self.matrix_data[matrix_element_key].get_master_initial_band_name()
                master_final_band_name     = self.matrix_data[matrix_element_key].get_master_final_band_name()
                master_initial_spin        = self.matrix_data[matrix_element_key].get_master_initial_spin()
                master_final_spin          = self.matrix_data[matrix_element_key].get_master_final_spin()
                master_initial_gosia_level = self.lookup_gosia_level_by_band_spin(master_initial_band_name,master_initial_spin)
                master_final_gosia_level   = self.lookup_gosia_level_by_band_spin(master_final_band_name,master_final_spin)

                # Get r1 and r2, which are in this case the initial and final
                # gosia level indices to define which master this dependent
                # matrix element is coupled to.
                r1 = master_initial_gosia_level
                # Set the appropriate prefix on r2 if this matrix element is
                # coupled to a master of another multipole.  Otherwise, r2 is
                # simply the final level number of the master matrix element.
                if multipole_code == master_multipole_number:
                    r2 = master_final_gosia_level
                else:
                    # Add master multipole code n so that r2 reads "n0#", where # 
                    # is the final state of the master (or "n##" for two-digit 
                    # level number)
                    r2 = 100*master_multipole_number + master_final_gosia_level

                # Get the master's multipole text ("E2", "M1", etc.) to comment the coupling.
                master_multipole_text = REVERSE_MULTIPOLE[master_multipole_number]
                
                # Add a comment describing which master this dependent is coupled to.
                comment = "   ! coupled to <" + str(master_final_gosia_level) + "||" \
                  + master_multipole_text + "||" + str(master_initial_gosia_level) + ">"

            elif self.matrix_data[matrix_element_key].get_is_master():
                # It is a master matrix element.  Set r1 and r2 to the lower and upper limits.
                r1 = self.matrix_data[matrix_element_key].get_lower_limit()
                r2 = self.matrix_data[matrix_element_key].get_upper_limit()
                comment = "   ! master"
            else:
                # This must be a fixed matrix element.  (Consistency in the
                # fixed/master/dependent definition has already been checked by
                # the "is_good()" method, so this is the only remaining possibility.)
                r1 = 1
                r2 = 1
                comment = "   ! fixed"

            # May want to add an annotation to matrix_data and reprint it here.
            if not multipole_code in multipoles_already_marked: # if we haven't yet printed the multipole header
                output_lines.append(str(multipole_code)+' 0 0 0 0')
                multipoles_already_marked.append(multipole_code)

            # Add this matrix entry to the gosia input stream.
            # The gosia input runs properly with entries of the following format.
            #this_line = str(initial_gosia_level)+' '+str(final_gosia_level)+' '+str(matrix_element_value)+' '+str(r1)+' '+str(r2)

            # Formatting for readability:
            this_line = str(initial_gosia_level).ljust(2) + ' ' + str(final_gosia_level).ljust(3) + \
              ' ' + str(matrix_element_value).ljust(16) + ' ' + str(r1).ljust(16) + ' ' + str(r2).ljust(16) 
            this_line = this_line.ljust(58) # justify to line up the comment fields
            this_line = this_line + comment
            output_lines.append(this_line)

        output_lines.append('0 0 0 0 0')
            

        return output_lines


    def update_major_couplings(self):
        """Scans all matrix elements to find all bands coupled.

        This is used to update the level scheme window with the couplings
        between bands and in-band moments.  One or more couplings in a band or
        between bands is sufficient to label a "major coupling."

        A list is made of the form [[band1,band2,multipolecode,"text"],...]
        band1 can equal band2 to indicate inband E2/M1 sets.
        "text" may be used to label arrows on screen

        2010/06/09 - changed this to zero the couplings information each time
        it is called.

        July 2011: Updating this for the new level object structure and storage
        of the band information.

        """

        # 2010/06/09 zero the coupling information before regenerating it.  The
        # time advantage is not worth trying to save it.
        self.major_couplings = []

        for this_matrix_key in self.matrix_data.keys():
            # Extract the information from the key.  This is done in several
            # lines, in case something is added to the key.
            multipole_number     = this_matrix_key[0]
            initial_band_name    = this_matrix_key[1]
            initial_spin         = this_matrix_key[2]
            final_band_name      = this_matrix_key[3]
            final_spin           = this_matrix_key[4]
            # We don't need the pointer to the matrix element object.
            #this_matrix_element_object = self.matrix_data[this_matrix_key]
            # The description field on the level scheme diagram will be only the multipole text: E2, M1,... 
            description = REVERSE_MULTIPOLE[multipole_number]
            # Form a list to add to the major couplings:
            # The band *names* are used now to make the methods more robust.
            # Band numbers may change, but the names will not.
            this_major_coupling = [initial_band_name, final_band_name, multipole_number, description]

            # If this coupling (initial, final bands and multipole) has not
            # already been found, add it to the list of major couplings.
            if not this_major_coupling in self.major_couplings:
                self.major_couplings.append(this_major_coupling)

        return self.major_couplings

    def lowest_excitation_energy(self):
        """Returns the energy of the lowest excited state.

        """

        lowest_level_energy = self.maximum_level_energy()

        for one_level_key in self.levels.keys():
            this_energy = self.levels[one_level_key].get_energy()
            if this_energy < lowest_level_energy and this_energy > 0.0:  # Don't want the ground state.
                lowest_level_energy = this_energy

        return lowest_level_energy

    def maximum_level_energy(self):
        """Returns the highest level energy in memory.

        This should be modified to include or exclude inactive levels at the
        user's choice.

        """

        highest_level_energy = 0.

        for one_level_key in self.levels.keys():
            this_energy = self.levels[one_level_key].get_energy()
            if this_energy > highest_level_energy:
                highest_level_energy = this_energy

        return highest_level_energy


    def number_of_levels(self):
        """This has been updated for the pseudonym structure.

        We don't want to count levels twice if one is only a pseudonym for another.

        """

        return len(self.get_sorted_unique_levels())

    def number_of_bands(self,include_inactive_levels = False):
        """Return the number of bands in memory.

        """
        
        number_of_bands = 0
        for one_entry in self.band_settings_list:
            try:
                active_status = one_entry[1]["active"]
            except:
                # The active status has not been stored.
                print "Band ",one_entry[0]," has not been stored properly.  Please report this bug."
                active_status = True
            if active_status or include_inactive_levels:
                number_of_bands += 1

        return number_of_bands 

    def highestbandnumber(self):
        """Return the highest number of all bands in memory.

        """
        print "highestbandnumber is not finished."
        return len(self.band_settings_list) + 1
        

    def get_band_number_from_name(self,band_name):
        """Returns the band number from either a name or pseudonym.

        """

        for i in range(1,self.number_of_bands() + 1):
            this_band_name = self.getbandinfo(i,"name")
            this_band_pseudonym = self.getbandinfo(i,"pseudonym")
            if band_name == this_band_name or band_name == this_band_pseudonym:
                return i

        # If the band was not found, return None
        return None



    def getbandinfo(self,band_name,what):
        """Return information about the requested band.

        Note that the "head" is defined as the lowest-energy member
        in memory.

        """

        if what == "headenergy":
            # Rewritten Aug 2011.
            lowest_energy = None
            level_keys_in_band = self.get_all_level_keys_in_band_name(band_name)
            for one_level_key in level_keys_in_band:
                this_level = self.levels[one_level_key]
                level_energy = this_level.get_energy()
                if lowest_energy == None or level_energy < lowest_energy:
                    lowest_energy = level_energy
            return lowest_energy
        elif what == "K":
            # Rewritten July 2011.
            # Need to find the first level in this band and ask its K value.
            all_level_keys = self.get_sorted_unique_level_keys()
            for one_level_key in all_level_keys:
                # Get the band name
                this_band_name = one_level_key[0]
                if this_band_name == band_name:
                    this_level = self.levels[one_level_key]
                    K_value = this_level.get_K()
                    # Found a level in the band, which has a K value stored in
                    # it.  Return this K.
                    return K_value
        elif what == "number":
            # Rewritten July 2011.
            # Return the internal band number (base 0).
            all_band_names = self.get_all_band_names_in_order(include_inactive_bands = True)
            if band_name in all_band_names:
                return all_band_names.index(band_name)
            else:
                # Return a -1 flag to indicate that the band name is not in the
                # band settings list.  It may be a pseudonym, but this is not
                # handled here.
                return -1
                

    def setbandinfo(self,band,what,value):
        """Set information about a band.

        """
        self.fullsort()  # sort first to make searching easier
        try:
            if  what == "K":
                self.bandk[band] = value
                new_value = self.getbandinfo(band,"K")
            elif what == "name":
                self.bandname[band] = str(value)
            elif what == "pseudonym":
                self.bandpseudonym[band] = str(value)
            return 0
        except:
            print "Invalid band or setting."
            return -1

            
    def fix_matrix_element(self,matrixelementidentity):
        """Marks a matrix element as fixed and removes its limits.

        If matrixelementidentity = "all", every matrix element in memory is
        fixed at its current value.

        Later on, there should be a button to just fix/free a master.  This would
        keep the limits in memory, so the fixed/free status can be quickly turned
        on or off.  This will take some work, because gosia does not understand 
        when a free matrix element is coupled to a fixed matrix element.

        This could be done while preserving limits and couplings by just
        marking the master as fixed and then in the method to generate the ME
        section of OP,GOSI fixing the master and all m.e. coupled to it.

        """
        if not matrixelementidentity == "all":
            multipole_code,initial_band,initial_spin,final_band,final_spin = matrixelementidentity
            # Define the string that indicates that a matrix element is coupled to this master.
            coupling_string = "coupled to " + str(multipole_code)
            # Get the initial and final internal level numbers of the master.
            initial_level = self.get_level_number(initial_band,initial_spin)
            final_level = self.get_level_number(final_band,final_spin)

        for i in range(len(self.matrix_data)):
            # Go through all matrix elements and remove the couplings to this former master.
            # Gosia does not understand couplings to fixed matrix elements!
            # When master is found, set it to fixed.
            if matrixelementidentity == "all":
                matrixelement = self.matrix_data[i]
                matrixelement[4] = 1  
                matrixelement[5] = 1
                matrixelement[6] = "Fixed"
                self.matrix_data[i] = matrixelement
            else:
                matrixelement = self.matrix_data[i]
                this_multipole_code = matrixelement[0]
                this_initial_level = matrixelement[1]
                this_final_level = matrixelement[2]
                this_initial_band = self.get_level_information(this_initial_level,"band")
                this_final_band = self.get_level_information(this_final_level,"band")
                this_initial_spin = self.get_level_information(this_initial_level,"spin")
                this_final_spin = self.get_level_information(this_final_level,"spin")
                this_r1 = matrixelement[4]
                this_r2 = matrixelement[5]
                this_coupling = matrixelement[6]
                if (initial_level == this_initial_level and final_level == this_final_level\
                  and multipole_code == this_multipole_code) or (this_coupling == coupling_string \
                  and this_r1 == initial_level and this_r2 == final_level):
                    # This is either the master to be fixed or a dependent on this master.
                    matrixelement[4] = 1  
                    matrixelement[5] = 1
                    matrixelement[6] = "Fixed"
                    self.matrix_data[i] = matrixelement

        # No error testing at this point!
        return 0

    def setmatrixelementlimits(self,matrixelementidentity,limits):
        """Sets the limits of the matrix element defined by matrixelementidentity

        limits = [r1,r2]

        """
        r1, r2 = limits
        multipole_code,initial_band,initial_spin,final_band,final_spin = matrixelementidentity
        for i in range(len(self.matrix_data)):
            matrixelement = self.matrix_data[i]
            this_multipole_code = matrixelement[0]
            this_initial_level = matrixelement[1]
            this_final_level = matrixelement[2]
            this_initial_band = self.get_level_information(this_initial_level,"band")
            this_final_band = self.get_level_information(this_final_level,"band")
            this_initial_spin = self.get_level_information(this_initial_level,"spin")
            this_final_spin = self.get_level_information(this_final_level,"spin")
            if initial_band == this_initial_band and initial_spin == this_initial_spin and final_band == this_final_band\
              and final_spin == this_final_spin and multipole_code == this_multipole_code:
                # This is the one we want
                matrixelement[4] = r1  
                matrixelement[5] = r2
                matrixelement[6] = "master"
                self.matrix_data[i] = matrixelement
                return 0  # no error 

        # If not found in self.matrix_data, return an error.
        return "setmatrixelement error - not found"

    def are_coupled(self,initial_level_key,final_level_key):
        """If the two states (internal numbering) are coupled by at least one matrix element, True is returned.

        Uses internal level numbering (base 0).

        Otherwise, False is returned.
        """

        # Change to the primary level keys.  The level keys requested could be
        # pseudonyms, and the matrix should only contain references to the
        # primary levels, not pseudonyms.
        initial_level_key = self.get_primary_level_key_from_pseudonym(initial_level_key)
        final_level_key   = self.get_primary_level_key_from_pseudonym(final_level_key)

        # If either call to get a primary level key failed, then this level is
        # not in memory and is not coupled to any other level.  In this case,
        # return False.
        if None in [initial_level_key,final_level_key]:
            return False

        # Get the initial band name, spin and the final band name, spin to check for coupling.
        initial_band_name = initial_level_key[0]
        initial_spin      = initial_level_key[1]
        final_band_name   = final_level_key[0]
        final_spin        = final_level_key[1]

        they_are_coupled = False
        for one_matrix_key in self.matrix_data.keys():
            this_initial_band_name = one_matrix_key[1]
            this_final_band_name   = one_matrix_key[3]
            this_initial_spin      = one_matrix_key[2]
            this_final_spin        = one_matrix_key[4]

            # Check to see if there is a coupling in either order (initial
            # state to final state, or final state to initial state):

            if (this_initial_spin == initial_spin and this_final_spin == final_spin and \
                this_initial_band_name == initial_band_name and this_final_band_name == final_band_name) or\
               (this_final_spin == initial_spin and this_initial_spin == final_spin and \
                this_initial_band_name == final_band_name and this_final_band_name == initial_band_name):
                they_are_coupled = True
                break # out of the for loop

        return they_are_coupled
            
    def prompt_for_matrix_element(self):
        """ Prompts the user to define a matrix element.

        Returns the matrix element key as a tuple. 

        If the initial or final level cannot be found, return None.  

        This does NOT check for the existence of the matrix element itself, so
        that this method can be used more widely.

        """

        print "(Enter q to quit.)"
        initial_band_number =   prompt_number("Initial band NUMBER: ","i")
        if initial_band_number == "quit":
            return None
        # Get the primary band names from the band numbers.
        initial_primary_band_name = self.get_primary_band_name_from_band_number(initial_band_number)
        if initial_primary_band_name == None:
            print "Invalid band number."
            return None
        final_band_number =     prompt_number("Final band NUMBER: ","i")
        if final_band_number == "quit":
            return None
        # Get the primary band names from the band numbers.
        final_primary_band_name = self.get_primary_band_name_from_band_number(final_band_number)
        if final_primary_band_name == None:
            print "Invalid band number."
            return None

        # Get rounded floats for spins, so that they can be matched exactly to
        # the integer or half-integer spins.
        initial_spin =   prompt_number("Initial spin: ","r")
        if initial_spin == "quit":
            return None
        final_spin =     prompt_number("Final spin: ","r")
        if final_spin == "quit":
            return None

        # Construct level keys.
        initial_level_key = (initial_primary_band_name,initial_spin)
        final_level_key   = (final_primary_band_name,final_spin)

        # If one or both levels cannot be found, return None.
        if not (initial_level_key in self.levels.keys() and final_level_key in self.levels.keys()):
            print "One or both levels not found."
            return None

        multipole_text = ""
        while not multipole_text in MULTIPOLE.keys(): 
            multipole_text = raw_input("Multipole (E1...E6 or M1, M2): ")

        # Get the Gosia multipole code number used to key the matrix.
        multipole_code = MULTIPOLE[multipole_text]

        matrix_element_key = (multipole_code,initial_primary_band_name,initial_spin,final_primary_band_name,final_spin)

        return matrix_element_key 

    def user_set_masters(self):
        """Prompts the user to set master matrix elements.

        If only one master was set, then it asks if the user would like to add
        dependencies to the master, so that the master definition doesn't have
        to be typed twice.  (Saves a click and prompts.)

        """

        print "Master matrix elements will be fit to gamma-ray yield data,"
        print "  and dependent matrix elements can be specified to vary "
        print "  with a master."
        print ""
        print "Choose from the following options to set one or more masters:"
        print ""
        print " s  Set a master matrix element"
        print " d  Add dependent matrix elements to vary with a master matrix element"
        print " u  Fix (unset) one or all master matrix elements"
        print " r  Select individual master matrix elements by rules"
        print " f  Fix (unset) matrix elements by rules"
        print ""
        print "Options r and f take Boolean rules to set or fix master matrix elements."
        print ""
        print " p  Display fit parameters"
        print ""

        # A list of valid options for evaluating the user's choice.
        all_options = ["s","u","r","f","d","p","a"]

        option = raw_input("Enter a letter from the options above: ").lower()
        if not option in all_options:
            print "Invalid choice.  Quitting."
            # Return None to tell the GUI not to save undo information.
            return None

        if option == "p":
            self.display_coupling_information()
            # Return None to tell the GUI not to save undo information.
            return None
            
        elif option == "u":
            # Unset one or more masters (return them to fixed matrix elements).
            fix_all = yes_no_prompt("Fix all [y/N]? ",False)
            if fix_all == True:
                for one_matrix_key in self.matrix_data.keys():
                    self.matrix_data[one_matrix_key].set_is_fixed()
                print "All matrix elements now fixed at present values."
                return 0
            else:
                print "Define the master matrix element:"
                master_matrix_element_key = self.prompt_for_matrix_element()

                # Check that this matrix element exists.
                if not master_matrix_element_key in self.matrix_data.keys():
                    print "This matrix element does not exist.  Quitting."
                    return -1
                else:
                    # Fix this matrix element.
                    self.matrix_data[master_matrix_element_key].set_is_fixed()
                    print "This matrix element is now fixed."
                    print "Matrix elements coupled to this master are still coded"
                    print " as coupled to it, so if you reset it as a master, they"
                    print " will again vary with this master in a fit."
                    return 0

        elif option == "s":

            print "Define the master matrix element:"
            master_matrix_element_key = self.prompt_for_matrix_element()

            # Check that this matrix element exists.
            if not master_matrix_element_key in self.matrix_data.keys():
                print "This matrix element does not exist.  Quitting."
                return -1

            # Get the multipole code and text.
            multipole_code = master_matrix_element_key[0]
            multipole_text = REVERSE_MULTIPOLE[multipole_code]

            # Get the proper units for this multipole.
            units = UNITS_DICT[multipole_text]

            # Get the current value of the matrix element and report to the user.
            current_value = self.matrix_data[master_matrix_element_key].get_current_value()
            print "Matrix element value: ", current_value, units

            # Get the lower and upper limits, and make sure that they make sense.
            limits_are_sensible = False
            while not limits_are_sensible:
                lower_limit = prompt_number("Lower limit (sign-sensitive): ","f")
                if lower_limit == "quit":
                    print "Quitting."
                    return None
                upper_limit = prompt_number("Upper limit (sign-sensitive): ","f")
                if upper_limit == "quit":
                    print "Quitting."
                    return None
                if lower_limit > upper_limit:
                    # They are in the wrong order (sign sensitive).  Swap them.
                    print "Reversing the matrix element limits so that the lower limit is less than the upper limit."
                    lower_limit, upper_limit = upper_limit, lower_limit
                if not (current_value >= lower_limit and current_value <= upper_limit):
                    print "Limits must not exclude the current value!  Try again."
                else:
                    limits_are_sensible = True

            # Set the upper and lower limits.  This automatically sets the matrix element to a master.
            self.matrix_data[master_matrix_element_key].set_upper_limit(upper_limit)
            self.matrix_data[master_matrix_element_key].set_lower_limit(lower_limit)
            print "Lower limit: ",lower_limit, "set."
            print "Upper limit: ",upper_limit, "set."

            # Ask the user whether or not to add dependencies to this master.  This saves re-entering the master definition.
            add_dependencies = yes_no_prompt("Add dependencies to this master [Y/n]? ",True)
            if add_dependencies:
                self.add_dependencies(master_key=master_matrix_element_key)
            return 0


        elif option == "r":
            return_code = self.set_or_fix_masters_by_rules(set_masters=True)
            return 0

        elif option == "f":
            return_code = self.set_or_fix_masters_by_rules(set_masters=False)
            return 0


        elif option == "d":
            self.add_dependencies()
            return 0

        else:
            print "Invalid option.  Cancelled."
            return_code = None


    def get_level_information(self,level_key,what):
        """Returns information about a level in memory.

        get_level_information(level_key,what)

        level_key is a tuple (band_name,spin)

        "what" must specify a string 'spin', 'lifetime', 'parity', or 'energy', or 'exists'

        Returned type will be int for bandnumber, but float for spin or energy.

        Return value is Boolean (True or False) for "exists".

        """

        if what == 'spin':
            try:
                return_spin = self.levels[level_key].get_spin()
            except:
                return_spin = None
            return return_spin
        elif what == 'energy':
            try:
                return_energy = self.levels[level_key].get_energy()
            except:
                return_energy = None
            return return_energy
        elif what == 'calculated lifetime':
            try:
                return_lifetime = self.levels[level_key].get_calculated_lifetime()
            except:
                return_lifetime = None
            return return_lifetime
        elif what == 'parity':
            try:
                return_parity = self.levels[level_key].get_parity()
            except:
                return_parity = None
            return return_parity
        elif what == "exists":
            try:
                self.levels[level_key]
                return True
            except:
                return False
        elif what == "internal_level_number":
            all_keys = self.get_level_keys_in_gosia_order(include_inactive_bands = True)
            for internal_level_number in range(len(all_keys)):
                if level_key == all_keys[internal_level_number]:
                    return internal_level_number
            # If flow goes to here, it was not found.  Return None.
            return None

        else:
            # error.  return -1 for now.  
            return -1


    def makewindow(self,option=""):
        """Creates a level scheme window for the nucleus object.

        """


        plt.figure(LEVELSCHEMEFIGURE,figsize=LSFIGSIZE)

        pylab.ion()       # Make sure updating is on.  I may have to flip on/off for speed in some methods.
        pylab.draw()      # force a draw
        pylab.ioff()  # testing....


        return


    def addtxtlabel(self,x,y,sometext):
        """Plots a text label on the active window.

        Note that LaTeX notation works, e.g. $\gamma$!
        """
        plt.figure(LEVELSCHEMEFIGURE,figsize=LSFIGSIZE)
        pylab.text(x, y, sometext)

    def plotalevel(self,energy,position,levellabel,levelcolor=LEVELCOLOR):
        """Plots a line representing a single level.

        """

        plt.figure(LEVELSCHEMEFIGURE,figsize=LSFIGSIZE)
        pylab.plot([position-LEVELWIDTH/2.,position+LEVELWIDTH/2.],[energy,energy],color=levelcolor)
        pylab.text(position+LEVELWIDTH/2.,energy,levellabel,fontsize = SPINLABELFONTSIZE)

    def clear_window(self):
        """Clears the figure window to prepare for a new drawing.

        """

        # Clear the figure.
        plt.figure(LEVELSCHEMEFIGURE,figsize=LSFIGSIZE)
        pylab.clf()  # Clear the window.

    def draw_a_particle_detector(self,xy_points,title,x_label,y_label,theta_r=None,phi_r=None,sample_points=None):
        """Draws the x,y detector shape specified by at least three pairs of x,y coordinates

        This could be in any arbitrary frame sent by the calling function, and
        the x,y,labels and title will describe the frame and units.  If sample
        points are given, then the theta,phi sampling sent to Gosia will be
        displayed in red.

        """

        self.clear_window()
        pylab.ioff()
        # Get the values of the maximum and minimum x,y coordinates
        # Unzip into an x list and a y list.
        x_tuple,y_tuple = zip(*xy_points)
        max_x = max(x_tuple)
        max_y = max(y_tuple)
        min_x = min(x_tuple)
        min_y = min(y_tuple)
        
        for i in range(len(xy_points) - 1):
            x = xy_points[i][0]
            y = xy_points[i][1]
            next_x = xy_points[i + 1][0]
            next_y = xy_points[i + 1][1]
            pylab.plot([x,next_x],[y,next_y],color='k')
        # Draw the linear connection from the last point to the first.
        pylab.plot([next_x,xy_points[0][0]],[next_y,xy_points[0][1]],color='k')
        y_span = max_y - min_y
        x_span = max_x - min_x


        # Mark the point selected as the intersection of a normal to the target
        # center.
        if not theta_r == None and not phi_r == None:
            label_string = "Normal to target at (theta,phi) = ("+str(round(theta_r,2))+", "+str(round(phi_r,2))+") degrees"
            self.drawanarrow(0. - 0.25*x_span,0. + 0.25*y_span,0.,0.,label_string,"r")
            pylab.plot([0.,0.],[min_y,max_y],'g')

        low_y_plot_limit = min_y - 0.1 * y_span
        high_y_plot_limit = max_y + 0.1 * y_span
        low_x_plot_limit = min_x - 0.1 * x_span
        high_x_plot_limit = max_x + 0.1 * x_span
        
        plt.title(title)
        plt.xlabel(x_label)
        plt.ylabel(y_label)
        if not theta_r == None and not phi_r == None:
            plt.ylim(low_y_plot_limit,high_y_plot_limit)
        else:
            plt.ylim(high_y_plot_limit,low_y_plot_limit)
        plt.xlim(low_x_plot_limit,high_x_plot_limit)

        pylab.draw()  # to show the plot

        if not sample_points == None:
            # Sample points were given as they will be sent to gosia.  Draw the
            # lines representing these samples of the detector shape.
            for i in range(len(sample_points)):
                theta = sample_points[i][0]
                for j in range(len(sample_points[i]) / 2):
                    phi_1,phi_2 = sample_points[i][(2*j) + 1:(2*j) + 2 + 1]  # Python list notation--second index needs "+1".
                    pylab.plot([phi_1,phi_2],[theta,theta],color='r')

        pylab.draw()  # to show the plot

        return 0


    def plotredtransprob(self,band1,band2,requested_multipole_text):
        """Plots B(ML)'s values in the "upward" direction.

        "Upward" is defined as higher in a band or to the right in the level
        scheme, following the convention of excitation direction in gosia--from
        lower-numbered to higher-numbered level in Gosia's LEVE section.  Note
        that the usual Weisskopf unit in the downward direction is used,
        however, to plot the Weisskopf estimate line!

        This uses the same window as the level scheme drawing, so it Will be
        necessary to redraw level scheme window after this is no longer wanted
        on figure.

        """
        # Clear the figure.
        plt.figure(LEVELSCHEMEFIGURE,figsize=LSFIGSIZE)
        pylab.ioff()
        pylab.clf()  # Clear the window.

        spinlist = []    # The list of initial spins for the selected transitions.
        blist    = []    # The list of B(Ml) values for the selected transitions.

        # The matrix data must be sorted from low to high spin in order for
        # this to work in a consistent direction for in-band B(ML) plots.
        # Get all matrix keys in Gosia order.
        all_matrix_keys = self.get_all_matrix_keys_in_gosia_order()

        requested_multipole_code = MULTIPOLE[requested_multipole_text]  # Get the gosia code for a multipole.
        for matrix_key in all_matrix_keys:
            matrix_object = self.matrix_data[matrix_key]
            # Get the variables that index the matrix element.
            multipole_code, initial_band_name, initial_spin, final_band_name, final_spin = matrix_key
            # Get the multipole_text string.
            multipole_text = REVERSE_MULTIPOLE[multipole_code]
            current_value = matrix_object.get_current_value()
            # Get the level keys.
            initial_level_key = (initial_band_name,initial_spin)
            final_level_key   = (final_band_name,final_spin)
            # The band numbers as displayed on the level scheme diagram.
            initial_band_number = self.get_band_number_for_display(initial_band_name)
            final_band_number   = self.get_band_number_for_display(final_band_name)



            if initial_band_number == band1 and final_band_number == band2 and\
              multipole_text == requested_multipole_text and\
              not initial_level_key == final_level_key:  # Skip static moments
                spinlist.append(initial_spin)
                blist.append(bmlambda(initial_spin,current_value))

        # Get the Weisskopf estimate for this multipolarity in the downward 
        # direction (spin lambda --> spin 0).

        weisskopf = calc_wu(self.A,requested_multipole_text)

        # Set appropriate x limits.
        x_min = min(spinlist) - 1.
        x_max = max(spinlist) + 1.

        # Draw a line at the Weisskopf estimate (for decays, but this is 
        # still helpful).  The x limits from above are used to set the 
        # beginning and end of the line.

        wxlist = [x_min,x_max]
        wylist = [weisskopf,weisskopf]
        plt.plot(wxlist,wylist,'r--')

        # Make it a log scale
        plt.semilogy()
        # plot it
        plt.scatter(spinlist,blist,s=25,c='r',marker=(0,3,0))

        # Set appropriate y limits for the plot
        y_min = 10**(int(math.log10(min(min(wylist),min(blist))))-1)
        y_max = 10**(round(math.log10(max(max(wylist),max(blist))))+1)
        # If only one B(Ml) then set y_max one decade higher than y_min
        if y_max == y_min:
            y_max = 10.0 * y_min

        plt.ylim(y_min,y_max)
        plt.xlim(x_min,x_max)

        # Put on axis labels
        plt.xlabel('Initial spin')
        plt.ylabel('B(ML;up)')

        # show the figure & update
        pylab.draw()  # to show the plot

        # Output of the mean B(ML) and W.u.
        summed_bml = 0.
        for one_bml in blist:
            summed_bml += one_bml
        mean_bml = summed_bml / len(blist)
        print "                      Mean B(ML;up):  " + str(mean_bml)
        print "Single particle estimate B(ML;down):  " + str(weisskopf)
        print "               Mean B(ML;up) [W.u.]:  " + str(mean_bml/weisskopf)

        # Write spinlist, blist to rachel_bml.txt file
        bml_output_lines = []
        for i in range(len(spinlist)):
            this_spin = spinlist[i]
            this_bml = blist[i]
            line_to_write = str(this_spin) + '  ' + str(this_bml) + '\n'
            bml_output_lines.append(line_to_write)
        with open('rachel_bml.txt','w') as bml_output_file:
            bml_output_file.writelines(bml_output_lines)
        print "B(ML) points written to file rachel_bml.txt."
        raw_input("Press enter to quit the Plot B(ML) function and resume the GUI.")
        self.draw_level_scheme()
            

    def plotalllevels(self,completelist):
        """Clears the pylab window and draws levels with text spin labels.

        This drawing method checks whether or not levels can be populated, and
        whether or not they are isomers.  Isomers and unpopulated levels are
        shown in red.


        """

        # First, get the list of level keys of non-isomer (finite lifetime)
        # levels so that isomer levels can be properly marked.
        non_isomer_levels = investigated_nucleus.get_non_isomer_levels()

        plt.figure(LEVELSCHEMEFIGURE,figsize=LSFIGSIZE)
        pylab.ioff()
        pylab.clf()  # clear the window
        for i in range(len(completelist)):
            levelenergy = completelist[i][0] # float
            levelband = completelist[i][1]   # int
            levelspin = completelist[i][2]   # Text, e.g. "23/2"
            levelparity = completelist[i][3] # Text, i.e. "+" or "-"

            # Get the float spin value.
            spin = round(float(levelspin),1)

            # Get the band name from the displayed band number.
            band_name = self.get_primary_band_name_from_band_number(levelband)
            level_key = (band_name,spin)

            # Call the experiment_manager to see if there is any information on isomeric
            # and decoupled levels.

            # The following population and lifetime checks are made the first
            # time that gosia is called for a fit calculation, so they may not
            # be defined yet.  If they are not defined, the levels are drawn in
            # red.  
            #try:
            if not the_experiment_manager.is_populated(level_key):
                level_color = "r"
            else:
                level_color = "k"
            if not level_key in non_isomer_levels:
                level_color = "r"
            #except:
            #    level_color = "r"  # show in red if not yet established as isomer/populated.

            spinparity = levelspin+levelparity # concatenate the spin-parity for the text label
            self.plotalevel(levelenergy,levelband,spinparity,level_color) # use band number as position 
        pylab.ion()
        
    def drawanarrow(self,x1,y1,x2,y2,arrowlabel="",requestedcolor=LEVELCOLOR):
        """Draws a generic arrow with a label and color.

        label defaults to null
        color defaults to LEVELCOLOR

        """

        plt.figure(LEVELSCHEMEFIGURE,figsize=LSFIGSIZE)
        plt.annotate(arrowlabel, xy=(x2,y2),  xycoords='data',
                xytext=(x1,y1), textcoords='data',
                arrowprops=dict(arrowstyle="->",color=requestedcolor)
                )

    def drawstaticmoment(self,band_name,levelenergy,requestedcolor=RMEARROWCOLOR,comment=None,update=False):
        """Plots a representation of a static moment on a level.

        Updating August 2011 in version -57.

        For now, I am drawing a circle on the left end of a level.

        """

        band_number = self.get_band_number_for_display(band_name)
        plt.figure(LEVELSCHEMEFIGURE,figsize=LSFIGSIZE)
        x_position = band_number - LEVELWIDTH/2.
        x_position_for_label = 0.95 * x_position
        plt.scatter(x_position,levelenergy,s=25,c=requestedcolor,marker=(0,3,0))
        if not comment == None:
            plt.annotate(comment, xy=(x_position,levelenergy),  xycoords='data',
                xytext=(x_position_for_label,levelenergy), textcoords='data',
                arrowprops=dict(arrowstyle="->",color=requestedcolor))
        if update:
            self.set_axes_nicely(self.number_of_bands(),self.maximum_level_energy())


    def set_axes_nicely(self,nbands,maxenergy):
        """Makes space for interband m.e. arrows below zero energy 

        """
        plt.figure(LEVELSCHEMEFIGURE,figsize=LSFIGSIZE)

        # Make tick labels for the x axis, composed of band name, number and
        # the K label.

        bandlist= ['']
        active_band_names = self.get_all_band_names_in_order(include_inactive_bands = True)
        for band_name in active_band_names:
            K = self.getbandinfo(band_name,"K")
            # If this is band #1, prepend "K=" to the K quantum number string.
            # This is only done for band 1 to save space on the plot.
            internal_band_number = self.getbandinfo(band_name,"number")
            external_band_number = internal_band_number + 1
            if external_band_number == 1:
                K_label = "K=" + str(K)
            else:
                K_label = str(K)
            band_number_string = str(external_band_number) + "\n" + band_name + "\n" + K_label
            bandlist.append(str(band_number_string))
        bandlabels = tuple(bandlist)

        plt.xticks(numpy.arange(nbands + ASMIDGE),bandlabels)
        plt.ylim(-maxenergy/5., 1.1*maxenergy)   # a little extra head room and room 
                                                 # for interband arrows at the bottom.
        plt.xlim(0., nbands + 1.1)  # Add a little extra to round nbands up to next 
                                    # integer, so that enough space is allowed for 
                                    # the full level scheme.
        title_string = "Z = " + str(self.Z) + ",  A = " + str(self.A) + ". K values are for the band heads."
        #pylab.title('Level Scheme Window')
        pylab.title(title_string)
        pylab.ylabel('Energy (keV)')
        pylab.draw()  # v. 2.0.0.beta: starting to get errors here if called from outside.

        
    def draw_level_scheme(self):
        """Draw the level scheme, including "major couplings"

        This does not create the window.  

        This draws the levels with spin-parity labels and puts on single
        "major" arrows for the sets of matrix elements.

        """

        # Draw the level scheme in the window.
        # plotalllevels needs a list of energies and a list of levels.
        completelist = [] # list of level data for plotalllevels()

        # Step through the bands in the order in which they are to be
        # displayed.  Don't ask for inactive bands.
        all_displayed_band_names = self.get_all_band_names_in_order(include_inactive_bands = False)
        all_level_data = self.get_all_levels_list_in_display_order(include_inactive_bands = False)
        for one_level_entry in all_level_data:
            this_band_number, energy, spin, parity, band_name, can_be_excited = one_level_entry
            if band_name in all_displayed_band_names:
                # If the band is not hidden (disabled) by the user.
                if parity == -1:
                    parity_text = '-'
                elif parity == 1:
                    parity_text = '+'
                spin_text = str(spin)
                completelist.append([energy,this_band_number,spin_text,parity_text])

        # Make sure there is at least one level to display.
        if len(all_level_data) == 0:
            # No levels in memory.
            print "No levels in memory."

            plt.figure(LEVELSCHEMEFIGURE,figsize=LSFIGSIZE)
            pylab.ioff()
            pylab.clf()  # clear the window
            # Just draw one dummy level.
            levelenergy = 0.0 # float
            levelband = 1   # int
            level_color = "r"
            spinparity = ""
            self.plotalevel(levelenergy,levelband,spinparity,level_color) # use band number as position 
            pylab.text(0.75,500.,"No level data in memory.")
            pylab.ion()
            self.set_axes_nicely(1,1000.)
            pylab.draw()
            return 0

        # There are levels in memory.  Draw them all.
        self.plotalllevels(completelist)

        # Draw major couplings from band to band.  First, make an updated list
        # of major couplings.
        self.update_major_couplings()

        # Now represent all major couplings on the display with arrows.  Fits
        # the arrows into the space below zero on the level scheme window.
        # This requires setting the axes, so we know where to fit in the
        # arrows.
        self.set_axes_nicely(self.number_of_bands(),self.maximum_level_energy())
        lowlim,highlim = plt.ylim()

        # Display on the plot window the number of levels and matrix elements
        # in memory.
        temporary_number_of_levels = self.number_of_levels()
        temporary_number_of_me     = self.number_of_matrix_elements()
        if temporary_number_of_levels > MAXIMUMLEVELS:
            nlevels_label_color = 'r'
        else:
            nlevels_label_color = 'g'
        if temporary_number_of_me > MAXIMUM_NUMBER_OF_MATRIX_ELEMENTS: 
            nme_label_color = 'r'
        else:
            nme_label_color = 'g'

        pylab.text(0.1,0.7*highlim,str(temporary_number_of_me)+'\nm.e.',color=nme_label_color)
        pylab.text(0.1,0.9*highlim,str(temporary_number_of_levels)+'\nlevels',color=nlevels_label_color)

        # Count the major interband couplings (one for each multipole and pair
        # of bands) to figure the spacing for them.
        def f(x): return not x[0] == x[1]
        ninterbandcouplings = len(filter(f,self.major_couplings))
        majorarrowspacing = lowlim / (ninterbandcouplings + 1.)  # This will be negative
        currentyposition = majorarrowspacing # set position for first arrow

        # Now go through the major couplings and draw either an arrow with
        # label below the level scheme (interband) or a text label on the level
        # scheme (intraband).
        for this_coupling in self.major_couplings:
            band_name_1 = this_coupling[0]   # initial band
            band_name_2 = this_coupling[1]   # final band
            multipole_code = this_coupling[2]   # 7 for m1
            # Get the current band numbers for the initial and final bands of
            # the coupling.
            all_band_names_list = self.get_all_band_names_in_order(include_inactive_bands = True)
            # The current band number corresponding to this name is the
            # position in the band names list +1, since the positions start at
            # 0.
            band_number_1 = all_band_names_list.index(band_name_1) + 1
            band_number_2 = all_band_names_list.index(band_name_2) + 1
            x1 = float(band_number_1)
            x2 = float(band_number_2)
            # textlabel is the "description" field in the major couplings,
            # which will be the multipole text for now ("E2", "M1", etc.)
            textlabel = this_coupling[3]  
            if band_number_1 == band_number_2:   # if in-band
                # Only going to be E2 or M1.  If it's E2, put it higher than M1
                if multipole_code == 2:   # E2
                    y = 0.95 * highlim
                else:                      # M1
                    y = 0.90 * highlim
                self.addtxtlabel(x1-LEVELWIDTH/2.,y,textlabel)  # start at left edge of band
            else:     
                # Interband.  Draw arrow below the digram and put label on it:
                # initial band, final band, y position, no text label
                self.drawinterbandarrow(x1,x2,currentyposition,'')
                self.addtxtlabel((x1+x2)/2.,currentyposition,textlabel)
                currentyposition = currentyposition + majorarrowspacing

        # Redraw.
        pylab.draw()

        return 0


    def drawinterbandarrow(self,initialband,finalband,yposition,text):
        """Draws a "major" arrow representing coupling between two bands.

        Need to figure out where to put pylab.draw() for best speed and 
        adequate updating.
        """
        self.drawanarrow(initialband,yposition,finalband,yposition,text,INTRINSICARROWCOLOR)


    def drawonetransition(self,initial_band_name,final_band_name,initial_spin,final_spin,color='k',label="",interactive=True):
        """Draws one transition arrow

        Updating August 2011 in version -57.

        """

        # Turn off interactive updating for higher drawing speed
        initial_level_key = (initial_band_name,initial_spin)
        final_level_key   = (final_band_name,final_spin)
        initial_energy = self.get_level_information(initial_level_key,'energy')
        final_energy   = self.get_level_information(final_level_key,'energy')
        initial_band_number = self.get_band_number_for_display(initial_band_name)
        final_band_number   = self.get_band_number_for_display(final_band_name)
        self.drawanarrow(initial_band_number,initial_energy,final_band_number,final_energy,label,color) 

        return 0

    def draw_in_band_details(self,band_number,multipole_text):
        """Draws "minor" arrows representing all couplings.

        Only draws couplings for one multipole at a time.

        dI=2 arrows are shifted from dI = 1 arrows for clarity.

        multipole_text is "e2","m1".

        """

        # A dictionary to store the text lines for printing.  The dictionary is
        # keyed by initial and final spin, so that we can easily sort the
        # entries for printing.

        matrix_element_printing_dict = {}

        # Convert the multipole text to a code number
        requested_multipole_code = MULTIPOLE[multipole_text]

        # Get the requested primary band name.
        requested_band_name = self.get_primary_band_name_from_band_number(band_number)
        internal_band_number   = self.getbandinfo(requested_band_name, "number")
        band_number = internal_band_number + 1

        # Turn off interactive updating for higher drawing speed
        pylab.ioff()

        # Loop through all matrix elements and draw the selected ones
        for one_matrix_key in self.matrix_data.keys():
            multipole_code    = one_matrix_key[0]
            initial_band_name = one_matrix_key[1]
            final_band_name   = one_matrix_key[3]
            initial_spin      = one_matrix_key[2]
            final_spin        = one_matrix_key[4]
            initial_K = self.levels[(initial_band_name, initial_spin)].get_K()
            final_K   = self.levels[(final_band_name, final_spin)].get_K()
            if multipole_code == requested_multipole_code and\
              initial_band_name == requested_band_name and\
              final_band_name == requested_band_name:
                # multipole, initial and final bands match this matrix element.
                reduced_matrix_element = self.matrix_data[one_matrix_key].get_current_value()
                is_master              = self.matrix_data[one_matrix_key].get_is_master()
                is_fixed               = self.matrix_data[one_matrix_key].get_is_fixed()
                is_dependent           = self.matrix_data[one_matrix_key].get_is_dependent()
                matrix_element_good    = self.matrix_data[one_matrix_key].get_is_good()  # True if the matrix element is defined properly.
                if matrix_element_good:
                    error_comment = ""
                else:
                    error_comment = "Matrix element master/fixed/dependent status is not properly defined.  Plese report this as a bug."
                spin_difference = int(abs(final_spin - initial_spin) + ASMIDGE)  # round to nearest integer
                # Get energies of initial and final levels
                initial_energy = self.levels[(initial_band_name,initial_spin)].get_energy()
                final_energy   = self.levels[(final_band_name,final_spin)].get_energy()

                # Get the upper and lower limits, etc.  Non-masters can have
                # error bars, depending on how the errors were calculated!
                diagonal_errors   = self.matrix_data[one_matrix_key].get_diagonal_errors()
                correlated_errors = self.matrix_data[one_matrix_key].get_correlated_errors()
                if not None in diagonal_errors:
                    diagonal_errors_string = format(-abs(100.0 * diagonal_errors[0] / reduced_matrix_element), ".3g").rjust(10)\
                                    + "  " + format(abs(100.0 * diagonal_errors[1] / reduced_matrix_element), ".3g").rjust(10)
                else:
                    diagonal_errors_string = "".rjust(10)
                diagonal_errors_string = diagonal_errors_string.rjust(20)
                if not None in correlated_errors:
                    correlated_errors_string = format(-abs(100.0 * correlated_errors[0] / reduced_matrix_element), ".3g").rjust(10)\
                                      + "  " + format(abs(100.0 * correlated_errors[1] / reduced_matrix_element), ".3g").rjust(10)
                else:
                    correlated_errors_string = "".rjust(10)
                correlated_errors_string = correlated_errors_string.rjust(20)
                if is_master:
                    upper_limit       = self.matrix_data[one_matrix_key].get_upper_limit()
                    lower_limit       = self.matrix_data[one_matrix_key].get_lower_limit()
                    if self.matrix_data[one_matrix_key].hit_upper_limit():
                        upper_limit_string = "*" + format(upper_limit,".3g").rjust(10)
                    else:
                        upper_limit_string = " " + format(upper_limit,".3g").rjust(10)
                    if self.matrix_data[one_matrix_key].hit_lower_limit():
                        lower_limit_string = "*" + format(lower_limit,".3g").rjust(10)
                    else:
                        lower_limit_string = " " + format(lower_limit,".3g").rjust(10)
                    both_limits_string = lower_limit_string + upper_limit_string 
                    both_limits_string = both_limits_string.rjust(25) 
                    comment = diagonal_errors_string + correlated_errors_string + both_limits_string 
                elif is_dependent:
                    master_key = self.matrix_data[one_matrix_key].get_master_matrix_element_key()
                    master_multipole_code = REVERSE_MULTIPOLE[master_key[0]]
                    dependent_string = "dependent on <" + str(master_key[3:4+1]).strip("()").replace("'",'"') + " ||" + master_multipole_code + "|| " + str(master_key[1:2+1]).strip("()").replace("'",'"') + ">"
                    comment = diagonal_errors_string + correlated_errors_string + dependent_string.rjust(56)
                else:
                    comment = diagonal_errors_string + correlated_errors_string 
                    
                # Store the matrix element text temporarily for printing a list.
                formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                  final_band_name = final_band_name, final_spin = final_spin, multipole_text = multipole_text, \
                  value = reduced_matrix_element, initial_K = initial_K, final_K = final_K)
                formatted_text = formatted_text.ljust(90)
                full_line = formatted_text + comment + error_comment
                matrix_element_printing_dict[(initial_spin,final_spin)] = full_line

                # Set the appropriate color for a master/dependent/fixed matrix element.
                if is_master:
                    this_color = MASTERMECOLOR
                elif is_fixed:
                    this_color = FIXEDMECOLOR
                else:
                    # It's a dependent matrix element.
                    this_color = RMEARROWCOLOR

                if initial_spin == final_spin:  # Draw a representation of a static moment
                    self.drawstaticmoment(requested_band_name,initial_energy,this_color)
                else:                 # Transition matrix element
                    if spin_difference == 1:  # Stagger the dI=1,2 arrows so you can see both.
                        self.drawanarrow(band_number-LEVELWIDTH/4.,initial_energy,band_number-LEVELWIDTH/4.,final_energy,"",this_color) # no text
                    else:  # dI=2.  Stagger the even & odd spin arrows so they don't overlap
                        # This is done by staggering left/right by the value of the integer part of the spin, mod 2.
                        this_position = band_number + (LEVELWIDTH/4.) * (round(initial_spin) % 2)
                        self.drawanarrow(this_position,initial_energy,this_position,final_energy,"",this_color) # no text

        # Draw and turn interactive updating back on.
        self.set_axes_nicely(self.number_of_bands(),self.maximum_level_energy())
        pylab.ion()

        # Sort the matrix element text strings for printing
        output_keys = matrix_element_printing_dict.keys()
        output_keys.sort()
        matrix_element_list = []

        # Add a header line.
        matrix_element_list.append("Matrix element".ljust(90) + "   Diagonal errors (%)" + "   Correlated errors (%)" + "    Lower limit" + "  Upper limit")

        for one_key in output_keys:
            this_line = matrix_element_printing_dict[one_key]
            matrix_element_list.append(this_line)

        matrix_element_list.extend(["","Fixed matrix elements are shown in black,",\
                                       "masters (variable in fits)      in green,",\
                                       "dependents (on a master)        in red.",\
                                       "",\
                                       "To see which dependents are linked to which",\
                                       "masters, use the \"Examine setup\" button, option \"p\"."])

        # Display the list of matrix element values.  If popups aren't enabled,
        # then this will go to the terminal.
        title_string = multipole_text + " matrix elements in band " + str(band_number)
        create_dialog_popup({"text_lines":matrix_element_list,"title":title_string})


    def draw_interband_details(self,requested_initial_band_number,requested_final_band_number,multipole_text):
        """Draws "minor" arrows representing all couplings.

        Only draws couplings for one multipole.

        multipole text is "e2","m1", etc.
        """

        # A dictionary to store the text lines for printing.  The dictionary is
        # keyed by initial and final spin, so that we can easily sort the
        # entries for printing.

        matrix_element_printing_dict = {}

        # Convert the multipole text to a code number
        requested_multipole_code = MULTIPOLE[multipole_text]

        # Get the requested internal band numbers.
        requested_initial_internal_band_number = requested_initial_band_number - 1
        requested_final_internal_band_number   = requested_final_band_number - 1

        # Turn off interactive updating for higher drawing speed.
        pylab.ioff()

        # Loop through all matrix elements and draw the selected ones
        for one_matrix_key in self.matrix_data.keys():
            multipole_code    = one_matrix_key[0]
            initial_band_name = one_matrix_key[1]
            final_band_name   = one_matrix_key[3]
            initial_spin      = one_matrix_key[2]
            final_spin        = one_matrix_key[4]
            initial_internal_band_number = self.getbandinfo(initial_band_name, "number")
            final_internal_band_number   = self.getbandinfo(final_band_name, "number")
            initial_K = self.levels[(initial_band_name, initial_spin)].get_K()
            final_K   = self.levels[(final_band_name, final_spin)].get_K()
            if multipole_code == requested_multipole_code and\
              initial_internal_band_number == requested_initial_internal_band_number and\
              final_internal_band_number   == requested_final_internal_band_number:
                # multipole, initial and final bands match this matrix element.
                reduced_matrix_element = self.matrix_data[one_matrix_key].get_current_value()
                is_master              = self.matrix_data[one_matrix_key].get_is_master()
                is_fixed               = self.matrix_data[one_matrix_key].get_is_fixed()
                is_dependent           = self.matrix_data[one_matrix_key].get_is_dependent()
                matrix_element_good    = self.matrix_data[one_matrix_key].get_is_good()  # True if the matrix element is defined properly.
                if matrix_element_good:
                    error_comment = ""
                else:
                    error_comment = "Matrix element master/fixed/dependent status is not properly defined.  Plese report this as a bug."
                spin_difference = int(abs(final_spin - initial_spin) + ASMIDGE)  # round to nearest integer
                # Get energies of initial and final levels
                initial_energy = self.levels[(initial_band_name,initial_spin)].get_energy()
                final_energy   = self.levels[(final_band_name,final_spin)].get_energy()

                # Get the upper and lower limits, etc.  Non-masters can have
                # error bars, depending on how the errors were calculated!
                diagonal_errors   = self.matrix_data[one_matrix_key].get_diagonal_errors()
                correlated_errors = self.matrix_data[one_matrix_key].get_correlated_errors()

                if not None in diagonal_errors:
                    diagonal_errors_string = format(-abs(100.0 * diagonal_errors[0] / reduced_matrix_element), ".1f").rjust(10)\
                                    + "  " + format(abs(100.0 * diagonal_errors[1] / reduced_matrix_element), ".1f").rjust(10)
                else:
                    diagonal_errors_string = "".rjust(10)
                diagonal_errors_string = diagonal_errors_string.rjust(20)

                if not None in correlated_errors:
                    correlated_errors_string = format(-abs(100.0 * correlated_errors[0] / reduced_matrix_element), ".1f").rjust(10)\
                                      + "  " + format(abs(100.0 * correlated_errors[1] / reduced_matrix_element), ".1f").rjust(10)
                else:
                    correlated_errors_string = "".rjust(10)
                correlated_errors_string = correlated_errors_string.rjust(20)
                if is_master:
                    upper_limit       = self.matrix_data[one_matrix_key].get_upper_limit()
                    lower_limit       = self.matrix_data[one_matrix_key].get_lower_limit()
                    if self.matrix_data[one_matrix_key].hit_upper_limit():
                        upper_limit_string = "*" + format(upper_limit,".3g").rjust(10)
                    else:
                        upper_limit_string = " " + format(upper_limit,".3g").rjust(10)
                    if self.matrix_data[one_matrix_key].hit_lower_limit():
                        lower_limit_string = "*" + format(lower_limit,".3g").rjust(10)
                    else:
                        lower_limit_string = " " + format(lower_limit,".3g").rjust(10)
                    both_limits_string = lower_limit_string + upper_limit_string 
                    both_limits_string = both_limits_string.rjust(25) 
                    comment = diagonal_errors_string + correlated_errors_string + both_limits_string 
                elif is_dependent:
                    master_key = self.matrix_data[one_matrix_key].get_master_matrix_element_key()
                    master_multipole_code = REVERSE_MULTIPOLE[master_key[0]]
                    dependent_string = "dependent on <" + str(master_key[3:4+1]).strip("()").replace("'",'"') + " ||" + master_multipole_code + "|| " + str(master_key[1:2+1]).strip("()").replace("'",'"') + ">"
                    comment = diagonal_errors_string + correlated_errors_string + dependent_string.rjust(56)
                else:
                    comment = diagonal_errors_string + correlated_errors_string 
                    
                # Store the matrix element text temporarily for printing a list.
                formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                  final_band_name = final_band_name, final_spin = final_spin, multipole_text = multipole_text, \
                  value = reduced_matrix_element, initial_K = initial_K, final_K = final_K, comment = "")
                formatted_text = formatted_text.strip().ljust(90) 
                full_line = formatted_text + comment + error_comment
                matrix_element_printing_dict[(initial_spin,final_spin)] = full_line
                # Set the appropriate color for a master/dependent/fixed matrix element.
                if is_master:
                    this_color = MASTERMECOLOR
                elif is_fixed:
                    this_color = FIXEDMECOLOR
                else:
                    # It's a dependent matrix element.
                    this_color = RMEARROWCOLOR

                self.drawanarrow(requested_initial_band_number,initial_energy,requested_final_band_number,final_energy,"",this_color) # no text

        # Draw and turn interactive updating back on.
        self.set_axes_nicely(self.number_of_bands(),self.maximum_level_energy())
        pylab.ion()

        # Sort the matrix element text strings for printing
        output_keys = matrix_element_printing_dict.keys()
        output_keys.sort()
        matrix_element_list = []

        # Add a header line.
        matrix_element_list.append("Matrix element".ljust(90) + "   Diagonal errors (%)" + "   Correlated errors (%)" + "    Lower limit" + "  Upper limit")

        for one_key in output_keys:
            this_line = matrix_element_printing_dict[one_key]
            matrix_element_list.append(this_line)

        matrix_element_list.extend(["","Fixed matrix elements are shown in black,",\
                                       "masters (variable in fits)      in green,",\
                                       "dependents (on a master)        in red.",\
                                       "",\
                                       "* indicates that a matrix element hit a limit in the last fit.",\
                                       "",\
                                       "To see which dependents are linked to which",\
                                       "masters, use the \"Examine setup\" button, option \"p\"."])

        # Display the list of matrix element values.  If popups aren't enabled,
        # then this will go to the terminal.
        title_string = multipole_text + " matrix elements from band " + str(initial_internal_band_number) +\
          " to band " + str(final_internal_band_number)
        create_dialog_popup({"text_lines":matrix_element_list,"title":title_string})


    def read_txt_level_scheme(self,txt_file_name):
        """Reads a level scheme in the Rachel format.

        Z   A                          # optional comment
        band_name spin parity energy   # optional comment
        band_name spin parity energy other_band_name yet_another_band_name  # optional comment
                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pseudonyms
        The pseudonyms are used to preserve references to the former names of
        merged bands.  The user should not type these into the level scheme
        file, but if she does, it will not cause problems.

        ...

        e.g.

        32 71                 # some nucleus
        ground 1.5 - 0.       
        ground 3.5 - 100.     # not so sure about this state
        side   2.5 + 250.   

        August 2011:  This format still needs to be modified so that a 5th,
        6th, etc.  non-comment field can contain other band names to create
        aliases for this level.

        where band_name may not contain whitespace, spin is a decimal number,
        parity is a space-delimited symbol, either "+" or "-" and energy is in
        keV.

        Z and A are integers.

        Comments can follow any properly constructed line, but should be
        preceded with a "#".

        """

        # Get the existing band names, so that the names of duplicate bands can
        # be modified.
        old_band_names = self.get_all_band_names()
        # A list for the new band names to add.
        new_band_names = []
        if len(old_band_names) == 0:
            first_level_scheme = True
        else:
            first_level_scheme = False
            
        print "Attempting to read file \"" + txt_file_name + "\"."
        print "testing"
        try:
            with open(txt_file_name,'r') as txt_file:
                txt_lines = txt_file.readlines()
        except:
            print "File \"" + txt_file_name + "\" not found, or file format is bad."
            print "Quitting."
            return -1
        print "File is ",len(txt_lines)," lines long"

        # Skip to first line with exactly two fields (other than comments).
        for line_counter in range(len(txt_lines)):
            this_line = txt_lines[line_counter]
            # Strip off any comments following at least one "#" symbol and
            # split the earlier part into fields.
            this_line_fields = this_line.split("#")[0].split()

            # Check that there are exactly 6 fields remaining after comments
            # have been removed.
            if len(this_line_fields) == 2:
                Z = int(this_line_fields[0])
                A = int(this_line_fields[1])
                break

        try:
            Z, A  # This will fail if no Z, A found
        except:
            print "Could not find Z, A at the top of the file.  Cancelled."
            return -1

        # Set the Z, A from this level scheme file.
        if self.get_value("Z") == None:
            print "Taking atomic number  Z = ",Z," from this file."
            self.Z = Z
        elif not Z == self.Z:
            print "Error: This file has a different Z value from the nucleus in memory!"
            print "Current atomic number Z = ",self.get_value("Z"),"."
            print "This level scheme file is for  Z = ",Z
            print "Quitting."
            return -1

        if self.get_value("A") == None:
            print "Taking mass number  A = ",A," from this file."
            self.A = A
        elif not A == self.A:
            print "Error: This file has a different A value from the nucleus in memory!"
            print "Current atomic number A = ",self.get_value("A"),"."
            print "This level scheme file is for  A = ",A
            print "Quitting."
            return -1

        # For reporting the number of levels read to the user.
        levels_read = 0

        # Read the levels to the end of the file.
        for this_line in txt_lines[line_counter+1:]:
            skip_line = False
            # Strip comments and split the first part before comments into fields.
            this_line_fields = this_line.split("#")[0].split()
            # Skip the line unless it has the right number of fields.
            if len(this_line_fields) >= 4:
                # there are at least 4 fields.  Any after the 4th must define pseudonyms
                this_band_name = this_line_fields[0]
                while this_band_name in old_band_names:
                    this_band_name = this_band_name + "x"
                this_spin      = round(float(this_line_fields[1]),1)
                # Check that the parity field is only "+" or "-".
                if this_line_fields[2] == "+":
                    this_parity = 1
                elif this_line_fields[2] == "-":
                    this_parity = -1
                else:
                    print "Skipping line ",this_line[:20],"... because the parity is not understood."
                    skip_line = True
                this_energy = float(this_line_fields[3])

                # Add this to the level scheme if there were no "skip_line" flags.
                if not skip_line:
                    # If this band name has not yet been encountered in the file, 
                    # add this band name and number to the dict and add new band information.
                    while this_band_name in old_band_names:
                        # Add an "x" repeatedly to the end of the band name to make it unique.
                        this_band_name = this_band_name + "x"
                    # Add this new band name to the list of primary band names.  Alias band names do not go in here.
                    if not this_band_name in new_band_names:
                        new_band_names.append(this_band_name)
                        print "Added new band \"",this_band_name,"\"."

                    this_level_band_names = [this_band_name]
                    # Check for pseudonyms.
                    if len(this_line_fields) > 4:
                        # Parse the band name pseudonyms.
                        for pseudonym in this_line_fields[4:]:
                            corrected_pseudonym = pseudonym.strip()
                            this_level_band_names.append(corrected_pseudonym)
                        
                    # Now update the level data with the new level. 
                    # The call to def add_a_level can take a list of strings in
                    # the band_names field to add aliases on creation of the
                    # level.

                    #self.add_a_level(band_names = this_band_name, spin = this_spin, parity = this_parity, energy = this_energy)
                    self.add_a_level(band_names = this_level_band_names, spin = this_spin, parity = this_parity, energy = this_energy)

                        
                    levels_read = levels_read + 1
                    print "Added ",this_spin,this_parity," level at ",this_energy,"keV to band ",this_band_name,"."
            else:
                if not len(this_line_fields) == 0:
                    print "Skipping line ",this_line[:20],"... because it is not formatted correctly."

        # Now store the band names permanently.  The names as stored
        # permanently are indexed by number, not name--the opposite of the
        # temporary dictionary used in the present def.

        # Call the method to add the new band names to the display and the
        # order for Gosia.
        self.add_bands(new_band_names) 

        # Guess all K values.  (This eliminates the need to type them into the file.)
        self.guess_all_k_values()


        print "Read ",len(new_band_names)," bands."
        print "Read ",levels_read," levels."
        print "Be sure to delete any duplicate bands that may exist!"
        print "Done."

        self.set_default_normalization_transition()

        return 0


    def read_ags_file_level_scheme(self,nameofagsfile=""):
        """This reads a standard Radware ags level scheme (not gls!).
        
        July 14 2011: This is being changed to a new method to read levels into
        the new level class.

        This does not read yield data.  See the methods in the "detector"
        class; yields are stored in the associated detectors.

        """

        def print_debug_file_lines():
            print "Cannot parse ags file line #" + str(linenumber + 1) + "."
            print "Could be missing fields, such as spin or parity, or"
            print "multiple spin assignments."
            print "Lines: "
            for debug_line_number in range(linenumber - 3, linenumber + 3):
                if debug_line_number == linenumber:
                    print " --->",
                print "     " + agsfilelines[debug_line_number]
            to_skip = yes_no_prompt("You can skip this level, or quit loading.\nSkip [Y/n]? ",True)
            print "YOU MUST FIX THE AGS FILE IF YOU ARE GOING TO READ EXPERIMENTAL YIELD DATA FROM IT."
            return to_skip

        # Get the existing band names, so that the names of duplicate bands can
        # be modified.
        old_band_names = self.get_all_band_names()
        # A list for the new band names to add.
        new_band_names = []
        if len(old_band_names) == 0:
            first_level_scheme = True
        else:
            first_level_scheme = False
            
        # Define the list of ags text lines.
        agsfilelines=[] # The whole ags file is read into here, and then it can
                        # be parsed later as desired.

        print "Attempting to read file \"" + nameofagsfile + "\"."
        try:
            with open(nameofagsfile,'r') as agsfile:
                agsfilelines.extend(agsfile.readlines())
        except:
            print "File \"" + nameofagsfile + "\" not found, or file format is bad."
            print "Quitting."
            return -1

        # File is now read (and closed because of "with").
        print "AGS file is ",len(agsfilelines)," lines long."

        # Check the 6th line of the file to make sure it contains AGS version
        # info.  If not, the file structure is not understood.
        if len(agsfilelines) > 5:
            templist = agsfilelines[5].lower().partition("version")
            if templist[0] == " ascii gls file format ":
                agsversion=float(templist[2])
                print "The file is Radware AGS version ",agsversion
            else:
                print "Incorrect file format.  A Radware AGS file was expected."
                return -1
        else:
            print "Incorrect file format.  A Radware AGS file was expected."
            return -1

        # Get various things from the file: the Z of the nucleus, the numbers
        # of levels and bands.  I am using temporary variables in this method
        # that begin with an underscore, but I have now abandoned this style.
        # These _xxxx variables will be renamed.
        linenumber = 1 + findinlist(agsfilelines,["Z","Nlevels","Ngammas","Nbands"])
        # Set the Z and A numbers only if they haven't already been set.
        new_Z = int(agsfilelines[linenumber].split()[0])
        if self.get_value("Z") == None:
            self.set_value("Z",new_Z)
        elif not self.get_value("Z") == new_Z:
            print "Error: This file has a different Z value from the nucleus in memory!"
            print "Current atomic number Z = ",self.get_value("Z"),"."
            print "This AGS file is for  Z = ",new_Z
            print "Quitting."
            return -1

        nlevels = int(agsfilelines[linenumber].split()[1])
        print nlevels," levels to be read."
        number_of_bands = int(agsfilelines[linenumber].split()[3])
        print number_of_bands," bands in level scheme."

        # 3.  READ ALL OF THE LEVELS AND ADD THEM.
        # See the add_a_level method and the add_level_pseudonym method.
        # Assign band names to the bands.  

        # 1.  Read the band names.
        # A temporary dictionary to map the ags file band numbers to the names.
        # Band names may be modified to make them unique.
        new_level_scheme_band_name_dictionary = {}

        linenumber = 1 + findinlist(agsfilelines,["Band","Name","X0"])
        # A temporary dictionary to store band names and their numbers in the ags file.
        for i in range(number_of_bands):
            this_line = linenumber + i
            textline = agsfilelines[this_line]
            temp_name = textline[6:14]
            temp_band_number = int(textline[:5])
            band_name = string.join(temp_name.split(),"")   # Strip all spaces so that the branching data file is easy to read.
            while band_name in old_band_names or band_name in new_band_names:
                # Add an "x" repeatedly to the end of the band name to make it unique.
                band_name = band_name + "x"
            # Add this to the temporary list of band names, so that uniqueness
            # of names can be checked for every new band.
            new_band_names.append(band_name)
            # Add the ags file band number pointing to the corresponding band name.
            new_level_scheme_band_name_dictionary[temp_band_number] = band_name

        # Find the first level entry and read all levels, creating the level
        # object for each.
        linenumber = 1 + findinlist(agsfilelines,["++","LabelDX","LabelDY"])


        for i in range(nlevels):
            try:
                ags_level_number = int(agsfilelines[linenumber].split()[0])  # Added reading of radware level number.
                level_energy     = float(agsfilelines[linenumber].split()[1])
                ags_band_number  = int(agsfilelines[linenumber].split()[5])  
                band_name        = new_level_scheme_band_name_dictionary[ags_band_number]
            except:
                to_skip = print_debug_file_lines()
                # If the user wants to skip this level, continue to the next iteration of the loop.
                # Otherwise, exit with an error.
                if to_skip:
                    print "Skipping this level."
                    linenumber = linenumber + 2
                    continue
                else:
                    print "Quitting."
                    return 0

            # To get parity, test the "-" or "+" symbol, then set to +/-1
            try:
                if "-" in agsfilelines[linenumber].split()[3]:
                    parity = -1 # Put negative parity in the band parity dict.
                else:
                    parity = 1
            except:
                to_skip = print_debug_file_lines()
                # If the user wants to skip this level, continue to the next iteration of the loop.
                # Otherwise, exit with an error.
                if to_skip:
                    print "Skipping this level."
                    linenumber = linenumber + 2
                    continue
                else:
                    print "Quitting."
                    return 0

            # To parse the spin, first we need to test whether it's integer or
            # half integer.  Note that in Python rounded floats can be tested
            # for equivalence to another rounded float.
            # Note that in Radford's ags file library, he sometimes puts the
            # parity symbol on the left, sometimes on the right, hence .strip
            # instead of .rstrip
            try: 
                spintext = agsfilelines[linenumber].split()[3].strip('+-')  # Strip pluses and minuses from the spin text
                if "/" in spintext:  # half-integer spin
                    fractionformspin = spintext.partition('/')
                    spin = round(float(fractionformspin[0]) / float(fractionformspin[2]),1)
                else:
                    spin = round(float(spintext),1)
            except:
                to_skip = print_debug_file_lines()
                # If the user wants to skip this level, continue to the next iteration of the loop.
                # Otherwise, exit with an error.
                if to_skip:
                    print "Skipping this level."
                    linenumber = linenumber + 2
                    continue
                else:
                    print "Quitting."
                    return 0

            # Now update the level data with the new level.  This has been
            # updated with the extra field for ags level number.
            self.add_a_level(band_names = band_name, spin = spin, parity = parity, energy = level_energy)
            # Now update the level data with the new level.  This has been

            linenumber = linenumber + 2

        print i+1," levels read."

        # Ask the user for the atomic mass, which is needed later for stopping
        # power calculations, etc.
        if self.get_value("A") == None:
            while True:
                A = prompt_number("Atomic mass number A = ","i")
                if not A == "quit":
                    break
            self.set_value("A",A)
        else:
            print "Keeping original mass number A = ",self.get_value("A"),"."

        # Call the method to add the new band names to the display and the
        # order for Gosia.
        self.add_bands(new_band_names) 

        # Since K is generally not given in the AGS files, we will not try to
        # get K from the AGS file all K values (for unknown new bands)
        self.guess_all_k_values()

        self.set_default_normalization_transition()

        print "Done."
        return 0


    def guess_all_k_values(self):
        """Guess K values for all states that don't have K values yet.

        July 14 2011: K values are stored in the levels now, not in a band
        dictionary.

        """

        temporary_band_K_dictionary = {}  # {"name1":K,"name2":K...}

        # Loop through all levels, assigning K values to a dictionary of
        # name:K.  This will assume that the K value is the lowest spin value
        # in each band.
        for one_level_key in self.levels:
            this_band_name, this_spin = one_level_key
            # If this band is not in the temporary K dictionary, add it with a
            # starting K value.  Otherwise, update the K value if a lower spin
            # was found.
            if not this_band_name in temporary_band_K_dictionary.keys():
                # If the level has not already been given a K value.
                temporary_band_K_dictionary[this_band_name] = this_spin
            elif this_spin < temporary_band_K_dictionary[this_band_name]:
                # If the spin of this level is less than the current K
                # value.
                temporary_band_K_dictionary[this_band_name] = this_spin
                
        # Now go through all levels that did not already have a K value, and
        # change their K values to the guesses from above.
        for one_level_key in self.levels:
            this_band_name, this_spin = one_level_key
            current_K_of_this_level = self.levels[one_level_key].get_K()
            if current_K_of_this_level == None:
                guessed_K_value = temporary_band_K_dictionary[this_band_name]
                self.levels[one_level_key].set_K(guessed_K_value)

        print "Guessed K values for all new bands.  They can be changed later."
        return 0
            
    def askallkvalues(self):
        """Ask the user for a K value for each band.  
        
        Eventually need checks that they make physical sense.

        Default values can be guessed from existing levels, but the graphical
        display will make this easy.  An assignment of all K values could be a
        True/False flag set globally.  The GUI could disallow matrix element
        calculations unless this is done...
        """

        if not self.number_of_bands() == len(self.bandk):  # if all bands are not assigned a K value
            print "Enter K values for the following bands.\nYou can change this later."
            bandsofknownk = set(self.bandk.keys())
            allbands = set(temp[0] for temp in self.levels)
            # Only ask for allbands - bandsofknownk  (set arithmetic)
            bandstoaskfork = allbands - bandsofknownk
            for bandnumber in bandstoaskfork:
                kvalue = prompt_number("Band " + str(bandnumber) + ": ","r")
                if kvalue == "quit":
                    return 0
                else:
                    kvalue = abs(kvalue)

                self.bandk[bandnumber] = kvalue
            

    def number_of_matrix_elements(self):
        """Returns the total number of matrix elements.

        """
        return len(self.matrix_data)

    def indexmatrixelement(self,multipolenumber,li,lf):
        """Finds the position in the matrix element list if the matrix element exists.
        
        If it does not exist, returns -1 (integer).  Takes a number (the gosia code
        number) for multipole.
        """

        for i in range(self.number_of_matrix_elements()):
            # If the list [multi,li,lf] matches, then return the index requested.
            if [self.matrix_data[i][0],self.matrix_data[i][1],self.matrix_data[i][2]] == \
              [multipolenumber,li,lf]:
                return i
        # If it was not found and returned, give the code -1 ("doesn't exist").
        return -1


    def filter_me(self):
        """Delete matrix elements matching the Python boolean tests.

        Step through all matrix elements.  Delete matrix elements that meet
        all of the selection criteria in rules_list, e.g.
              fi > ii               (final spin greater than initial spin)
              ib == 1               (initial band is 1)
              fb == 2 or fb == 3    (final band is 2 or 3)
              ml == 7               (multipolarity is M1)
              
        """

        print "Enter rules to select the matrix elements to be DELETED."

        # Get a list of rules to select matrix elements
        rules_list = self.get_matrix_element_selection_rules()

        # A dict for sorting the deleted matrix elements.
        matrix_element_printing_dict = {}  # [(initial_band_number, initial_spin, final_band_number, final_spin)] = formatted_text

        # Step through all matrix elements and delete the selected ones.
        for matrix_key in self.matrix_data.keys():
            # Extract all of the variables that might be referenced in the rules_list.
            # Test each rule (condition).  If all conditions are met for this matrix element,
            # couple this one to the master.  This "rules" method may be a minor nuisance to
            # the user, so maybe a "define quick dependency" button should also be included.
            # This is a good proof of principle for a method to selectively add or delete
            # matrix elements from set by writing rules in simple math, e.g.
            #   fi > ii               (final spin greater than initial spin)
            #   ib == 1               (initial band is 1)
            #   fb == 2 or fb == 3    (final band is 2 or 3)
            #   ml == 7               (multipolarity is M1)
            #   mt == "E2"            (multipolarity is E2)

            matrix_element_object = self.matrix_data[matrix_key]

            # Get the variables that index the matrix element.
            multipole_code, initial_band_name, initial_spin, final_band_name, final_spin = matrix_key
            # Get the multipole_text string.
            multipole_text = REVERSE_MULTIPOLE[multipole_code]
            # The band numbers as displayed on the level scheme diagram.
            initial_band_number = self.get_band_number_for_display(initial_band_name)
            final_band_number   = self.get_band_number_for_display(final_band_name)
            # Get the level keys to check, for example, whether the matrix_element is a static moment.
            initial_level_key = (initial_band_name,initial_spin)
            final_level_key   = (final_band_name,final_spin)
            current_value     = matrix_element_object.get_current_value()

            # Convert to simple two-character names, so the user can write simple
            # rules without long variable names.
            me = current_value   # The current value of the matrix element
            ml = multipole_code
            mt = multipole_text  # requires the user to type quotes--ml is easier.
            # Get the values of ii, bi, if, bf
            # (initial spin, initial band, final spin, final band)
            ii = initial_spin
            fi = final_spin
            ib = initial_band_number
            fb = final_band_number
            
            # Now run through all conditions to see if this matrix element meets the user's conditions.
            selected = True
            for condition in rules_list:
                try:
                    eval(condition)
                except:
                    print "The rule \"",condition,"\" is invalid."
                    print "Check the allowed variables and syntax, and try again."
                    print "Note that the equality operator is \"==\", not \"=\"."
                    print "Quitting."
                    return -1
                if not eval(condition):
                    # The matrix element does not meet one of the conditions
                    selected = False
                    break              # break out of the for loop

            # Fix or set this matrix element as a master, as requested by the user.
            if selected:
                formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                  final_band_name = final_band_name, final_spin = final_spin, multipole_text = multipole_text, \
                  value = current_value)
                matrix_element_printing_dict[(initial_band_number, initial_spin, final_band_number, final_spin)] = formatted_text
                del self.matrix_data[matrix_key]

        # Sort the deleted matrix element descriptions and print them.
        deleted_keys = matrix_element_printing_dict.keys()
        deleted_keys.sort()
        print "Deleted matrix elements: "
        print "------------------------------------------------------------"
        for one_key in deleted_keys:
            print matrix_element_printing_dict[one_key]
        number_removed = len(matrix_element_printing_dict)
        print "Removed ",number_removed," matrix elements."

        block_print_with_line_breaks("You should write the Gosia yld file again after you are finished updating the matrix, before running a gosia \"Make corrected yields\" or \"Fit\" operation.\nIf you want to plot yields,  run \"Integrate yields\" again after you are finished updating the matrix.")

        # Update the major couplings again, in case some band-->band couplings
        # have been entirely removed.
        self.update_major_couplings()
        # Redraw the level scheme.
        self.draw_level_scheme()

        return 0  # no error testing for now

    def deletematrixelement(self,multipolenumber,li,lf):
        """Tests a matrix element for existence and deletes it if it is found.

        deletematrixelement(multipolenumber,li,lf)

        The matrix element is identified by its multipole number and initial
        and final level numbers (internal numbering system) li and lf.

        Returns 0 if the matrix element was successfully deleted;
               -2 if it didn't exist in the first place
        """
        
        i = self.indexmatrixelement(multipolenumber,li,lf)            # index of the one to be removed
        if i > -1:  # if it exists
            # Note: "try" would not work here!  del a[-1] deletes the first from the right end!
            del self.matrix_data[i]
            return 0
        else:
            return -2  # Note that this is not supposed to be an error. 
                       # It means the matrix element didn't exist.
                       # deletematrixelement can be used to delete one "if" it exists.


    def spin_parity_allowed_transition(self,multipole_text,initial_state,final_state):
        """This will return true if the matrix element is allowed; false otherwise.
        
        multipole_text   is a string, e.g. "e2", "M1"
        initial_state    is a state key, e.g. ("gsb",0.0)
        final_state      is a state key, e.g. ("gam",2.0)

        Here, multipole is the gosia code number (see manual section "ME").

        Conditions for True:
        Initial and final levels must exist.
        Parity must be conserved.
        Angular momentum must be conserved (I-selection with photon).
        
        K does *not* need to be conserved in this test.
        """

        # Capitalize the multipole text.
        multipole_text = multipole_text.upper()

        l = MULTIPOLE_LAMBDA[multipole_text] # lambda
        initial_spin = initial_state[1]
        final_spin   = final_state[1]
        absolute_delta_i = abs(final_spin - initial_spin)
        if absolute_delta_i - l - ASMIDGE > 0.0:
            # can't couple the photon (spin conservation)
            return False

        #  Check for parity conservation  
        initial_parity = self.levels[initial_state].get_parity()
        final_parity   = self.levels[final_state].get_parity()

        if initial_parity == final_parity:
            parity_change = False
        else:
            parity_change = True

        # Check the multipole E or M.  multipole_text has been capitalized.
        if multipole_text[0] == 'E': # electric
            if (l in [1,3,5] and not parity_change) or (l in [2,4,6] and parity_change):
                # parity not conserved!
                return False
        elif (l == 1 and parity_change) or (l == 2 and not parity_change): # magnetic
            # parity not conserved!
            return False

        return True  # if no problems above, then it is allowed
    
    
    def add_matrix_element(self,multipole_string = None, initial_band_name = None, \
        final_band_name = None, initial_spin = None, final_spin = None, value = None):
        """Add one fixed matrix element to the matrix.

        Master or dependent information cannot be set here.  That information
        can be set in another method under construction.

        multipole_string is one of 
          'e1','e2','e3','e4','e5','e6','m1','m2'  or 
          'E1','E2','E3','E4','E5','E6','M1','M2'

        The matrix element will be added if there appears to be room in Gosia's
        memory.  This check is not very accurate; Gosia's free memory will
        depend on the quantity of other setup data in its memory.  The GUI will
        handle at least as many matrix elements as Gosia if
        MAXIMUM_NUMBER_OF_MATRIX_ELEMENTS is set to 999.

        """

        # Check that all quantities have been passed.  This should eventually
        # check the validity of all quantities, but since this is an internal
        # method, the check is not vital.
        if None in [multipole_string, initial_band_name, final_band_name, initial_spin, final_spin, value]:
            print  "In add_matrix_element, one or more required fields are missing."
            return "In add_matrix_element, one or more required fields are missing."

        # If the gosia multipole code can be determined, then this is a valid multipole.
        try:
            multipole_number = MULTIPOLE[multipole_string]
        except:
            print  "In add_matrix_element, the multipole text string is invalid."
            return "In add_matrix_element, the multipole text string is invalid."

        # If the matrix element exists then this will overwrite it automatically.
        # If there is still room (in gosia) for more matrix elements,
        if self.number_of_matrix_elements() < MAXIMUM_NUMBER_OF_MATRIX_ELEMENTS:
            self.matrix_data[(multipole_number, initial_band_name, initial_spin, final_band_name, final_spin)] = matrix_element(current_value = value)
        else:
            print  "Maximum of ",MAXIMUM_NUMBER_OF_MATRIX_ELEMENTS," matrix elements reached."
            return "Maximum of ",MAXIMUM_NUMBER_OF_MATRIX_ELEMENTS," matrix elements reached."

                
    def add_complete_matrix(self):
        """Prompts the user for EM parameters and adds all K-allowed matrix elements.

        This currently will add all E2, M1, E3 and E1 matrix elements that are
        K-allowed.

        """

        # First, see if there are + and - parity states in the level scheme.
        # If not, then the E1, E3 prompts can be skipped.
        set_of_parities = set([])
        for level_key in self.levels.keys():
            # Get the parity of this state, and save it to a set.
            parity = self.levels[level_key].get_parity()
            set_of_parities.add(parity)
        # See if there are two or only one parity in the level scheme.
        if len(set_of_parities) == 2:
            even_and_odd_parity_states = True
        else:
            even_and_odd_parity_states = False

        quadrupole_moment = prompt_number("Enter an intrinsic quadrupole moment (sqrt(5/(16pi))eQo) for all in-band transitions [eb]: ","f")
        if quadrupole_moment == "quit":
            return 0

        gk_gr = prompt_number("Enter an M1 moment <K|M1|K> for all in-band transitions [n.m.]: ","f")
        if gk_gr == "quit":
            return 0

        e2_interband_moment = prompt_number("Enter an E2 moment <Kf|E2|Ki> for all interband transitions [eb]: ","f")
        if e2_interband_moment == "quit":
            return 0

        m1_interband_moment = prompt_number("Enter an M1 moment <Kf|M1|Ki> for all interband transitions [n.m.]: ","f")
        if m1_interband_moment == "quit":
            return 0

        # Only if there are different-parity states in the level scheme, ask
        # for E1 and E3 parameters.
        if even_and_odd_parity_states:
            print "This level scheme contains even- and odd-parity states."
            e3_interband_moment = prompt_number("Enter an E3 moment <Kf|E3|Ki> for all interband transitions [eb^(3/2)]: ","f")
            if e3_interband_moment == "quit":
                return 0
            e1_interband_moment = prompt_number("Enter an E1 moment <Kf|E1|Ki> for all interband transitions [eb^(1/2)]: ","f")
            if e1_interband_moment == "quit":
                return 0
        else:
            print "This level scheme does not contain even- and odd-parity states."

        # Get all primary band names.
        all_band_names = self.get_all_band_names_in_order(include_inactive_bands = True)

        # Define parameters for the add-matrix-element methods for the
        # multipoles in use.
        e2_in_band_parameter_dict = {"Q":quadrupole_moment,"low_spin_limit":None,"high_spin_limit":None}
        e2_interband_parameter_dict = {"intrinsic":e2_interband_moment,"signature_term":0.0}
        m1_in_band_parameter_dict = {"gkgr":gk_gr,"gr":0.0,"b":0.0,"low_spin_limit":None,"high_spin_limit":None}
        m1_interband_parameter_dict = {"intrinsic":m1_interband_moment,"signature_term":0.0}
        if even_and_odd_parity_states:
            e1_parameter_dict = {"intrinsic":e1_interband_moment,"signature_term":0.0}
            e3_parameter_dict = {"intrinsic":e3_interband_moment,"signature_term":0.0}

        # Get the number of bands in the level scheme.
        number_of_bands = self.number_of_bands(include_inactive_levels = False)
        # Active/inactive bands have not yet been implemented.

        # Cycle through all primary band names, adding matrix elements in the
        # "upper triangle" only.
        # We need to cycle through user (display) band numbers 1--n, not 0--n for the add-matrix methods.
        for initial_band_number in range(1,number_of_bands+1):
            for final_band_number in range(initial_band_number,number_of_bands+1):
                # If the initial band is the final band, then call methods to add in-band matrix elements.
                if initial_band_number == final_band_number:
                    # Add E2 matrix elements in-band.
                    print "Adding E2 matrix elements in band " + str(initial_band_number)
                    self.add_in_band("E2",initial_band_number,e2_in_band_parameter_dict)
                    # Add M1 matrix elements if possible.
                    print "Adding M1 matrix elements in band " + str(initial_band_number)
                    self.add_in_band("M1",initial_band_number,m1_in_band_parameter_dict)
                else:
                    # The initial and final bands are different.  
                    # Get the parities of the initial and final bands.
                    level_keys_in_initial_band = self.get_all_level_keys_in_band_name(all_band_names[initial_band_number-1])  # uses internal numbering
                    level_keys_in_final_band   = self.get_all_level_keys_in_band_name(all_band_names[final_band_number-1])    # uses internal numbering
                    # Checking only the band heads for parity.  Mixed parity in-band is not allowed.
                    initial_band_parity = self.levels[level_keys_in_initial_band[0]].get_parity()
                    final_band_parity   = self.levels[level_keys_in_final_band[0]].get_parity()
                    # If the initial band and final band have the same parity,
                    # add e2 and m1 matrix elements; otherwise add e1 and e3
                    # matrix elements.
                    if initial_band_parity == final_band_parity:
                        print "Adding E2 matrix elements from band " + str(initial_band_number) + " to band " + str(final_band_number)
                        self.add_alaga("e2",initial_band_number,final_band_number,None,None,e2_interband_parameter_dict)
                        print "Adding M1 matrix elements from band " + str(initial_band_number) + " to band " + str(final_band_number)
                        self.add_alaga("m1",initial_band_number,final_band_number,None,None,m1_interband_parameter_dict)
                    else:
                        print "Adding E1 matrix elements from band " + str(initial_band_number) + " to band " + str(final_band_number)
                        self.add_alaga("e1",initial_band_number,final_band_number,None,None,e1_parameter_dict)
                        print "Adding E3 matrix elements from band " + str(initial_band_number) + " to band " + str(final_band_number)
                        self.add_alaga("e3",initial_band_number,final_band_number,None,None,e3_parameter_dict)
                        
        return 0


    def add_inter_band(self,multipoletext,bandnumber1,bandnumber2,rule,low_spin_limit=None,high_spin_limit=None):
        """Add a set of interband matrix elements from one band to another

        Must go from low-numbered band to high-numbered band.  The order is
        reversed if necessary in this module.  

        Rule is one of alaga, mikhailov, etc.

        To avoid time-consuming, unnecessary re-sorting, I am relying on
        modules that add, delete, or rearrange levels and bands to call the
        sorting module afterward.  No sorting is done here.
        """

        # Add a description of what was done for the logs.
        full_description = "Added or changed interband matrix elements "

        multipoletext = multipoletext.upper() # change to upper case

        if not multipoletext in MULTIPOLE_LAMBDA.keys():  # e1--e6,m1,m2
            print "add_inter_band error: invalid multipole"
            return "add_inter_band error: invalid multipole"
        elif bandnumber1 == bandnumber2:
            print "add_inter_band error: initial and final bands must be different"
            return "add_inter_band error: initial and final bands must be different"

        #  Make sure that the matrix elements are coupled from low band to high
        #  band, so that phases are consistent in Gosia input.
        if bandnumber1 > bandnumber2:
            temp = bandnumber2
            bandnumber2 = bandnumber1
            bandnumber1 = temp
            print "Reversing the band numbers for a consistent phase convention."
            print "Add the matrix elements from band ", bandnumber1, " to band ", bandnumber2, "."
            
        try:
            initial_band_name = self.get_primary_band_name_from_band_number(bandnumber1)
        except:
            print "add_inter_band error: initial band number is invalid."

        try:
            final_band_name = self.get_primary_band_name_from_band_number(bandnumber2)
        except:
            print "add_inter_band error: final band number is invalid."

        full_description += " band " + initial_band_name + " --" + multipoletext + "--> " + final_band_name + ", "
        full_description += rule 
        investigated_nucleus.notes.append_log("procedure_log",full_description)

        if rule == 'alaga':
            errcode = self.add_alaga(multipoletext, bandnumber1, bandnumber2, low_spin_limit, high_spin_limit)
            if errcode == 0:
                self.draw_level_scheme()
                return 0
            else:
                print errcode
                return -1
        elif rule == 'kforbidden':
            errcode = self.add_k_forbidden(multipoletext,bandnumber1,bandnumber2,low_spin_limit,high_spin_limit)
            if errcode == 0:
                self.draw_level_scheme()
                return 0
            else:
                print errcode
                return -1
        elif rule == 'mikhailov':
            errcode = self.add_mikhailov(multipoletext,bandnumber1,bandnumber2,low_spin_limit,high_spin_limit)
            if errcode == 0:
                self.draw_level_scheme()
                return 0
            else:
                print errcode
                return -1
        else:
            print "add_inter_band : rule not implemented yet"
            return "add_inter_band : rule not implemented yet"


    def add_in_band(self,multipole_text,band_number,parameter_dict):
        """Adds a set of in-band matrix elements to a band.

        Only allow E2, M1 for in-band matrix elements.

        add_in_band(multipole_text,bandnumber,parameter_dict)

        multipole_text is a string, 'e2', or 'E2' or 'm1' or 'M1', (E4 or E6 also)

        Here, the levels must be coupled from lower to higher spin.  When the 
        levels are written out, they must be sorted from low- to high-spin, as
        in the latest getgoing version.

        parameter_dict contains the electromagnetic terms "Q"  (really math.sqrt(5./(16.*math.pi))eQ0)
                                                          "gkgr"
                                                          "gr"
                                                          "b"

        
        """

        # Add a description of what was done for the logs.
        full_description = ""

        # A counter for non-zero matrix elements added.  (Matrix elements that are identically zero are skipped.)
        matrix_element_counter = 0

        # Get the band name from the band number.
        band_name = self.get_primary_band_name_from_band_number(band_number)

        multipole_number = MULTIPOLE[multipole_text]
        multipole_text = multipole_text.upper()

        if not multipole_text in ['E2','M1','E4','E6']:
            print "You can only add inband matrix elements that conserve parity."
            return -1

        # Get l = lambda.
        l = MULTIPOLE_LAMBDA[multipole_text] # lambda number (e.g. 2, not "E2")

        # Check the band name to see if it is in the known bands.
        all_band_names = self.get_all_band_names_in_order(include_inactive_bands = True)
        if not band_name in all_band_names:
            print "Band name not found in add_in_band."
            return -1
        
        # Get all the level keys sorted by band name, then spin.    This is
        # important to prevent adding a matrix element <b||E2||a> and a second
        # one <a||E2||b>.
        all_level_keys = self.get_sorted_unique_level_keys()

        # July 2011: Instead of checking the K value of the band, we will check
        # the K value of each level, so that different K values can be assigned
        # to each state.

        # Get the spin limits between which the user wants to add matrix elements
        low_spin_limit = parameter_dict["low_spin_limit"]
        high_spin_limit = parameter_dict["high_spin_limit"]

        for i in range(self.number_of_levels()):
            initial_level_key       = all_level_keys[i]
            initial_level_object    = self.levels[initial_level_key]
            initial_band_name = initial_level_key[0]
            initial_spin      = initial_level_key[1]
            initial_K         = initial_level_object.get_K()
            for j in range(i,self.number_of_levels()):  # Consider i==j for static moments.
                final_level_key = all_level_keys[j]
                final_level_object = self.levels[final_level_key]
                final_band_name = final_level_key[0]
                final_spin      = final_level_key[1]
                final_K         = final_level_object.get_K()
                K_warning = False  # Don't give a warning about different K numbers unless this flag is set to True.
                if initial_band_name == band_name and final_band_name == band_name:    # It is in-band.
                    # Two states in the band have been found.
                    if not final_K == initial_K and abs(initial_spin - final_spin) <= l:
                        print "Warning:  State ",initial_level_key," has K = ",initial_K,", and state ",final_level_key," has K = ",final_K
                        print "  Be sure that you want different K values in one band."
                        K_warning = True
                        
                    if self.spin_parity_allowed_transition(multipole_text,initial_level_key,final_level_key):  # If this is spin-parity allowed
                        # The Clebsch-Gordan coupling is now made more general for a possible K change in the band!
                        coupling = ned(initial_spin,l,final_spin,initial_K,final_K - initial_K,final_K)
                        if multipole_text == 'M1':
                            gkgr = parameter_dict["gkgr"]
                            if "b" in parameter_dict.keys():
                                b = parameter_dict["b"]
                            else:
                                b = 0
                            if "gr" in parameter_dict.keys():
                                gr = parameter_dict["gr"]
                            else:
                                gr = 0

                            m1factors = math.sqrt(2.*initial_spin+1.)*M1CONSTANT
                            # We will only add from low spin to high spin for a consistent phase convention.
                            if final_spin > initial_spin:  # If it is a transition matrix element...
                                # Then add the transition matrix element.
                                # (Since the matrix elements are sorted from
                                # low to high spin, if not spinj > spini then
                                # it's a static moment with spinj = spini.
                                if initial_K == 0.5 and final_K == 0.5:
                                    decoupling_clebsch = ned(initial_spin,1,final_spin,-0.5,1,0.5)
                                    decoupling_term = b*(-1)**(initial_spin + 0.5)*2.0**(-0.5)*decoupling_clebsch
                                    reduced_matrix_element = m1factors * (gkgr*(initial_K*coupling - decoupling_term) +\
                                      gr*math.sqrt(initial_spin*(initial_spin+1.))*kronecker(initial_spin,final_spin))
                                else: 
                                    reduced_matrix_element = m1factors * (gkgr*(initial_K*coupling) + \
                                      gr*math.sqrt(initial_spin*(initial_spin+1.))*kronecker(initial_spin,final_spin))
                                # Only add the matrix element if it is not identically 0 and the initial spin is within the spin limits, if limits were set.
                                if (not reduced_matrix_element == 0.0) and (low_spin_limit == None or high_spin_limit == None or\
                                  (initial_spin >= low_spin_limit and final_spin <= high_spin_limit)):
                                    self.add_matrix_element(multipole_string = multipole_text, initial_band_name = initial_band_name,\
                                      final_band_name = final_band_name,initial_spin = initial_spin, final_spin = final_spin,\
                                      value = reduced_matrix_element)
                                    if K_warning:
                                        comment = "**Initial K = " + str(initial_K) + ", final K = " + str(final_K)
                                        formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                                          final_band_name = final_band_name, final_spin = final_spin, multipole_text = multipole_text, \
                                          value = reduced_matrix_element, initial_K = initial_K, final_K = final_K, comment = comment)
                                    else:
                                        comment = ""
                                        formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                                          final_band_name = final_band_name, final_spin = final_spin, multipole_text = multipole_text, \
                                          value = reduced_matrix_element, comment = comment)
                                    print formatted_text
                                    # Increment the counter of matrix elements.
                                    matrix_element_counter += 1
                        else:  # Must be E2.
                            # We will only add from low spin to high spin (or static moments) for a consistent phase convention.
                            if final_spin >= initial_spin:  # We should be able to test equivalence for rounded floats (spins).
                                intrinsic = parameter_dict["Q"]  # really sqrt(5/(16pi))eQo
                                e2factors = math.sqrt(2.*initial_spin+1.)
                                reduced_matrix_element = e2factors * intrinsic * coupling
                                # Only add the matrix element if it is not identically 0.
                                if (not reduced_matrix_element == 0.0) and (low_spin_limit == None or high_spin_limit == None or\
                                  (initial_spin >= low_spin_limit and final_spin <= high_spin_limit)):
                                    self.add_matrix_element(multipole_string = multipole_text, initial_band_name = initial_band_name,\
                                      final_band_name = final_band_name,initial_spin = initial_spin, final_spin = final_spin,\
                                      value = reduced_matrix_element)
                                    if K_warning:
                                        comment = "**Initial K = " + str(initial_K) + ", final K = " + str(final_K)
                                        formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                                          final_band_name = final_band_name, final_spin = final_spin, multipole_text = multipole_text, \
                                          value = reduced_matrix_element, initial_K = initial_K, final_K = final_K, comment = comment)
                                    else:
                                        comment = ""
                                        formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                                          final_band_name = final_band_name, final_spin = final_spin, multipole_text = multipole_text, \
                                          value = reduced_matrix_element, comment = comment)
                                        comment = "**Initial K = " + str(initial_K) + ", final K = " + str(final_K)
                                    print formatted_text
                                    # Increment the counter of matrix elements.
                                    matrix_element_counter += 1

        print "Added ",matrix_element_counter," matrix elements."

        self.draw_level_scheme()

        # Log the changed matrix elements.
        full_description = "Added or changed in-band " + multipole_text + " matrix elements in band " + band_name
        investigated_nucleus.notes.append_log("procedure_log",full_description)
        return 0

    def add_mikh_silent(self,multipole_text,bandnumber1,bandnumber2,parameter_dict,low_spin_limit=None,high_spin_limit=None):
        """Adds mikhailov m.e. without prompts.  This is for future development of user accessors.

        See equation 4-98 in B&M II.  The sqrt(factorial) term is omitted here
        for K-allowed transitions.

        """

        # A counter for non-zero matrix elements added.  (Matrix elements that are identically zero are skipped.)
        matrix_element_counter = 0

        # Get the band name from the band number.  Band names have been checked in def add_inter_band.
        requested_initial_band_name = self.get_primary_band_name_from_band_number(bandnumber1)
        requested_final_band_name   = self.get_primary_band_name_from_band_number(bandnumber2)

        # Capitalize the multipole text "e2" --> "E2".
        multipole_text = multipole_text.upper()

        l = MULTIPOLE_LAMBDA[multipole_text]    # lambda


        M_1 = parameter_dict["M_1"]
        M_2 = parameter_dict["M_2"]
        if "M_3" in parameter_dict.keys():
            M_3 = parameter_dict["M_3"]
        else:
            M_3 = 0.0

        # Get all the level keys sorted by band name, then spin.    This is
        # important to prevent adding a matrix element <b||E2||a> and a second
        # one <a||E2||b>.
        all_level_keys = self.get_sorted_unique_level_keys()

        # July 2011: Instead of checking the K value of the band, we will check
        # the K value of each level, so that different K values can be assigned
        # to each state.

        for i in range(self.number_of_levels()):    
            initial_level_key       = all_level_keys[i]
            initial_level_object    = self.levels[initial_level_key]
            initial_band_name = initial_level_key[0]
            initial_spin      = initial_level_key[1]
            initial_K         = initial_level_object.get_K()
            for j in range(self.number_of_levels()):
                final_level_key = all_level_keys[j]
                final_level_object = self.levels[final_level_key]
                final_band_name = final_level_key[0]
                final_spin      = final_level_key[1]
                final_K         = final_level_object.get_K()
                if initial_band_name == requested_initial_band_name and final_band_name == requested_final_band_name:    # The initial and final bands of these states match.
                    # If this pair of levels belongs to the correct pair of
                    # bands, in correct order (bandnumber1 --> bandnumber2)
                    if self.spin_parity_allowed_transition(multipole_text,initial_level_key,final_level_key):
                        # Get the proper normalization from B&M II pg 60, eqn 4-98:
                        if initial_K == 0.0:
                            normalization = math.sqrt(2.)
                        else:
                            normalization = 1.0

                        # Here we use a Clebsch-Gordan term for K-allowed, slightly different from that of 4-98.
                        coupling = ned(initial_spin,l,final_spin,initial_K,final_K-initial_K,final_K) 
                        # Get the M_2 term in B&M 4-98.
                        M_2_term = M_2 * (final_spin*(final_spin + 1.0) - (initial_spin * (initial_spin + 1.0)))
                        # If the initial K value is 1/2, then add the M_3 term from B&M 4-98.
                        if initial_K == 0.5:
                            M_3_term = M_3 * (-1.)**(initial_spin + 0.5) * round((initial_spin + 0.5),1)
                        else:
                            M_3_term = 0.
                        reduced_matrix_element = normalization * math.sqrt(2.*initial_spin+1.) * coupling \
                          * (M_1 + M_2_term + M_3_term)

                        # Put the matrix element into the data.  Check that it is
                        # within requested spin limits, if spin limits were
                        # requested.
                        should_add_this_one = True
                        if not low_spin_limit == None:
                            if initial_spin < low_spin_limit:
                                should_add_this_one = False
                        if not high_spin_limit == None:
                            if initial_spin > high_spin_limit:
                                should_add_this_one = False

                        # Only put it in if it is not identically 0 and within
                        # initial spin limits if requested.
                        if not reduced_matrix_element == 0.0 and should_add_this_one:  
                            self.add_matrix_element(multipole_string = multipole_text, initial_band_name = initial_band_name,\
                              final_band_name = final_band_name,initial_spin = initial_spin, final_spin = final_spin,\
                              value = reduced_matrix_element)
                            # Print the matrix element added.
                            comment = "M_2 term = " + str(M_2_term) + ", M_3 term = " + str(M_3_term)
                            formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                              final_band_name = final_band_name, initial_K = initial_K, final_K = final_K, final_spin = final_spin, \
                              multipole_text = multipole_text, value = reduced_matrix_element, comment = comment) 
                            # print formatted_text
                            matrix_element_counter += 1

        # print "Added ",matrix_element_counter," matrix elements."
        # Don't need to redraw; the add_inter_band method does that.

        return 0   # No errors are returned at present.


    def add_mikhailov(self,multipole_text,bandnumber1,bandnumber2,low_spin_limit=None,high_spin_limit=None):
        """Adds interband matrix elements with a spin-dependent intrinsic matrix element.

        See equation 4-98 in B&M II.  The sqrt(factorial) term is omitted here
        for K-allowed transitions.

        """

        # A counter for non-zero matrix elements added.  (Matrix elements that are identically zero are skipped.)
        matrix_element_counter = 0

        # Get the band name from the band number.  Band names have been checked in def add_inter_band.
        requested_initial_band_name = self.get_primary_band_name_from_band_number(bandnumber1)
        requested_final_band_name   = self.get_primary_band_name_from_band_number(bandnumber2)

        # Capitalize the multipole text "e2" --> "E2".
        multipole_text = multipole_text.upper()

        l = MULTIPOLE_LAMBDA[multipole_text]    # lambda
        print "lambda = ",l

        print "Matrix elements assume the angular-momentum coupling\n",\
              "  of the Alaga rule, so only K-allowed transitions are\n",\
              "  handled.  The intrinsic matrix element is given a\n",\
              "  spin-dependence:\n",\
              "    <Kf|xx|Ki> = M_1 + M_2(I_f^2 - I_i^2) + ",\
              "       + M_3(-1)^(I_i + 1/2)*(I_i + 1/2)*kronecker_delta(K_i,1/2),\n",\
              "  where xx is one of E2, M1, etc., and\n",\
              "       I_f^2 = I_f(I_f + 1), I_i^2 = I_i(I_i + 1).\n",\
              "  See, e.g. Bohr and Mottelson, eqn 4-98.\n",\
              "  (Omit the spin-dependent factorial terms.)"

        M_1 = prompt_number("M_1 = ","f")
        if M_1 == "quit":
            return 0
        M_2 = prompt_number("M_2 = ","f")
        if M_2 == "quit":
            return 0

        block_print_with_line_breaks("\nIf the kronecker_delta(K_1,1/2) term (in Bohr & Mottelson equation 4-98) is needed, enter M_3 here.  Otherwise, enter zero.  (If the term does not apply, it will be ignored.)",70)
        M_3 = prompt_number("M_3 = ","f")
        if M_3 == "quit":
            return 0
        
        # Get all the level keys sorted by band name, then spin.    This is
        # important to prevent adding a matrix element <b||E2||a> and a second
        # one <a||E2||b>.
        all_level_keys = self.get_sorted_unique_level_keys()

        # July 2011: Instead of checking the K value of the band, we will check
        # the K value of each level, so that different K values can be assigned
        # to each state.

        print "\nCheck below for unintended changes in K.\n"

        for i in range(self.number_of_levels()):    
            initial_level_key       = all_level_keys[i]
            initial_level_object    = self.levels[initial_level_key]
            initial_band_name = initial_level_key[0]
            initial_spin      = initial_level_key[1]
            initial_K         = initial_level_object.get_K()
            for j in range(self.number_of_levels()):
                final_level_key = all_level_keys[j]
                final_level_object = self.levels[final_level_key]
                final_band_name = final_level_key[0]
                final_spin      = final_level_key[1]
                final_K         = final_level_object.get_K()
                if initial_band_name == requested_initial_band_name and final_band_name == requested_final_band_name:    # The initial and final bands of these states match.
                    # If this pair of levels belongs to the correct pair of
                    # bands, in correct order (bandnumber1 --> bandnumber2)
                    if self.spin_parity_allowed_transition(multipole_text,initial_level_key,final_level_key):
                        # Get the proper normalization from B&M II pg 60, eqn 4-98:
                        if initial_K == 0.0:
                            normalization = math.sqrt(2.)
                        else:
                            normalization = 1.0

                        # Here we use a Clebsch-Gordan term for K-allowed, slightly different from that of 4-98.
                        coupling = ned(initial_spin,l,final_spin,initial_K,final_K-initial_K,final_K) 
                        # Get the M_2 term in B&M 4-98.
                        M_2_term = M_2 * (final_spin*(final_spin + 1.0) - (initial_spin * (initial_spin + 1.0)))
                        # If the initial K value is 1/2, then add the M_3 term from B&M 4-98.
                        if initial_K == 0.5:
                            M_3_term = M_3 * (-1.)**(initial_spin + 0.5) * round((initial_spin + 0.5),1)
                        else:
                            M_3_term = 0.
                        reduced_matrix_element = normalization * math.sqrt(2.*initial_spin+1.) * coupling \
                          * (M_1 + M_2_term + M_3_term)

                        # Put the matrix element into the data.  Check that it is
                        # within requested spin limits, if spin limits were
                        # requested.
                        should_add_this_one = True
                        if not low_spin_limit == None:
                            if initial_spin < low_spin_limit:
                                should_add_this_one = False
                        if not high_spin_limit == None:
                            if initial_spin > high_spin_limit:
                                should_add_this_one = False

                        # Only put it in if it is not identically 0 and within
                        # initial spin limits if requested.
                        if not reduced_matrix_element == 0.0 and should_add_this_one:  
                            self.add_matrix_element(multipole_string = multipole_text, initial_band_name = initial_band_name,\
                              final_band_name = final_band_name,initial_spin = initial_spin, final_spin = final_spin,\
                              value = reduced_matrix_element)
                            # Print the matrix element added.
                            comment = "M_2 term = " + str(M_2_term) + ", M_3 term = " + str(M_3_term)
                            formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                              final_band_name = final_band_name, initial_K = initial_K, final_K = final_K, final_spin = final_spin, \
                              multipole_text = multipole_text, value = reduced_matrix_element, comment = comment) 
                            print formatted_text
                            matrix_element_counter += 1

        print "Added ",matrix_element_counter," matrix elements."
        # Don't need to redraw; the add_inter_band method does that.

        return 0   # No errors are returned at present.


    def add_kforb_silent(self,multipole_text,bandnumber1,bandnumber2,parameter_dict,low_spin_limit=None,high_spin_limit=None):
        """Adds K-forbidden matrix elements without prompts. For scripting development.

        See Bohr and Mottelson, vol. 2, equation 4-98.

        This is essentially the same as the add_mikhailov method, but it is
        left as a separate method, in case minor differences are added.

        """

        # A counter for non-zero matrix elements added.  (Matrix elements that are identically zero are skipped.)
        matrix_element_counter = 0

        # Get the band name from the band number.  Band names have been checked in def add_inter_band.
        requested_initial_band_name = self.get_primary_band_name_from_band_number(bandnumber1)
        requested_final_band_name   = self.get_primary_band_name_from_band_number(bandnumber2)

        # Capitalize the multipole text "e2" --> "E2".
        multipole_text = multipole_text.upper()

        l = MULTIPOLE_LAMBDA[multipole_text]    # lambda

        M_1 = parameter_dict["M_1"]
        M_2 = parameter_dict["M_2"]
        if "M_3" in parameter_dict.keys():
            M_3 = parameter_dict["M_3"]
        else:
            M_3 = 0.0

        # See if a maximum was requested.  

        if "maximum_bml_wu" in parameter_dict.keys():
            maximum_bml_wu = parameter_dict["maximum_bml_wu"]
            saturation_limit = True  
            maximum_bml = maximum_bml_wu * calc_wu(self.get_value("A"),multipole_text)  # Maximum B(ML) allowed in e,b,n.m.
        else:
            saturation_limit = False

        # Get all the level keys sorted by band name, then spin.    This is
        # important to prevent adding a matrix element <b||E2||a> and a second
        # one <a||E2||b>.
        all_level_keys = self.get_sorted_unique_level_keys()

        # July 2011: Instead of checking the K value of the band, we will check
        # the K value of each level, so that different K values can be assigned
        # to each state.

        for i in range(self.number_of_levels()):    
            initial_level_key       = all_level_keys[i]
            initial_level_object    = self.levels[initial_level_key]
            initial_band_name = initial_level_key[0]
            initial_spin      = initial_level_key[1]
            initial_K         = initial_level_object.get_K()
            for j in range(self.number_of_levels()):
                final_level_key = all_level_keys[j]
                final_level_object = self.levels[final_level_key]
                final_band_name = final_level_key[0]
                final_spin      = final_level_key[1]
                final_K         = final_level_object.get_K()
                if initial_band_name == requested_initial_band_name and final_band_name == requested_final_band_name:    # The initial and final bands of these states match.
                    if self.spin_parity_allowed_transition(multipole_text,initial_level_key,final_level_key):
                        # Using the absolute change in K "mod_delta_K" to get the forbiddenness, n.
                        mod_Delta_K = int(abs(final_K - initial_K))
                        # The "forbiddenness" is "n".
                        n = mod_Delta_K - l
                        # Get the proper normalization from B&M II pg 60, eqn 4-98:
                        if initial_K == 0.0:
                            normalization = math.sqrt(2.)
                        else:
                            normalization = 1.0

                        # Here the C.G. coefficient is exactly that of B&M 4-98 for K-forbidden transitions in general.
                        coupling = ned(initial_spin,l,final_spin,final_K-l,l,final_K) 

                        # Get the M_2 term in B&M 4-98.
                        M_2_term = M_2 * (final_spin*(final_spin + 1.0) - (initial_spin * (initial_spin + 1.0)))
                        # If the initial K value is 1/2, then add the M_3 term from B&M 4-98.
                        if initial_K == 0.5:
                            M_3_term = M_3 * (-1.)**(initial_spin + 0.5) * round((initial_spin + 0.5),1)
                        else:
                            M_3_term = 0.
                        reduced_matrix_element = normalization * math.sqrt(2.*initial_spin+1.) * coupling \
                          * (M_1 + M_2_term + M_3_term) * factorial_term(initial_spin,initial_K,n) 

                        if saturation_limit:
                            # If a saturation limit is to be applied to the matrix elements, then check it now.
                            bml = reduced_matrix_element**2 / (2.*initial_spin + 1.)       # B(ML) in excitation direction
                            # Use the minimum of the magnitude of the matrix element or the saturation limit 
                            # with the sign calculated above, in either case (preserve phase calculated by
                            # model).
                            if bml > maximum_bml:
                                maximum_matrix_element = math.sqrt(maximum_bml*(2.*initial_spin + 1.))
                                reduced_matrix_element = math.copysign(maximum_matrix_element,reduced_matrix_element)
                        
                        # Put the matrix element into the data.
                        # Check that it is within requested spin limits, if spin limits were requested.
                        should_add_this_one = True
                        if not low_spin_limit == None:
                            if initial_spin < low_spin_limit:
                                should_add_this_one = False
                        if not high_spin_limit == None:
                            if initial_spin > high_spin_limit:
                                should_add_this_one = False
                        # Only put it in if it is not identically 0 and within
                        # initial spin limits if requested.
                        if not reduced_matrix_element == 0.0 and should_add_this_one:  
                            self.add_matrix_element(multipole_string = multipole_text, initial_band_name = initial_band_name,\
                              final_band_name = final_band_name,initial_spin = initial_spin, final_spin = final_spin,\
                              value = reduced_matrix_element)
                            # Print the matrix element added.
                            comment = "M_2 term = " + str(M_2_term) + ", M_3 term = " + str(M_3_term)
                            formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                              final_band_name = final_band_name, initial_K = initial_K, final_K = final_K, final_spin = final_spin, \
                              multipole_text = multipole_text, value = reduced_matrix_element, comment = comment) 
                            matrix_element_counter += 1

        # Don't need to redraw; the add_inter_band method does that.

        return 0   # no error returned


    def add_k_forbidden(self,multipole_text,bandnumber1,bandnumber2,low_spin_limit=None,high_spin_limit=None):
        """Adds K-forbidden matrix elements.

        See Bohr and Mottelson, vol. 2, equation 4-98.

        This is essentially the same as the add_mikhailov method, but it is
        left as a separate method, in case minor differences are added.

        """

        # A counter for non-zero matrix elements added.  (Matrix elements that are identically zero are skipped.)
        matrix_element_counter = 0

        # Get the band name from the band number.  Band names have been checked in def add_inter_band.
        requested_initial_band_name = self.get_primary_band_name_from_band_number(bandnumber1)
        requested_final_band_name   = self.get_primary_band_name_from_band_number(bandnumber2)

        # Capitalize the multipole text "e2" --> "E2".
        multipole_text = multipole_text.upper()

        l = MULTIPOLE_LAMBDA[multipole_text]    # lambda
        print "lambda = ",l

        print "Matrix elements assume the angular-momentum coupling\n",\
              "  of the Alaga rule, so only K-allowed transitions are\n",\
              "  handled.  The intrinsic matrix element is given a\n",\
              "  spin-dependence:\n",\
              "    <Kf|xx|Ki> = M_1 + M_2(I_f^2 - I_i^2) + ",\
              "       + M_3(-1)^(I_i + 1/2)*(I_i + 1/2)*kronecker_delta(K_i,1/2),\n",\
              "  where xx is one of E2, M1, etc., and\n",\
              "       I_f^2 = I_f(I_f + 1), I_i^2 = I_i(I_i + 1).\n",\
              "  See, e.g. Bohr and Mottelson, eqn 4-98.\n",\
              "  (Omit the spin-dependent factorial terms.)"

        M_1 = prompt_number("M_1 = ","f")
        if M_1 == "quit":
            return 0
        M_2 = prompt_number("M_2 = ","f")
        if M_2 == "quit":
            return 0

        block_print_with_line_breaks("\nIf the kronecker_delta(K_1,1/2) term (in Bohr & Mottelson equation 4-98) is needed, enter M_3 here.  Otherwise, enter zero.  If the term does not apply, it will be ignored.)",70)
        M_3 = prompt_number("M_3 = ","f")
        if M_3 == "quit":
            return 0

        string_maximum_bml = raw_input("Maximum B(ML) [W.u.] value or RETURN for no limit: ")
        # See if a maximum was requested.  If it can be converted to a float, then it
        # will be used as an upper limit.
        try:
            maximum_bml_wu = float(string_maximum_bml)
            saturation_limit = True  
            maximum_bml = maximum_bml_wu * calc_wu(self.get_value("A"),multipole_text)  # Maximum B(ML) allowed in e,b,n.m.
        except:
            saturation_limit = False

        # Get all the level keys sorted by band name, then spin.    This is
        # important to prevent adding a matrix element <b||E2||a> and a second
        # one <a||E2||b>.
        all_level_keys = self.get_sorted_unique_level_keys()

        # July 2011: Instead of checking the K value of the band, we will check
        # the K value of each level, so that different K values can be assigned
        # to each state.

        block_print_with_line_breaks("\nCheck below for unintended changes in K.\n\nThe Clebsch-Gordan terms depend only on the K value of the final band, as in B&M equation 4-95.",70)

        for i in range(self.number_of_levels()):    
            initial_level_key       = all_level_keys[i]
            initial_level_object    = self.levels[initial_level_key]
            initial_band_name = initial_level_key[0]
            initial_spin      = initial_level_key[1]
            initial_K         = initial_level_object.get_K()
            for j in range(self.number_of_levels()):
                final_level_key = all_level_keys[j]
                final_level_object = self.levels[final_level_key]
                final_band_name = final_level_key[0]
                final_spin      = final_level_key[1]
                final_K         = final_level_object.get_K()
                if initial_band_name == requested_initial_band_name and final_band_name == requested_final_band_name:    # The initial and final bands of these states match.
                    if self.spin_parity_allowed_transition(multipole_text,initial_level_key,final_level_key):
                        # Using the absolute change in K "mod_delta_K" to get the forbiddenness, n.
                        mod_Delta_K = int(abs(final_K - initial_K))
                        # The "forbiddenness" is "n".
                        n = mod_Delta_K - l
                        # Get the proper normalization from B&M II pg 60, eqn 4-98:
                        if initial_K == 0.0:
                            normalization = math.sqrt(2.)
                        else:
                            normalization = 1.0

                        # Here the C.G. coefficient is exactly that of B&M 4-98 for K-forbidden transitions in general.
                        coupling = ned(initial_spin,l,final_spin,final_K-l,l,final_K) 

                        # Get the M_2 term in B&M 4-98.
                        M_2_term = M_2 * (final_spin*(final_spin + 1.0) - (initial_spin * (initial_spin + 1.0)))
                        # If the initial K value is 1/2, then add the M_3 term from B&M 4-98.
                        if initial_K == 0.5:
                            M_3_term = M_3 * (-1.)**(initial_spin + 0.5) * round((initial_spin + 0.5),1)
                        else:
                            M_3_term = 0.
                        reduced_matrix_element = normalization * math.sqrt(2.*initial_spin+1.) * coupling \
                          * (M_1 + M_2_term + M_3_term) * factorial_term(initial_spin,initial_K,n) 

                        if saturation_limit:
                            # If a saturation limit is to be applied to the matrix elements, then check it now.
                            bml = reduced_matrix_element**2 / (2.*initial_spin + 1.)       # B(ML) in excitation direction
                            # Use the minimum of the magnitude of the matrix element or the saturation limit 
                            # with the sign calculated above, in either case (preserve phase calculated by
                            # model).
                            if bml > maximum_bml:
                                maximum_matrix_element = math.sqrt(maximum_bml*(2.*initial_spin + 1.))
                                reduced_matrix_element = math.copysign(maximum_matrix_element,reduced_matrix_element)
                        
                        # Put the matrix element into the data.
                        # Check that it is within requested spin limits, if spin limits were requested.
                        should_add_this_one = True
                        if not low_spin_limit == None:
                            if initial_spin < low_spin_limit:
                                should_add_this_one = False
                        if not high_spin_limit == None:
                            if initial_spin > high_spin_limit:
                                should_add_this_one = False
                        # Only put it in if it is not identically 0 and within
                        # initial spin limits if requested.
                        if not reduced_matrix_element == 0.0 and should_add_this_one:  
                            self.add_matrix_element(multipole_string = multipole_text, initial_band_name = initial_band_name,\
                              final_band_name = final_band_name,initial_spin = initial_spin, final_spin = final_spin,\
                              value = reduced_matrix_element)
                            # Print the matrix element added.
                            comment = "M_2 term = " + str(M_2_term) + ", M_3 term = " + str(M_3_term)
                            formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                              final_band_name = final_band_name, initial_K = initial_K, final_K = final_K, final_spin = final_spin, \
                              multipole_text = multipole_text, value = reduced_matrix_element, comment = comment) 
                            print formatted_text
                            matrix_element_counter += 1

        print "Added ",matrix_element_counter," matrix elements."
        # Don't need to redraw; the add_inter_band method does that.

        return 0   # no error returned

    def add_single_matrix_element(self,multipole_text,band_number_1,band_number_2):
        """Adds a single matrix element.

        The matrix element can be entered as a number, or as a mathematical
        expression, including Clebsch-Gordan coefficients using ned().

        """

        # Get the band name from the band number.  Band names have been checked in def add_inter_band.
        requested_initial_band_name = self.get_primary_band_name_from_band_number(band_number_1)
        requested_final_band_name   = self.get_primary_band_name_from_band_number(band_number_2)

        # Capitalize the multipole text "e2" --> "E2".
        multipole_text = multipole_text.upper()
        multipole_number = MULTIPOLE[multipole_text]  # The gosia code number for this multipole.

        print "Entering a reduced matrix element <",requested_final_band_name,"If||",multipole_text,"||",requested_initial_band_name,"Ii>."
        # Prompt for the initial and final spins.
        Ii = prompt_number("Ii: ","r")
        if Ii == "quit":
            return 0
        If = prompt_number("If: ","r")
        if Ii == "quit":
            return 0

        # Prompt for the reduced matrix element.
        print "Enter a numeric value [e,b,n.m.] or a mathematical expression."
        print "  Mathematical expressions can include standard operators "
        print "  (*,+,-,/,**[exponent]), Python math functions"
        print "  such as math.sqrt(Ii*2.+1.)."
        print "  Enter Clebsch-Gordan coefficients using the function "
        print "  cgc(j1,m1,j2,m2,j3,m3) = <j1 m1 j2 m2 | j3 m3>,"
        print "  following the order of spins used in Bohr and Mottelson."
        print "  For example, cgc(Ii,2,2,1,If,3) = <Ii 2 2 1 | If 3>."
        reduced_matrix_element = input("<If ||"+multipole_text+"||Ii>  = ")
        if reduced_matrix_element == 0.:
            print "Matrix element evaluates to exactly 0.\n  It will not be added.\nCancelled."
            return -1

        # Find the initial and final states in the level scheme.
        initial_level_key = (requested_initial_band_name, Ii)
        final_level_key   = (requested_final_band_name, If)
        initial_internal_level_number = self.lookup_internal_level_by_band_spin(requested_initial_band_name,Ii)
        final_internal_level_number   = self.lookup_internal_level_by_band_spin(requested_final_band_name,If)

        # If the states were entered in the opposite order to that which Gosia
        # needs (odometer order), then time-reverse the matrix element and swap
        # the initial and final states before adding to the matrix.
        if final_internal_level_number < initial_internal_level_number:
            reduced_matrix_element = time_reversal(Ii,If,multipole_text,reduced_matrix_element)
            Ii, If = If, Ii
            requested_initial_band_name, requested_final_band_name = requested_final_band_name, requested_initial_band_name
            initial_level_key, final_level_key = final_level_key, initial_level_key
            print "Gosia requires that the final state number be greater"
            print "  than the initial state number, so the states were"
            print "  reversed, and the matrix element was time-reversed."

        if self.spin_parity_allowed_transition(multipole_text,initial_level_key,final_level_key):
            # Put the matrix element into the data.
            try:
                self.add_matrix_element(multipole_string = multipole_text, initial_band_name = requested_initial_band_name,\
                  final_band_name = requested_final_band_name,initial_spin = Ii, final_spin = If,\
                  value = reduced_matrix_element)
                formatted_text = self.format_one_matrix_element(initial_band_name = requested_initial_band_name,initial_spin = Ii,\
                  final_band_name = requested_final_band_name, final_spin = If, multipole_text = multipole_text, \
                  value = reduced_matrix_element)
                print "Added " + formatted_text
                return 0   # no error returned
            except:
                print "Error."
                return -1
        else:
            print "This transition is not allowed by either spin or parity selection."
            return -1



    def add_alaga(self,multipole_text,bandnumber1,bandnumber2,low_spin_limit=None,high_spin_limit=None,parameter_dict=None):
        """Adds interband matrix elements according to B&M "General Structure of Matrix Elements.

        See Bohr and Mottelson section 4-3d, equations 4-91, 4-92.

        All matrix elements are tested well except the "signature-dependent
        term."

        """

        # A counter for non-zero matrix elements added.  (Matrix elements that are identically zero are skipped.)
        matrix_element_counter = 0

        # Get the band name from the band number.  Band names have been checked in def add_inter_band.
        requested_initial_band_name = self.get_primary_band_name_from_band_number(bandnumber1)
        requested_final_band_name   = self.get_primary_band_name_from_band_number(bandnumber2)

        # Capitalize the multipole text "e2" --> "E2".
        multipole_text = multipole_text.upper()

        l = MULTIPOLE_LAMBDA[multipole_text]    # lambda

        # See if this call is from a script or automated method.  If so, then
        # the parameter_dict will be included and not equal None.

        if not parameter_dict == None:
            intrinsic = parameter_dict["intrinsic"]
            signature_term = parameter_dict["signature_term"]
        else:
            # No parameter dict was included.  Prompt for the required information.
            print "lambda = ",l

            # Prompt for the intrinsic matrix element.
            print "NOTE:\n if K1 <> 0 and K2 == 0, please enter the intrisic matrix element\n",\
                  " as <K1|ML|K2>.  This will be changed in a later version."
            intrinsic = prompt_number("Intrinsic m.e. = ","f")
            if intrinsic == "quit":
                return 0

            block_print_with_line_breaks("\nIf the \"signature-dependent term\" (in Bohr & Mottelson equation 4-91) is needed, enter <K2|M(lambda,nu=K1+K2)|K1-bar> here.  Otherwise, enter zero.  If the term does not apply, it will be ignored.)",70)
            signature_term = prompt_number("<K2|M(lambda,nu=K1+K2)|K1-bar> = ","f")
            if signature_term  == "quit":
                return 0

        # Get all the level keys sorted by band name, then spin.    This is
        # important to prevent adding a matrix element <b||E2||a> and a second
        # one <a||E2||b>.
        all_level_keys = self.get_sorted_unique_level_keys()

        # July 2011: Instead of checking the K value of the band, we will check
        # the K value of each level, so that different K values can be assigned
        # to each state.

        print "\nCheck below for unintended changes in K.\n"

        for i in range(self.number_of_levels()):    
            initial_level_key       = all_level_keys[i]
            initial_level_object    = self.levels[initial_level_key]
            initial_band_name = initial_level_key[0]
            initial_spin      = initial_level_key[1]
            initial_K         = initial_level_object.get_K()
            for j in range(self.number_of_levels()):
                final_level_key = all_level_keys[j]
                final_level_object = self.levels[final_level_key]
                final_band_name = final_level_key[0]
                final_spin      = final_level_key[1]
                final_K         = final_level_object.get_K()
                if initial_band_name == requested_initial_band_name and final_band_name == requested_final_band_name:    # The initial and final bands of these states match.
                    # Mark the signature term not needed, unless it is found to be needed below.
                    signature_term_needed = False
                    # if this pair of levels belong to correct pair of bands, in correct order 
                    # (bandnumber1 --> bandnumber2) same as (i --> j)
                    if self.spin_parity_allowed_transition(multipole_text,initial_level_key,final_level_key):
                        # This transition is spin-parity allowed.
                        if initial_K == 0:
                            # Special coupling is needed.  See B&M eqn 4-92.
                            if final_K == 0:
                                # Normalization constant is 1
                                normalization = 1.
                            else:
                                normalization = math.sqrt(2.)

                            coupling = ned(initial_spin,l,final_spin,0,final_K,final_K) 
                            reduced_matrix_element = math.sqrt(2.*initial_spin+1.) * intrinsic \
                              * coupling * normalization
                        elif final_K == 0:
                            # Special coupling is needed.  See B&M eqn 4-92.
                            # (Here it has already been determined that K1 is not 0, so
                            # K2 = 0 and K1 <> 0.
                            # This is the same case as above, with normalization sqrt(2), but
                            # B&M defines the matrix elements always going from a K=0 band.
                            # Calculate the matrix element from K=0 band to other band (initial_K),
                            # apply the correct normalization, and then time-reverse the 
                            # matrix element before saving it.
                            normalization = math.sqrt(2.)
                            temporary_initial_K = final_K
                            temporary_final_K = initial_K
                            temporary_initial_spin = final_spin
                            temporary_final_spin = initial_spin
                            coupling = ned(temporary_initial_spin,l,temporary_final_spin,\
                              0,temporary_final_K,temporary_final_K) 
                            backward_reduced_matrix_element = math.sqrt(2.*temporary_initial_spin+1.) * intrinsic \
                              * coupling * normalization
                            # Now time-reverse the matrix element into the proper direction
                            reduced_matrix_element = time_reversal(temporary_initial_spin,temporary_final_spin,multipole_text,backward_reduced_matrix_element)
                        else:
                            # Neither K1 nor K2 is zero.  B&M equation 4-91 applies, possibly with the signature term
                            coupling_1 = ned(initial_spin,l,final_spin,initial_K,final_K - initial_K,final_K)
                            first_term = coupling_1 * intrinsic
                            # If the signature term can be coupled, ask for it.  See B&M II, eqn 4-91
                            if not initial_K == 0. and not final_K == 0. and l - (initial_K + final_K) + ASMIDGE > 0.0:  # being careful about base 2 representation
                                # (The base 2 is probably not important,
                                # because we defined everything starting from
                                # rounded floats, but this will avoid potential
                                # problems.)
                                signature_term_needed = True
                            else:
                                signature_term_needed = False

                            if signature_term_needed:
                                coupling_2 = ned(initial_spin,l,final_spin,-initial_K,initial_K+final_K,final_K)
                                phase_factor = (-1)**int(round(initial_spin+initial_K))
                                second_term = signature_term * coupling_2 * phase_factor
                            else:
                                second_term = 0
                            reduced_matrix_element = math.sqrt(2.*initial_spin+1.) * (first_term + second_term)

                                
                        # Put the matrix element into the data.
                        # If spin limits were requested, then only add ones where the initial spin is within the limits.
                        should_add_this_one = True
                        if not low_spin_limit == None:
                            if initial_spin < low_spin_limit:
                                should_add_this_one = False
                        if not high_spin_limit == None:
                            if initial_spin > high_spin_limit:
                                should_add_this_one = False
                        if not reduced_matrix_element == 0.0 and should_add_this_one:  # only put it in if it is not identically 0 and if it's within requested spin limits
                            self.add_matrix_element(multipole_string = multipole_text, initial_band_name = initial_band_name,\
                              final_band_name = final_band_name,initial_spin = initial_spin, final_spin = final_spin,\
                              value = reduced_matrix_element)
                            if signature_term_needed:
                                comment = " signature term = " + str(second_term)
                            else:
                                comment = ""
                            # Print the matrix element added.
                            formatted_text = self.format_one_matrix_element(initial_band_name = initial_band_name,initial_spin = initial_spin,\
                              final_band_name = final_band_name, initial_K = initial_K, final_K = final_K, final_spin = final_spin, \
                              multipole_text = multipole_text, value = reduced_matrix_element, comment = comment) 
                            print formatted_text
                            matrix_element_counter += 1

        print "Added ",matrix_element_counter," matrix elements."
        # Don't need to redraw; the add_inter_band method does that.

        return 0   # no error returned



    def merge_bands(self,recipient_band_number,donor_band_number):
        """Merges two bands into one.

        """

        # July 2011.

        #  If the donor and recipient are the same band, do nothing
        if donor_band_number == recipient_band_number:
            # No error is returned, because nothing was done.
            block_print_with_line_breaks("Can't merge a band into itself.  Change the band numbers in the \"Initial / final band\" fields.")
            return 0

        internal_donor_band_number     = donor_band_number     - 1
        internal_recipient_band_number = recipient_band_number - 1

        # Get the primary band name for each level from the band settings list.
        all_band_names      = self.get_all_band_names_in_order(include_inactive_bands = True)
        donor_band_name     = all_band_names[internal_donor_band_number]
        recipient_band_name = all_band_names[internal_recipient_band_number]
        
        # Safety checks for merging bands:
        # Check that all spins are unique, and that parities are all equal for
        # the two bands.  If not, then refuse to merge, because this would
        # cause problems.
        donor_band_level_keys     = self.get_all_level_keys_in_band_name(donor_band_name)
        recipient_band_level_keys = self.get_all_level_keys_in_band_name(recipient_band_name)

        # Check the parity of the first state in each band.  If the parities of
        # the two bands are unequal, merging them will cause problems with the
        # matrix and level methods.  Don't allow this.
        if not self.levels[donor_band_level_keys[0]].get_parity() == self.levels[recipient_band_level_keys[0]].get_parity():
            print "\nCan't merge bands of different parity.\n"
            return -1
        # Cycle through the keys in each band, and determine whether there are
        # one or more same-spin states in the two bands.
        spins_in_donor_band     = set(zip(*donor_band_level_keys)[1])
        spins_in_recipient_band = set(zip(*recipient_band_level_keys)[1])
        # Use set math to quickly see if there are no common spins in each band.
        if not (spins_in_donor_band - spins_in_recipient_band == spins_in_donor_band) or\
           not (spins_in_recipient_band - spins_in_donor_band == spins_in_recipient_band):
            # There are common spins in the two bands.  Don't allow a merge,
            # because this will confuse the level and matrix methods.
            print "\nCan't merge these two bands, because they have one or more common spins.\n"
            return -1

        # Add an alias for each level in the donor band.
        for one_level_key in self.levels.keys():
            this_band_name            = one_level_key[0]
            this_spin                 = one_level_key[1]
            this_level_object_pointer = self.levels[one_level_key]
            if this_band_name == donor_band_name:
                # Add an alias to this level with the new recipient band name.
                self.levels[(recipient_band_name,this_spin)] = this_level_object_pointer 

        # Remove the donor band entry from the band settings list.
        del self.band_settings_list[internal_donor_band_number]

        # Change the keys to matrices that reference the donor band, since the
        # matrix must always reference primary levels (bands), not aliases.
        self.set_matrix_keys_to_primary_levels()

        # Now reorder the direction of matrix elements and time-reverse as necessary.
        self.put_matrix_elements_in_gosia_direction()

        self.print_K_values(recipient_band_number)

        self.set_one_band_K_values(recipient_band_number)
        print "Band merge finished."

        return 0

    def delete_band(self,external_band_number_to_delete):
        """Deletes a band from the level scheme

        We use an existing band number here, so that we don't need to consider
        aliases.  

        """

        # Rewritten July 2011.  When levels are deleted, their aliases should
        # vanish automatically.  This has been tested on September 7 2011.

        # Make a list of all levels objects to be deleted.  The we will delete
        # from the levels dictionary all entries which point to these objects.
        # The object pointers are converted to strings, and the string values,
        # e.g. "<__main__.level instance at 0x3c71248>" are compared.
        level_object_strings_to_delete = []

        # Get all of the primary band names.
        all_band_names_in_order = self.get_all_band_names_in_order(include_inactive_bands = True)

        # Get the primary band name to delete.
        internal_band_number_to_delete = external_band_number_to_delete - 1
        primary_band_name_to_delete = all_band_names_in_order[internal_band_number_to_delete]

        # Get a list of the level objects, 
        for one_level_key in self.levels.keys():
            this_band_name = one_level_key[0]
            if this_band_name == primary_band_name_to_delete:
                # Convert this level object reference to a string, so that we
                # can see what level keys reference it and delete them.
                level_object_strings_to_delete.append(str(self.levels[one_level_key]))

        # Delete all references to each level object.  Cycle through *all*
        # level keys to get all aliases to this object.  This method can be
        # copied to a method to return level aliases and band aliases.
        # Keep a list of all deleted level keys.  This will be used to update
        # (prune) other data, such as the matrix.  This new list will include
        # all aliases to deleted levels as well.
        all_deleted_level_keys = []
        for one_level_key in self.levels.keys():
            this_level_object_string = str(self.levels[one_level_key])
            if this_level_object_string in level_object_strings_to_delete:
                del self.levels[one_level_key]
                # Add to the list of deleted level keys.
                all_deleted_level_keys.append(one_level_key)

        # Delete the band entry from the band settings list.
        del self.band_settings_list[internal_band_number_to_delete]

        for one_matrix_key in self.matrix_data.keys():
            # Get the (band name, spin) keys of the initial and final states of
            # the m.e. entry.
            initial_level_key = (one_matrix_key[1],one_matrix_key[2])  
            final_level_key   = (one_matrix_key[3],one_matrix_key[4])
            if (initial_level_key in all_deleted_level_keys) or (final_level_key in all_deleted_level_keys):
                del self.matrix_data[one_matrix_key]

        return 0

    def get_all_band_aliases(self,band_name):
        """Returns a list of aliases of the requested band.

        This is done in the class nucleus, because the level objects are keyed
        by aliases in the nucleus.levels dictionary; the level objects
        themselves don't know about the aliases (or band names).

        """

        # New: July 25th 2011.

        # The list of aliases (possibly empty) of this band.  The requested
        # name is not included in the list.
        list_of_aliases = []

        # Make a list of all of the level objects keyed by "band_name" and any
        # spin in self.levels.  Each entry is of the form: "<__main__.level
        # instance at 0x3c71248>".
        level_object_pointer_strings_in_this_band = []

        for one_level_key in self.levels.keys():
            this_band_name = one_level_key[0]
            if this_band_name == band_name:
                # Add this level object to the list as a pointer converted to a string.
                this_level_object_string = str(self.levels[one_level_key])
                level_object_pointer_strings_in_this_band.append(this_level_object_string)

        # Now cycle through all level keys and see which ones point to any of
        # the objects collected above.
        for one_level_key in self.levels.keys():
            this_level_object_string = str(self.levels[one_level_key])
            if this_level_object_string in level_object_pointer_strings_in_this_band:
                this_band_name = one_level_key[0]
                # This is either the primary band name or an alias.  If it
                # isn't the primary name, add it to the list of aliases to
                # return.
                if not this_band_name == band_name:
                    list_of_aliases.append(this_band_name)

        # May 25, 2012: This gives multiple entries.  Reduce to a set, then back to list.
        set_of_aliases = set(list_of_aliases)
        list_of_aliases = list(set_of_aliases)

        return list_of_aliases

    def swap_bands(self,external_band_number_1, external_band_number_2):
        """Swaps the numbers and positions of two bands.

        Interchanges the bands whose numbers are band1 and band2.
        This will be used for setting the GSB to band 1, among other
        things.

        Swaps the order of external_band_number_1 and external_band_number_2 in
        the band_settings_list.

        Time-reverses the matrix elements in memory if they are found to be in
        the wrong order after the interchange of band numbers.

        """

        # July 2011.

        # Get the internal (base 0) numbers of the original bands.
        internal_band_number_1 = external_band_number_1 - 1
        internal_band_number_2 = external_band_number_2 - 1

        # Get the initial and final band names.
        original_band_name_1 = self.band_settings_list[internal_band_number_1]
        original_band_name_2 = self.band_settings_list[internal_band_number_2]

        # Make a deepcopy of the band settings list.
        copy_of_old_band_settings_list = copy.deepcopy(self.band_settings_list)

        # Make a new band settings list.  This will replace the original, after
        # the changes.
        new_band_settings_list = []

        # Swap the order of the bands listed in self.band_settings_list.  This
        # will update the order in which they are displayed, and the output
        # methods for Gosia will read the levels in the display order and
        # low-spin to high-spin.
        for i in range(len(self.band_settings_list)):
            if   i == internal_band_number_1:
                new_band_settings_list.append(copy_of_old_band_settings_list[internal_band_number_2])
            elif i == internal_band_number_2:
                new_band_settings_list.append(copy_of_old_band_settings_list[internal_band_number_1])
            else:
                # This is not one of the bands to swap.  Just copy the original entry.
                new_band_settings_list.append(copy_of_old_band_settings_list[i])

        # Copy the new band settings list to save it.
        self.band_settings_list = copy.deepcopy(new_band_settings_list)

        self.put_matrix_elements_in_gosia_direction()

        block_print_with_line_breaks("After swapping bands, matrix elements have been time-reversed for the new ordering of states.  This is necessary to send them in the correct order to Gosia.  You might want to examine the limits on any \"master\" matrix elements to check that they were properly corrected for time-reversal.",70)

        return 0
        
    def set_matrix_keys_to_primary_levels(self):
        """Changes any references to level pseudonyms in the matrix keys to primary levels.

        """

        # Cycle through all matrix keys.  If a matrix key refers to an alias,
        # it will be re-keyed to the primary level keys.  (Level pseudonyms are
        # not allowed in the matrix keys.)

        for matrix_key in self.matrix_data.keys():

            # Extract the initial and final level keys from the matrix element key.
            multipole_code    = matrix_key[0]
            initial_level_key = (matrix_key[1:3])
            final_level_key   = (matrix_key[3:5])

            # Get the primary level key for the initial and final states.  If
            # these are pseudonyms, then the primary keys will be different.
            primary_initial_level_key = self.get_primary_level_key_from_pseudonym(initial_level_key)
            primary_final_level_key   = self.get_primary_level_key_from_pseudonym(final_level_key)

            # If the primary keys are not the same as the original keys, then
            # add the new key first (to preserve the matrix element object).
            # Then delete the original key.
            if not (initial_level_key == primary_initial_level_key and final_level_key == primary_final_level_key):
                # Get the matrix element object to re-key it.
                matrix_element_object = self.matrix_data[matrix_key]  # using the original key to be deleted below.
                # Replace this key with a new key using primary band names.
                new_initial_band_name, new_initial_spin = primary_initial_level_key 
                new_final_band_name, new_final_spin     = primary_final_level_key 
                new_matrix_key = (multipole_code, new_initial_band_name, new_initial_spin, new_final_band_name, new_final_spin)
                # Add the matrix element object with the new key.
                self.matrix_data[new_matrix_key] = matrix_element_object
                # Remove the old matrix key.
                del self.matrix_data[matrix_key]

        return 0

    def put_matrix_elements_in_gosia_direction(self):
        """Time-reverses and re-indexes matrix elements so that they are in Gosia order.

        Gosia requires matrix elements to be in the direction of lower level
        number to higher level number.

        """

        # Get the level keys in the order they will be sent to Gosia.
        ordered_level_keys = self.get_level_keys_in_gosia_order(include_inactive_bands = True)

        # Cycle through all matrix elements.  If the initial, final level keys
        # for a matrix element are not in the order in ordered_level_keys,
        # time-reverse the matrix element, and re-key it from lower-index level
        # to higher-index level.
        for one_matrix_key in self.matrix_data.keys():
            # See if it is in the correct direction (lower to higher band
            # number, lower to higher spin).
            matrix_element_object = self.matrix_data[one_matrix_key]
            initial_band_name     = one_matrix_key[1]
            initial_spin          = one_matrix_key[2]
            final_band_name       = one_matrix_key[3]
            final_spin            = one_matrix_key[4]
            initial_level_key = (initial_band_name, initial_spin)
            final_level_key   = (final_band_name, final_spin)
            # If the index of the initial level in the ordered level keys is
            # lower than that of the final level, then the matrix element is in
            # the correct direction.  Otherwise, it needs to be time-reversed,
            # and the new matrix entry must replace the original.  Just change
            # the value using the accessor, then re-key the matrix element
            # object in self.matrix_data.
            if not ordered_level_keys.index(final_level_key) >= ordered_level_keys.index(initial_level_key):
                # This matrix entry must have its initial and final level keys reversed.
                # Get the mutlipole number for the time reversal.
                multipole_code_number = one_matrix_key[0]  # 2 for E2, 7 for M1, etc.
                # Get the multipole text ("E2", "M1", etc.)
                multipole_text = REVERSE_MULTIPOLE[multipole_code_number]
                # Get the orginal value.
                original_matrix_element = matrix_element_object.get_current_value()
                # Get the value of the matrix element time-reversed.
                time_reversed_matrix_element = time_reversal(initial_spin,final_spin,multipole_text,original_matrix_element)
                
                # Set the new value of the matrix element, if it changed.
                if not math.copysign(1.,time_reversed_matrix_element) == math.copysign(1.,original_matrix_element):
                    matrix_element_object.set_current_value(time_reversed_matrix_element)
                    sign_changed = True
                else:
                    sign_changed = False


                # See if this is a master (has its own limits):
                if matrix_element_object.get_is_master():
                    is_master = True
                else:
                    is_master = False
                # See if the sign of the matrix element was changed.
                if sign_changed:
                    # The sign changed.  Need to check whether the limits need
                    # to be updated by swapping or sign change(s).
                    if is_master:
                        # Get the limits for this master.  If the time-reversal
                        # changed the sign, then the signs of the limits may need to be
                        # reversed, and the upper, lower limits may need to be
                        # interchanged.
                        original_upper_limit = matrix_element_object.get_upper_limit()
                        original_lower_limit = matrix_element_object.get_lower_limit()

                        # The upper and lower limits should be interchanged,
                        # and their signs should be changed also.
                        new_upper_limit = -original_lower_limit
                        new_lower_limit = -original_upper_limit
                        # Set the new upper and lower limits.
                        matrix_element_object.set_upper_limit(new_upper_limit)
                        matrix_element_object.set_lower_limit(new_lower_limit)

                # Now the time-reversed matrix element must be re-keyed to the
                # new order of initial and final bands.
                new_matrix_key = (multipole_code_number, final_band_name, final_spin, initial_band_name, initial_spin)
                # Add the matrix element object with the new key.
                self.matrix_data[new_matrix_key] = matrix_element_object
                # Remove the old matrix key.
                del self.matrix_data[one_matrix_key]

        return 0

    def get_level_keys_in_gosia_order(self,include_inactive_bands = True):
        """Returns the (band_name,spin) level keys in the order that Gosia needs them.

        If include_inactive_bands is False, then only bands designated by the
        user as "active" will be returned.  This will be used to deselect bands
        sent to Gosia to save memory.

        """

        # New July 2011.

        # Make a dictionary for sorting the level keys.  The key of this
        # dictionary will be (internal_band_number, spin), so that the keys can
        # be sorted in one .sort() operation.  The values to which the keys
        # point are the (band_name, spin) tuples.
        level_key_sorting_dictionary = {}

        # A list for the final sorted level keys to return.
        ordered_level_keys_list = []

        # Get the band names in order.  We will exclude the 
        ordered_band_names = self.get_all_band_names_in_order(include_inactive_bands = include_inactive_bands)

        for one_level_key in self.levels.keys():
            this_band_name = one_level_key[0]
            # See if this band name is in the ordered band names.  If not, then
            # the user chose to exclude one or more inactive bands.
            if this_band_name in ordered_band_names:
                # This band should be included.  Get the spin and the band
                # number to key the sorting dictionary.
                this_spin      = one_level_key[1]
                # If bands have been excluded, then this may not be the
                # "absolute" band number.  We call it "relative."
                this_relative_band_number = ordered_band_names.index(this_band_name)
                sorting_key = (this_relative_band_number, this_spin)
                level_key_sorting_dictionary[sorting_key] = one_level_key

        # Now the sorting dictionary is built.  Sort the keys and output the
        # level keys in the sorted order by band number, then spin.
        sorted_dictionary_keys = level_key_sorting_dictionary.keys()
        sorted_dictionary_keys.sort()

        # Cycle through the keys and make the list of level keys to return.
        for one_sort_key in sorted_dictionary_keys:
            standard_level_key = level_key_sorting_dictionary[one_sort_key]
            ordered_level_keys_list.append(standard_level_key)

        return ordered_level_keys_list


    def get_all_dependent_matrix_keys(self,master_matrix_key):
        """Returns a list of all matrix keys of dependents on this master.

        If there are no dependents of this master, then an empty list is returned.

        """

        dependent_keys = []

        # Search all matrix elements to find dependents on this master.
        for matrix_key in self.matrix_data.keys():
            if self.is_dependent_on(master_matrix_key,matrix_key):
                dependent_keys.append(matrix_key)

        return dependent_keys
            
    def is_dependent_on(self,master_matrix_key,possible_dependent_key):
        """Returns True if the matrix element possible_dependent_key is dependent on the master.

        Otherwise returns False.

        Both arguments are matrix element key tuples.

        """

        possible_dependent_object = self.matrix_data[possible_dependent_key]

        # Try to get the key to this possible dependent's master.  If None is
        # returned, then it is not a dependent.
        possible_dependent_master_key = possible_dependent_object.get_master_matrix_element_key()
        if possible_dependent_master_key == None:
            return False
        elif possible_dependent_master_key == master_matrix_key:
            return True
        else:
            return False


    def get_matrix_element_selection_rules(self):
        """Prompts the user for Boolean rules to define matrix elements.

        If the user enters nothing, then only the list ["False"] is returned,
        so that no matrix elements will match.

        """

        print " Use the variables ib (initial band number)"
        print "                   fb (final band number)"
        print "                   ii (initial spin)"
        print "                   fi (final spin)"
        print "                   ml (multipole)"
        print " and the boolean operators ==, <, >, not, and, or."
        print " Expressions on separate lines will be combined by a logical \"and\"."
        print " Multipole codes are 1(E1)...6(E6), 7(M1) and 8(M2)."
        print " For example, entering \"ib==1 and fb==2 and ml==7\" will specify all"
        print "   M1 matrix elements coupling band 1 to band 2."
        print " IF YOU MAKE A MISTAKE, ENTER \"False\" (without quotes, case sensitive)"
        print "   on a separate line.  This will cancel the operation."
        print "Enter \'q\' to quit when all rules are entered:"
        rules_list = []
        while True:
            new_rule = raw_input("Rule> ")
            if not len(new_rule.strip()) == 0:
                if not new_rule[0].lower() == 'q':
                    rules_list.append(new_rule)
                else:
                    break

        if rules_list == []:
            rules_list = ["False"]

        return rules_list

    def add_dependencies_silent(self,master_key,rules_list):
        """Silent version for future upgrade.
        
        Uses the rules for spins, bands, master matrix element, etc. given in
        the rules list to select the matrix elements to be coupled, and
        to define the master.  

        master_key = (multipole_code,initial_band_name,initial_spin,final_band_name,final_spin)
                 is the identity of the matrix element to which all matrix elements
                 meeting the rules_list conditions (below) will be coupled.

        If the master matrix element also meets these conditions, then this is ignored.

        """


        # rules_list = ["bf == 2","if > ii",...]
        # is a list of strings translated into tests.  If all conditions are met for
        # a matrix element in the level scheme, then the matrix element is coupled to 
        # the master.

        # Extract the parameters describing the master matrix element.
        master_multipole_code, master_initial_band_name, master_initial_spin, master_final_band_name, master_final_spin = master_key
        master_initial_level_key = (master_initial_band_name, master_initial_spin)
        master_final_level_key   = (master_final_band_name, master_final_spin)
        master_multipole_text = REVERSE_MULTIPOLE[master_multipole_code]


        # Step through all matrix elements.  For matrix elements that meet all 
        # of the selection criteria in rules_list, set their coupling to the 
        # indices of the master, using the appropriate gosia code.
        for matrix_key in self.matrix_data.keys():
            # Extract all of the variables that might be referenced in the rules_list.
            # Test each rule (condition).  If all conditions are met for this matrix element,
            # couple this one to the master.  This "rules" method may be a minor nuisance to
            # the user, so maybe a "define quick dependency" button should also be included.

            matrix_element_object = self.matrix_data[matrix_key]

            # Get the variables that index the matrix element.
            multipole_code, initial_band_name, initial_spin, final_band_name, final_spin = matrix_key
            # Get the multipole_text string.
            multipole_text = REVERSE_MULTIPOLE[multipole_code]
            # The band numbers as displayed on the level scheme diagram.
            initial_band_number = self.get_band_number_for_display(initial_band_name)
            final_band_number   = self.get_band_number_for_display(final_band_name)
            # Get the level keys to check, for example, whether the matrix_element is a static moment.
            initial_level_key = (initial_band_name,initial_spin)
            final_level_key   = (final_band_name,final_spin)
            current_value     = matrix_element_object.get_current_value()

            # Convert to simple two-character names, so the user can write simple
            # rules without long variable names.
            me = current_value   # The current value of the matrix element
            ml = multipole_code
            mt = multipole_text  # requires the user to type quotes--ml is easier.
            # Get the values of ii, bi, if, bf
            # (initial spin, initial band, final spin, final band)
            ii = initial_spin
            fi = final_spin
            ib = initial_band_number
            fb = final_band_number
            
            # Now run through all conditions to see if this matrix element meets the user's conditions.
            selected = True
            for condition in rules_list:
                try:
                    eval(condition)
                except:
                    print "The rule \"",condition,"\" is invalid."
                    print "Check the allowed variables and syntax, and try again."
                    print "Note that the equality operator is \"==\", not \"=\"."
                    print "Quitting."
                    return 0
                if not eval(condition):
                    # The matrix element does not meet one of the conditions
                    selected = False
                    break              # break out of the for loop

            if selected:
                # This matrix element matches the selection rules.

                # Make sure that this matrix element is not the requested
                # master.  All other matching matrix elements can be set as
                # dependencies.
                if not matrix_key == master_key:
                    # This matrix element is not the master itself.  Set it as dependent on the master.
                    matrix_element_object.set_is_dependent()
                    matrix_element_object.set_master_initial_band_name(master_initial_band_name)
                    matrix_element_object.set_master_final_band_name(master_final_band_name)
                    matrix_element_object.set_master_initial_spin(master_initial_spin)
                    matrix_element_object.set_master_final_spin(master_final_spin)
                    matrix_element_object.set_master_multipole_string(master_multipole_text)
                    matrix_element_description = self.format_one_matrix_element(initial_band_name=initial_band_name,\
                      initial_spin=initial_spin,final_band_name=final_band_name,final_spin=final_spin,\
                      multipole_text=multipole_text,value=current_value)

        return 0   # No error returned


    def add_dependencies(self,master_key=None):
        """Defines the matrix elements to be coupled in a gosia fit.
        
        Uses the rules for spins, bands, master matrix element, etc. given in
        the rules list to select the matrix elements to be coupled, and
        to define the master.  

        master_key = (multipole_code,initial_band_name,initial_spin,final_band_name,final_spin)
                 is the identity of the matrix element to which all matrix elements
                 meeting the rules_list conditions (below) will be coupled.

        If the master matrix element also meets these conditions, then this is ignored.

        """

        if master_key == None:
            # The master has not yet been specified.  Ask for it.
            print "Define the master matrix element to add dependencies to."
            master_key = self.prompt_for_matrix_element()
            if master_key == None:
                print "The master matrix element was not properly defined.  Quitting."
                return 0

        # rules_list = ["bf == 2","if > ii",...]
        # is a list of strings translated into tests.  If all conditions are met for
        # a matrix element in the level scheme, then the matrix element is coupled to 
        # the master.
        # Get the rules list:
        print "Select the matrix elements to couple to this master."
        rules_list = self.get_matrix_element_selection_rules()

        # Extract the parameters describing the master matrix element.
        master_multipole_code, master_initial_band_name, master_initial_spin, master_final_band_name, master_final_spin = master_key
        master_initial_level_key = (master_initial_band_name, master_initial_spin)
        master_final_level_key   = (master_final_band_name, master_final_spin)
        master_multipole_text = REVERSE_MULTIPOLE[master_multipole_code]

        # See if the master is known, and if it truly is a master.
        if not master_key in self.matrix_data.keys():
            print "The chosen master matrix element is not in the matrix.  Quitting."
            return 0
        if not self.matrix_data[master_key].get_is_master():
            print "The chosen master has not yet been set as a master."
            print "Use the button \"Fit parameters\" to set it as a master."
            print "Quitting."
            return 0

        print "The following matrix elements are now coupled to the requested master."

        # Step through all matrix elements.  For matrix elements that meet all 
        # of the selection criteria in rules_list, set their coupling to the 
        # indices of the master, using the appropriate gosia code.
        for matrix_key in self.matrix_data.keys():
            # Extract all of the variables that might be referenced in the rules_list.
            # Test each rule (condition).  If all conditions are met for this matrix element,
            # couple this one to the master.  This "rules" method may be a minor nuisance to
            # the user, so maybe a "define quick dependency" button should also be included.

            matrix_element_object = self.matrix_data[matrix_key]

            # Get the variables that index the matrix element.
            multipole_code, initial_band_name, initial_spin, final_band_name, final_spin = matrix_key
            # Get the multipole_text string.
            multipole_text = REVERSE_MULTIPOLE[multipole_code]
            # The band numbers as displayed on the level scheme diagram.
            initial_band_number = self.get_band_number_for_display(initial_band_name)
            final_band_number   = self.get_band_number_for_display(final_band_name)
            # Get the level keys to check, for example, whether the matrix_element is a static moment.
            initial_level_key = (initial_band_name,initial_spin)
            final_level_key   = (final_band_name,final_spin)
            current_value     = matrix_element_object.get_current_value()

            # Convert to simple two-character names, so the user can write simple
            # rules without long variable names.
            me = current_value   # The current value of the matrix element
            ml = multipole_code
            mt = multipole_text  # requires the user to type quotes--ml is easier.
            # Get the values of ii, bi, if, bf
            # (initial spin, initial band, final spin, final band)
            ii = initial_spin
            fi = final_spin
            ib = initial_band_number
            fb = final_band_number
            
            # Now run through all conditions to see if this matrix element meets the user's conditions.
            selected = True
            for condition in rules_list:
                try:
                    eval(condition)
                except:
                    print "The rule \"",condition,"\" is invalid."
                    print "Check the allowed variables and syntax, and try again."
                    print "Note that the equality operator is \"==\", not \"=\"."
                    print "Quitting."
                    return 0
                if not eval(condition):
                    # The matrix element does not meet one of the conditions
                    selected = False
                    break              # break out of the for loop

            if selected:
                # This matrix element matches the selection rules.

                # Make sure that this matrix element is not the requested
                # master.  All other matching matrix elements can be set as
                # dependencies.
                if not matrix_key == master_key:
                    # This matrix element is not the master itself.  Set it as dependent on the master.
                    matrix_element_object.set_is_dependent()
                    matrix_element_object.set_master_initial_band_name(master_initial_band_name)
                    matrix_element_object.set_master_final_band_name(master_final_band_name)
                    matrix_element_object.set_master_initial_spin(master_initial_spin)
                    matrix_element_object.set_master_final_spin(master_final_spin)
                    matrix_element_object.set_master_multipole_string(master_multipole_text)
                    matrix_element_description = self.format_one_matrix_element(initial_band_name=initial_band_name,\
                      initial_spin=initial_spin,final_band_name=final_band_name,final_spin=final_spin,\
                      multipole_text=multipole_text,value=current_value)
                    print matrix_element_description

        print "Finished."
        return 0   # No error returned

    def read_best_fit_matrix_elements(self,bst_file_name):
        """Reads the best-fit matrix elements from the gosia bst file.

        File name is passed in (from gosia_shell).
        """
        try:
            with open(bst_file_name,'r') as bst_file:
                bst_lines = bst_file.readlines()
        except:
            print "Matrix element file not found."
            return -1

        # The odometer ordering is the same as in the order passed to Gosia.
        # First, get this ordering of matrix keys.
        matrix_keys_in_gosia_order = self.get_all_matrix_keys_in_gosia_order()

        # Cycle through the matrix elements in the gosia order, and set them
        # all to the best fit values in the Gosia bst file.
        matrix_element_number = 0  # The index in the bst file lines.
        for matrix_key in matrix_keys_in_gosia_order:
            best_value = float(bst_lines[matrix_element_number])
            # The following line replaces the matrix element without changing 
            # the limits, couplings, etc.
            self.matrix_data[matrix_key].set_current_value(best_value)
            # See if this matrix element has hit one of the limits.  If so, print a warning.
            # We will only check masters.
            if self.matrix_data[matrix_key].get_is_master():
                upper_limit = self.matrix_data[matrix_key].get_upper_limit()
                lower_limit = self.matrix_data[matrix_key].get_lower_limit()
                hit_upper_limit = (best_value >= upper_limit)
                hit_lower_limit = (best_value <= lower_limit)
                if hit_upper_limit or hit_lower_limit:
                    # Get the matrix element details, and format the matrix element to print the warning.
                    multipole_code, initial_band_name, initial_spin, final_band_name, final_spin = matrix_key
                    multipole_text = REVERSE_MULTIPOLE[multipole_code]
                    units = UNITS_DICT[multipole_text]
                    formatted_matrix_element = self.format_one_matrix_element(initial_band_name=initial_band_name,\
                      initial_spin=initial_spin,final_band_name=final_band_name,final_spin=final_spin,\
                      multipole_text=multipole_text,value=None,initial_K=None,final_K=None,comment=None)
                    print formatted_matrix_element, " has hit the ",
                    if hit_upper_limit:
                        print "upper limit of ",upper_limit,
                    else:
                        print "lower limit of ",lower_limit,
                    print " ", units, "!"

            # Increment the matrix element number to get from the bst file.
            matrix_element_number += 1

        return 0

    def get_all_level_pseudonym_keys(self,requested_level_key):
        """Returns a list of level keys that are pseudonyms pointing to this one.

        """

        pseudonym_keys = []

        try:
            object_string_of_requested_level = str(self.levels[requested_level_key])
        except:
            # The level key is not in memory.  Return an empty list.
            return []

        for one_key in self.levels.keys():
            # Convert the level object reference to a string, e.g. "<__main__.level instance at 0x33cbcb0>"
            level_object_string = str(self.levels[one_key])
            if level_object_string == object_string_of_requested_level and not (one_key == requested_level_key):
                # This object matches the object to which level_key points.
                # There can only be one primary level key that points to this
                # object in the sorted unique level keys.  Return this one.
                 pseudonym_keys.append(one_key)

        return pseudonym_keys


    def get_primary_level_key_from_pseudonym(self,level_key):
        """Returns the primary (band_name,spin) tuple of the requested level.

        If this level_key is a primary name, then it is returned unchanged.  

        If it is a pseudonym, then the primary level key is returned.

        If the level cannot be found, then None is returned.

        """

        primary_level_keys = self.get_sorted_unique_level_keys()  # Getting the KEYS, not the list of level data.
        try:
            object_string_of_requested_level = str(self.levels[level_key])
        except:
            # The level key is not in memory.  Return None.
            return None

        for one_primary_key in primary_level_keys:
            # Convert the level object reference to a string, e.g. "<__main__.level instance at 0x33cbcb0>"
            level_object_string = str(self.levels[one_primary_key])
            if level_object_string == object_string_of_requested_level:
                # This object matches the object to which level_key points.
                # There can only be one primary level key that points to this
                # object in the sorted unique level keys.  Return this one.
                return one_primary_key

        # If flow goes to here, then the primary key could not be found.  This
        # is a bug, since every pseudonym must point to a primary level object.
        print "Primary level key could not be found for level ",level_key,".  Please report this bug."
        return None

    def lookup_internal_level_by_band_spin(self,band_name,spin):
        """Looks up the internal level number of a level in memory by band name, spin.

        The internal level number is now *calculated* by the index in the
        levels in the order they would be sent to Gosia.  Note that for the
        ground state the Gosia index is 1, while the internal level number
        would be 0.

        If the level is not in memory, then return None.

        This now uses a faster method that gets all level keys as a list and
        finds the matching one by the index list method.

        August 2011: Adding a lookup of the primary level key if a pseudonym is
        given.  The calling function does not need to know that it has
        requested the level number of a pseudonym.

        """

        # Get the primary level key of this level.  This will be the original
        # level key if it was a primary level.
        primary_key = self.get_primary_level_key_from_pseudonym((band_name,spin))

        # If the level is unknown, then return None.
        if primary_key == None:
            return None

        # Change band_name to the primary band name.  The spin of a pseudonym
        # is the same as the spin of the primary level key.
        band_name = primary_key[0]

        # Now we have the primary band name, and we can search the unique
        # levels (not including pseudonyms) to get the index of the level we
        # are searching for in the set that will be sent to Gosia.

        # A list of all primary level keys (not including pseudonyms).
        all_level_entries = self.get_sorted_unique_levels()

        # Unzip the level entries into four tuples: band names, spins, parities, energies.
        bands, spins, parities, energies = zip(*all_level_entries)

        # Zip together the (band,spin) tuples in the sorted order.
        band_spin_tuples = zip(bands,spins)

        # Try/except is used, in case the level requested is not in memory.
        try:
            internal_level_number = band_spin_tuples.index((band_name,spin))
            return internal_level_number
        except:
            # The level requested cannot be found.  Return None.
            return None


    def lookup_gosia_level_by_band_spin(self,band_name,spin):
        """Looks up the gosia level number of a level in memory by band name, spin.

        Nov. 11 2010: This also finds a matching pseudonym.
        If the level is not in memory, then return None.

        This now uses a faster method that gets all level keys as a list and
        finds the matching one by the index list method.

        """

        # Get the internal level number.  If it exists, return the internal number plus one (the gosia base-1 index).
        internal_level_number = self.lookup_internal_level_by_band_spin(band_name,spin)

        if not internal_level_number == None:
            return internal_level_number + 1  # base-1 gosia numbering.
        else:
            # The level cannot be found.  Return None.
            return None



    def get_branching_lines(self):
        """Provides a list of branching data as text lines in the gosia format.

        This also re-reads the branching ratio data from disk.
        """
        self.read_branching_data()

        if len(self.branching_data) > 0:
            branching_string_list = []  # the list of strings to be sent to gosia
            # First, get the branching ratios to be included (for levels
            # in the current level scheme only).
            number_of_branching_ratios = 0
            # Step through all branching data in memory, and pick out the ones that apply to this
            # level scheme.
            temporary_branching_string_list = []  # a temporary list to be prepended with the gosia NBRA,WBRA values
            for i in range(len(self.branching_data)):
                this_branching_list = self.branching_data[i]
                # Check this branching ratio to see if all three levels are in memory.
                initial_band_name, initial_spin, final_band_name_1,final_spin_1,final_band_name_2,final_spin_2,r,delta_r = this_branching_list
                # Are these levels all in the level scheme currently?
                # Look up the gosia level number.  If -1 is returned, then it doesn't exist.
                initial_gosia_level = self.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
                final_gosia_level_1 = self.lookup_gosia_level_by_band_spin(final_band_name_1,final_spin_1)
                final_gosia_level_2 = self.lookup_gosia_level_by_band_spin(final_band_name_2,final_spin_2) 
                if initial_gosia_level > 0 and final_gosia_level_1 > 0 and final_gosia_level_2 > 0:
                    # Then all three states are in memory.  Add this branching ratio to the
                    # data to be passed to gosia.
                    # Construct the line for op,yiel and increment the branching ratio
                    # number NBRA for gosia.
                    branching_line_for_gosia = str(initial_gosia_level) + "  " + str(final_gosia_level_1) + "  " + str(initial_gosia_level) + "  " + str(final_gosia_level_2) + "  " + str(r) + "  " + str(delta_r) 
                    temporary_branching_string_list.append(branching_line_for_gosia)
                    # Now increment the number of branching ratios for gosia.
                    number_of_branching_ratios = number_of_branching_ratios + 1

            # Now construct the final list for gosia.
            if number_of_branching_ratios > 0:
                header_line = str(number_of_branching_ratios) + "  " + str(self.branching_data_weight)
                branching_string_list = [header_line]
                branching_string_list.extend(temporary_branching_string_list)
                return branching_string_list
            else:
                # No branching data apply to the levels in the level scheme.
                return ["0,0"]  # This is returned as a list for compatibility with the

        else:
            # No branching data to report.  Return 0,0 for this line in gosia input.
            return ["0,0"]  # This is returned as a list for compatibility with the
                            # generate_yiel method of class experimentmanager.

    ## ***New in version -59*** ##
    def add_a_level(self,band_names = [],spin = None, parity = None, energy = None):
        """Adds a level.

        July 14 2011

        If band_names is only a string, then it is converted to a list of one
        element.  If a list of N band names is given, then the level is added
        with N pseudonyms.

        """

        # Round the spin to the nearest tenth, which will effectively make it
        # rounded to the nearest half-integer.  
        try:
            spin = round(float(spin),1)
        except:
            # The spin is not understood.  Return an error code.
            return -1

        # Check that the parity is +1 or -1.
        try:
            parity = int(parity)
        except:
            # The parity is not understood.
            return -1

        if not parity in [-1,1]:
            # The parity is not -1 or 1.  Return an error.
            return -1

        # Check that the energy is a float.  (It should be in keV).
        try:
            energy = float(energy)
        except:
            # The energy is not understood.  return an error.
            return -1

        # See if band_names is a list of strings or a string.  
        type_strings = str(type(band_names)).split("'")
        if type_strings[1] == "str":
            # This appears to be a string.  Convert it to a list of one item,
            # which should be a string.
            band_names = [band_names]

        # Add the level once using the first band name.  If there are more than
        # one band name, add pseudonyms with the same pointer to the same level
        # object.
        # First, we reverse the band names and pop off the last one, which was
        # the first name passed in.
        band_names.reverse()
        try:
            first_band_name = band_names.pop()
        except:
            # There was nothing to pop.  No band names were given.  Return an error.
            return -1

        # Everything so far has succeeded, so add the level using the first band name in the key.
        first_level_key = (first_band_name, spin)
        self.levels[first_level_key] = level(spin = spin, parity = parity, energy = energy)
        for one_band_name in band_names:
            this_level_key = (one_band_name, spin)
            # Add the pointer to the level object to the other (band_name,spin)
            # keys requested.  This effectively creates pseudonyms.
            self.levels[this_level_key] = self.levels[first_level_key]

        # If there were no exceptions to this point, then return 0 indicating no errors.
        return 0

    def add_level_pseudonym(self,old_band_name = None, spin = None, new_band_name = None):
        """This will add a band name pseudonym to the level requested.

        The level is looked up by band name (possibly one of a number of
        pseudonyms) and spin.

        If the level does not exist, then an error is returned.

        If the level exists, then the pseudonym to the level pointer is added.

        """

        # New July 2011.

        # Check that all values were passed.
        if old_band_name == None or spin == None or new_band_name == None:
            return "Can't add band pseudonym because one or more fields were not passed."

        # Find the level if it exists.
        try:
            original_level = self.levels[(old_band_name, spin)]
        except:
            # If this failed, then the original level does not exist.  Return
            # an error code.
            return "Level not found."

        # Now that the level is found, add the pseudonym to its pointer in the
        # self.levels dictionary.

        self.levels[(new_band_name,spin)] = original_level
        return 0  # No error.

    def add_bands(self,new_band_names):
        """Adds bands to the end of the list that orders them.

        This order is used to send levels in the proper order to gosia and for
        the display.

        The setting "active":True is added to all new band names.  The user can
        deactivate them as desired later.

        """

        for one_name in new_band_names:
            self.band_settings_list.append([one_name,{"active":True}])

        return 0


    def get_all_band_names(self):
        """This will get all band names *and* pseudonyms in use.

        This will be used primarily to make sure that new levels do not
        overwrite old levels.

        This will take the band names from the level dictionary, because the
        format of the self.band_settings_list may change.

        """

        all_level_keys = self.levels.keys()
        # Using set math to avoid duplicates.
        set_of_all_band_names = set([])
        for one_key in all_level_keys:
            set_of_all_band_names.add(one_key[0])
        list_of_all_band_names = list(set_of_all_band_names)
        return list_of_all_band_names 
        


class gosia_shell:
    """Manages gosia inputs and runs gosia.

    Polls the experiment manager, nucleus, detector manager objects for gosia
    input information as needed and generates a gosia input, which can be
    saved, displayed, passed to gosia, etc.  

    """

    def __init__(self):
        # Save the file name for OP,FILE generation
        self.base_file_name = "gosia"  # This is fixed for the moment.
        self.add_vac_controls = False  # Flags to skip the entry of VAC controls in the CONT block.
        self.gosia_kinematics_state = None   # The state number for calculation of scattering kinematics.
        # Must make a deep copy of the default dictionary.  Otherwise,
        # changes to one dictionary will update the other!
        self.minimization_parameter_dict = copy.deepcopy(DEFAULTMINIMIZATIONPARAMETERDICT)
        self.saved_user_experiments = False
        self.saved_user_nucleus = False
        # The following four weights are new in version 2.0.0 beta.
        self.lifetime_weight = 1.      
        self.branching_weight = 1.
        self.matrix_element_weight = 1.
        self.mixing_ratio_weight = 1.
        self.number_of_magnetic_substates = DEFAULT_MAGNETIC_SUBSTATES 
        self.number_of_magnetic_substates_for_minimization = 1
        self.vac_control_dict = {}  # An empty dict until the user enters non-default values.

    def kill_gosia(self,signal_arg_1,signal_arg_2):
        """Kills the gosia run if it is still running.

        """

        print "\nSignal ", signal_arg_1

        try:
            self.current_gosia_process
        except:
            # No process has been defined yet.
            return -1

        # See if Gosia is running.  
        poll_value = self.current_gosia_process.poll()
        if poll_value == None:
            # The process is still running.
            print "KILLING Gosia...",
            self.current_gosia_process.kill()
            print "killed."
            return -1


    def for_upgrade(self,restored_version):
        """Sets new variables as appropriate for an upgrade from

        version restored_version to present VERSION.

        """

        total_errors = 0
        return_text = []

        if restored_version in []:
            # Add to the list above to select for upgrades by session file's version number.
            try:

                # Add to the commands here to upgrade the object of this class.

                success_string = "Gosia shell data successfully upgraded to version " + str(VERSION) + "."
                return_text.extend(textwrap.wrap(success_string,TEXTVIEW_COLUMNS))
            except:
                total_errors += 1
                return_text.extend(textwrap.wrap("Could not update the nuclear data weighting."))
            
            # Examples of syntactically correct error codes are below.
            #total_errors += 1
            #return_text.extend(textwrap.wrap("ipsum lorem blah blah blah",TEXTVIEW_COLUMNS))
        else:
            # No upgrade necessary.
            pass

        return total_errors,return_text

    def user_set_data_weights(self):
        """Allows the user to set weights on all data (under construction).

        """

        while True:
            current_branching_weight = self.get_branching_weight()
            current_mixing_weight    = self.get_mixing_ratio_weight()
            current_matrix_weight    = self.get_matrix_element_weight()
            current_lifetime_weight  = self.get_lifetime_weight()
            print "Current weights:"
            print "---------------------------------------------"
            print "Measured branching ratio data      ",current_branching_weight 
            print "Measured mixing ratio data         ",current_mixing_weight    
            print "Measured matrix element data       ",current_matrix_weight    
            print "Measured lifetime data             ",current_lifetime_weight  
            print ""
            print "Enter 'q' to quit."
            try:
                prompt_string = "New branching ratio weight: "
                weight = prompt_number(prompt_string,"f")
                if not weight == "quit":
                    new_weight = max(0.,weight)
                    new_weight = min(1.,new_weight)
                    self.branching_weight = new_weight
                else:
                    break

                prompt_string = "New mixing ratio weight: "
                weight = prompt_number(prompt_string,"f")
                if not weight == "quit":
                    new_weight = max(0.,weight)
                    new_weight = min(1.,new_weight)
                    self.mixing_ratio_weight = new_weight
                else:
                    break

                prompt_string = "New measured matrix element weight: "
                weight = prompt_number(prompt_string,"f")
                if not weight == "quit":
                    new_weight = max(0.,weight)
                    new_weight = min(1.,new_weight)
                    self.matrix_element_weight = new_weight
                else:
                    break

                prompt_string = "New measured lifetime weight: "
                weight = prompt_number(prompt_string,"f")
                if not weight == "quit":
                    new_weight = max(0.,weight)
                    new_weight = min(1.,new_weight)
                    self.lifetime_weight = new_weight
                else:
                    break

            except:
                print "Quitting."
                return -1

    def set_number_of_magnetic_substates(self):

        finished = False
        while not finished:
            new_number_of_substates = prompt_number("Enter the number of magnetic substates for all experiments (1--8): ","i")
            if new_number_of_substates == "quit":
                finished = True
            else:
                if new_number_of_substates <= 8 and new_number_of_substates >= 1:
                    self.number_of_magnetic_substates = new_number_of_substates 
                    print "Now using ",self.number_of_magnetic_substates, " for all experiments."
                    finished = True
                else:
                    print "You must use 1--8 substates."

        return 0

    def get_number_of_magnetic_substates(self):
        return self.number_of_magnetic_substates

    def get_number_of_magnetic_substates_for_minimization(self):
        return self.number_of_magnetic_substates_for_minimization

    def get_mixing_ratio_weight(self):
        """Returns a float: the weight to be given to mixing ratio data

        in the chi-squared fit.  

        """

        return self.mixing_ratio_weight

    def get_matrix_element_weight(self):
        """Returns a float: 
        
        the weight to be given to previously-measured matrix element data in
        the chi-squared fit.  

        """

        return self.matrix_element_weight

    def get_lifetime_weight(self):
        """Returns a float: the weight to be given to lifetime data

        in the chi-squared fit.  

        """

        return self.lifetime_weight

    def get_branching_weight(self):
        """Returns a float: the weight to be given to branching data

        in the chi-squared fit.  

        """

        return self.branching_weight

    def get_excited_state_data(self):
        """Runs a fast point calculation to find which states are excited

        This calculation is based on the current nuclear and experimental
        definitions.

        It also stores information on which states have a finite lifetime.

        Since this pertains to both nuclear data and experimental conditions
        (which states can be excited in which experiments to a finite
        probability), there is a choice of where to store it--in the nucleus
        object (but with references to the experiment, detector), or in the
        gosia shell (but with references to the investigated nucleus's level
        numbers).  For now, it is being stored in the gosia_shell object.

        """

        # Call OP,POIN to find populated levels and then store excited state,
        # lifetime data in the gosia shell object (this object).  Since this
        # could change at any time, the data will be re-generated at each call
        # to gosia to determine what yield and nuclear data to pass to gosia
        # for the full calculation.

        # Call the methods to run a point calculation.
        print "  Evaluating states for coupling to the ground state...\n  ",
        error_code = self.generate("Point yields","Run gosia input",False,True,False,{},True)   # Run silently.  Final "True" overrides settings to make NCM=1.
        if error_code == -1:
            print "Gosia killed by user or cannot run Gosia.  Check for errors above."
            return -1
        # Syntax: generate(self,function,action,tf=False,silent=False,release_for_correlated_errors=True,output_options = {},evaluation_only=False)
        print "  Done.\n  ",

        # Parse the output of the point calculation to get the excited state
        # and lifetime data.
        print "  Collecting excited-state and calculated lifetime data...\n  ",
        the_experiment_manager.parse_gosia_integrated_yields(False,True)
        # Syntax: parse_gosia_integrated_yields(self,tf=False,evaluate=False)
        print "  Done.\n    ",

        # Update the level scheme window to show the coupled states.
        investigated_nucleus.draw_level_scheme()


    def print_minimization_parameters(self,short_form=False):
        """Prints a nicely formatted list of the available parameters.

        Prints in the order listed in the Gosia manual, which takes some
        sorting, since dictionary keys do not list in the order they were
        entered.

        """

        output_list = []
        default_dict_copy = copy.deepcopy(DEFAULTMINIMIZATIONPARAMETERDICT)  # Make a deep copy, so that the DEFA...DICT is not altered below.

        for one_key in self.minimization_parameter_dict.keys():
            current_value = self.minimization_parameter_dict[one_key][0]
            description = self.minimization_parameter_dict[one_key][1]
            sort_order  = default_dict_copy[one_key][2]
            default_value = default_dict_copy[one_key][0]
            output_list.append([sort_order,one_key,current_value,default_value,description])

        output_list.sort()
        print "Minimization parameters:"
        print "--------------------------------------------------------------------------------"
        for one_entry in output_list:
            print str(one_entry[0]).rjust(2), "  ",one_entry[1].ljust(23),"Current: ",str(one_entry[2]).ljust(8)," Default: ",str(one_entry[3])
            if not short_form:
                block_print_with_line_breaks(one_entry[4])
                print ""

        return 0


    def set_minimization_parameters(self,parameter_name,new_value):
        """This method does not check values. 

        See the set...interactive method.

        """
        values_list = self.minimization_parameter_dict[parameter_name]
        values_list[0] = new_value
        self.minimization_parameter_dict[parameter_name] = values_list
        return 0


    def set_minimization_parameters_interactive(self):
        """Interactively sets minimization parameters.

        """
        self.print_minimization_parameters()

        if yes_no_prompt("Revert to default parameters [y/N]? ",False):
            # Must make a deep copy of the default dictionary.  Otherwise,
            # changes to one dictionary will update the other!
            self.minimization_parameter_dict = copy.deepcopy(DEFAULTMINIMIZATIONPARAMETERDICT)
            self.print_minimization_parameters(True)
            print "Reverted to default parameters."
            print "Done."
            return 0

        # Construct a temporary dictionary to lookup parameters by number.
        number_to_name_dict = {}
        for item in self.minimization_parameter_dict.keys():
            parameter_number = self.minimization_parameter_dict[item][2]
            number_to_name_dict[parameter_number] = item

        while True:
            try:
                parameter_number = int(raw_input("Enter number of parameter to change or return to quit: "))
            except:
                # User hit return to quit (or typed a non-numeric character).
                self.print_minimization_parameters(True)
                print "Done."
                return -1

            # User entered a parameter number.  Find it in the number-->name
            # dictionary, and allow the user to change it.
            parameter_name = number_to_name_dict[parameter_number]
            values_list = self.minimization_parameter_dict[parameter_name]
            # Check what type (boolean, int or float) is required.
            required_type = values_list[3]
            if required_type == "boolean":
                try:
                    new_value = eval(raw_input("Enter True or False: ").title())
                    self.set_minimization_parameters(parameter_name,new_value)
                except:
                    print "Invalid entry.  Must be \"True\" or \"False\"."
            else:
                # Suggest a range of values to the user.
                lower_limit = values_list[4]
                upper_limit = values_list[5]
                if required_type == "integer":
                    prompt_string = "Enter an integer between " + str(lower_limit) + " and " + str(upper_limit) + ": "
                    try:
                        new_value = int(raw_input(prompt_string))
                        if new_value <= upper_limit and new_value >= lower_limit:
                            self.set_minimization_parameters(parameter_name,new_value)
                        else:
                            print "Value not in range."
                    except:
                        print "Invalid entry.  Must be an integer."
                elif required_type == "float":
                    prompt_string = "Enter a float between " + str(lower_limit) + " and " + str(upper_limit) + ": "
                    try:
                        new_value = float(raw_input(prompt_string))
                        if new_value <= upper_limit and new_value >= lower_limit:
                            self.set_minimization_parameters(parameter_name,new_value)
                        else:
                            print "Value not in range."
                    except:
                        print "Invalid entry.  Must be a float."

        return 0

    def set_gosia_kinematics_state(self,silent=False,gosia_level_number=2):
        """Interactive. Sets the kinematics gosia state number in the gosia_shell object.

        """

        if silent:
            self.gosia_kinematics_state = gosia_level_number
            return 0

        else:
            
            band_number = prompt_number("Band NUMBER of new kinematics state: ","i")
            if band_number == "quit":
                return 0
            spin        = prompt_number("Spin: ","r")
            if spin == "quit":
                return 0

            primary_band_name = investigated_nucleus.get_primary_band_name_from_band_number(band_number)
            level_key = (primary_band_name,spin)
            gosia_level_number = investigated_nucleus.get_level_information(level_key,"internal_level_number") + 1
            if not gosia_level_number == None:
                self.gosia_kinematics_state = gosia_level_number
                return 0
            else:
                print "State not found.  Cancelled."
                return -1

    def return_kinematics_state_data(self):
        """Returns a list of [band_name,spin,level_energy] of the kinematics state

        """

        if self.gosia_kinematics_state == None:
            # Output the gosia default (as in the 2010 manual CONT section "NCM")
            gosia_level_number = 2
        else:
            # Output the current setting.
            gosia_level_number = self.gosia_kinematics_state

        band_name, spin = investigated_nucleus.get_band_and_spin_from_gosia_level_number(gosia_level_number)
        energy          = investigated_nucleus.get_level_information((band_name,spin),"energy")

        return [band_name,spin,energy]

    def print_kinematics_state(self):
        """Prints the state for the calculation of kinematics.

        """


        if self.gosia_kinematics_state == None:
            # Output the gosia default (as in the 2010 manual CONT section "NCM")
            gosia_level_number = 2
            print "(*Default* setting)"
        else:
            # Output the current setting.
            gosia_level_number = self.gosia_kinematics_state

        band_name, spin = investigated_nucleus.get_band_and_spin_from_gosia_level_number(gosia_level_number)

        print "Band \"",band_name,"\", spin ",spin

        return 0


    def get_base_file_name(self):
        """Returns the base file name without extension.

        """
        return self.base_file_name

    def use_default_vac_values(self):
        """Sets a flag to skip the VAC controls in the CONT block.

        """

        self.add_vac_controls = False

    def print_vac_parameters(self):
        """Prints the current vacuum parameters.

        """

        print "The deorientation effect can be turned off by specifying"
        print "  Lambda = 0. and K = 0."
        print "Refer to the Gosia manual entry for VAC, in the CONT section."
        print "Default values are:"
        print "J1     = 3"
        print "Gamma  = 0.02 ps^-1"
        print "Lambda = 0.0345 ps^-1"
        print "tau_c  = 3.5 ps"
        print "g      = Z/A"
        print "K      = 6.0E-06"
        print "x      = 0.6"

        print "Current user settings:"
        for one_parameter_number in VAC_PARAMETER_NUMBER_DICT.keys():
            one_parameter_name = VAC_PARAMETER_NUMBER_DICT[one_parameter_number]
            print one_parameter_name + ": ",
            if one_parameter_name in self.vac_control_dict.keys():
                parameter_value = self.vac_control_dict[one_parameter_name]
                print parameter_value
            else:
                print "default"


    def set_vac_parameters(self,parameter_dict):
        """Sets the vacuum depolarization (deorientation) g-factor from g-factor passed in.


        """

        # Set the flag to use the user's vac parameters.
        self.add_vac_controls     = True
        
        # Save the parameter dict for generating the VAC, entries.
        self.vac_control_dict = parameter_dict

        return 0
        

    def generate(self,function,action,tf=False,silent=False,release_for_correlated_errors=True,output_options = {},evaluation_only=False,amplitudes=False,file_extension_substitution_dict = {},make_dummy_cor_file=True):
        """Generates a gosia input for the requested function and runs it if requested.

        output_options is a dictionary of extra output options, some of which
        may be mutually exclusive, such as "collision function" and
        "amplitudes".

        The function would be one of
        "Integrated yields" (OP,INTG)
        "Make corrected yields" (OP,CORR)
        "Fit" (OP,MINI)
        "Make Ge det file" (OP,GDET)
        etc.
        
        The action specifies whether to return the gosia input file as text,
        run it, save it, etc.
       
        For now, it puts all files that may or may not be used in OP,FILE.
        This can be optimized later to avoid empty files.

        Added flag "evaluation_only".  If this is True, then the NCM state is
        set to 0 to avoid possible crashes of Gosia in inverse kinematics
        cases.  

        Now the YNRM normalization constants are updated for every call, since
        the user could have changed the NCM kinematics state.  This obviates
        the "Estimate normalizations" function in the Gosia Function pull-down.

        """


        # First, check for setup problems that will cause Gosia to crash.
        error_code = the_experiment_manager.check_for_problems()
        if error_code == -1:
            return -1
        error_code = investigated_nucleus.check_for_problems()
        if error_code == -1:
            return -1

        # Calculate new normalization constants for all experiments every time
        # Gosia is called, in case the user changed the level scheme or the
        # kinematics (NCM) state.
        the_experiment_manager.calculate_ynrm_constants(silent=silent)

        if not silent:
            print "Selected function: ",function
            print "Generating gosia input...  "

            # This calls a method to update a list of sets of states for which
            # nuclear & yield data should be included.  Note that this method
            # calls another execution of the present method to evaluate the
            # excited state data.
            #
            # Do not attempt to update the excited state data if a correlated
            # error (two-step) calculation is in progress.

            if function == "Integrated yields" or function == "Make simulated yields" or \
              function == "Fit" or function == "Make corrected yields" or \
              function == "Point yields":

                self.get_excited_state_data()


        if function == "Integrated yields" or function == "Make simulated yields":
            full_gosia_input = self.op_intg_input() 
        elif function == "Map":
            # The file name substitution dict is used when op,map is called for the deorientation calculation.
            full_gosia_input = self.op_mini_input(do_map_instead=True,file_name_substitution_dict=file_extension_substitution_dict)
        elif function == "Fit":
            full_gosia_input = self.op_mini_input()
        elif function == "Deorientation coeff.":
            full_gosia_input = self.vacuum_depolarization_input(DEORIENTATION_FILE_DEF_DICT)
        elif function == "Calculate lifetimes":
            full_gosia_input = self.lifetimes_input()
        elif function == "Make corrected yields":
            full_gosia_input = self.op_intg_input("corr")  
        elif function == "Make Ge det file":
            full_gosia_input = self.op_gdet_input()
        elif function == "Point yields":
            if evaluation_only:
                # Make sure that NCM is temporarily set to state 1 (gosia
                # numbering) so that crashes can be avoided in inverse
                # kinematics when only the couplings are being evaluated.
                full_gosia_input = self.op_poin_input(ncm_override=True)
            elif make_dummy_cor_file:
                # Use op,poin to put yields into a dummy cor file, not the
                # default file.  (Don't want to overwrite real data.)
                full_gosia_input = self.op_poin_input(ncm_override=True,IFL=1,file_extension_substitution_dict=file_extension_substitution_dict,YLIM=1.e-6)
            else:
                # Pass on whether or not to write out the a(w) amplitude data.
                full_gosia_input = self.op_poin_input(amplitudes=amplitudes)
        elif function == "Start":
            full_gosia_input = self.op_star_input(output_options)
        elif function == "Diagonal errors":
            full_gosia_input = self.op_erro_diag_input(release_for_correlated_errors)
        elif function == "Correlated errors":
            full_gosia_input = self.op_erro_corr_input(release_for_correlated_errors)

        if full_gosia_input == -1:
            # An error message should have been printed already.  Cease further operations.
            return -1

        if action == "View gosia input":
            # Return the input to the gui to display. 
            return full_gosia_input
        elif action == "Run gosia input":

            # Write the gosia input to a file and run it.
            gosia_input_file_name = self.base_file_name + ".inp"
            gosia_output_file_name = self.base_file_name + ".out"
            write_lines_to_file(gosia_input_file_name,full_gosia_input,force=True)

            # Run the calculation
            command_line = GLOBAL_SETUP_DICT["GOSIA_EXECUTABLE"] + " < " + gosia_input_file_name + " > rachel_temp_file"
            if DEBUGGING_MODE or function == "Fit":
                command_line = GLOBAL_SETUP_DICT["GOSIA_EXECUTABLE"] + " < " + gosia_input_file_name 
            if not silent:
                if function == "Integrated yields" or function == "Make corrected yields" or function == "Fit" or \
                  function == "[Diagonal errors]" or function == "Correlated errors" or function == "Make simulated yields":
                    print "For many experiments or large level schemes, this may take some time."
                else:
                    print ""
            print "Running gosia.  Press CTRL-C to abort."
            time_stamp = get_system_time_stamp().strip('\n')
            if not silent:
                print "Process started at ", time_stamp
            sys.stdout.flush()

            # Run Gosia in a way that will allow the user to send a break signal for runaway calculations.
            # Set the signal handler to call kill_gosia in case of a break.
            signal.signal(signal.SIGINT,self.kill_gosia)
            self.current_gosia_process = subprocess.Popen(command_line,shell=True)

            if function == "Fit":
                print "=================================="
                print "=GOSIA OUTPUT TO TERMINAL FOLLOWS="
                print "=================================="
            else:
                print "|",
                
            sys.stdout.flush()
            while self.current_gosia_process.poll() == None:
                # Gosia is still running...
                # If the call did not specify silent output, print a progress bar.
                for seconds in range(60):
                    # Check every second to see whether Gosia is still running.
                    if not self.current_gosia_process.poll() == None:
                        break
                    time.sleep(1)
                # Print a dot every minute.
                if not silent and not function == "Fit":
                    print "-",
                    sys.stdout.flush()

            # Turn off CTRL-C again.
            ignore_break()

            # Check that Gosia executed without being killed.  If it was
            # killed, then the poll_value from the subprocess will be something
            # other than 0.  In this case, we quit processing.
            poll_value = self.current_gosia_process.poll()
            if not poll_value == 0:
                print "Gosia was killed.  Processing cannot continue."
                return -1
            else:
                print "> |"

            time_stamp = get_system_time_stamp().strip('\n')
            if not silent:
                print "Completed at ",time_stamp
                print "Done."

            # Read the output file, and check for errors.
            with open(gosia_output_file_name,'r') as gosia_output_file:
                gosia_output = gosia_output_file.readlines()

            # For now, since the correlated error output can give accurate
            # values, but still report overflowed values of chi-squared, the
            # error check is not done for correlated errors.
            # Same for the deor. coeff's, where we do a phoney fit command.

            if not function == "Correlated errors" and not function == "Deorientation coeff.":
                error_code = check_for_gosia_error(gosia_output)
            else:
                error_code = 0

            if error_code == -1:
                # This looks like a fatal error.
                if not silent:
                    print time_stamp, "...",
                    print "\nProcessing cannot continue properly due to the error above.\n"
                return error_code

            # If this was an op,gdet run, then call the_detector_manager to see if 
            # file 9 needs modification (e.g. for 4pi arrays).
            if function == "Make Ge det file":
                the_detector_manager.retouch_gdt_file()


            # Pass back the standard output from rachel_temp_file to the textview.
            with open("rachel_temp_file",'r') as std_out:
                std_output = std_out.readlines()

            # Read the output file.
            with open(gosia_output_file_name,'r') as gosia_output_file:
                gosia_output = gosia_output_file.readlines()


            # If this was a minimization, then store the final
            # chi-squared value in the output file.
            if function == "Fit":
                self.read_final_chi_squared_from_gosia()
                chi_squared_info = self.return_final_chi_squared()
                chisq, reason_string = chi_squared_info
                reason_string = reason_string.strip("\n")
                if not silent:
                    print "Final reduced chi-squared from the fit was ",chisq
                    print "after terminating the fit because "
                    print reason_string
                # Make a log entry about the fit result.
                investigated_nucleus.notes.append_log("procedure_log","Gosia fit. Chi-squared = " + str(chisq) + ".\n    Fit terminated because: " + reason_string)
                

            full_output = std_output + gosia_output

            # If integrated yields were calculated, store the calculated yields in memory.
            if function == "Point yields":
                if evaluation_only:
                    # Set second flag to True to tell the parse... method not
                    # to save the calculated yields.  This is a bug fix--this
                    # had been overwriting integrated yields with point yields
                    # during the calculation to evaluate the excited states.
                    self.all_integrated_yields = the_experiment_manager.parse_gosia_integrated_yields(tf,True) # tf=True means to accept a lower limit for tf calcs.
                else:
                    # If this method was not called for evaluation of excited
                    # states only, then the point yields should be stored.
                    self.all_integrated_yields = the_experiment_manager.parse_gosia_integrated_yields(tf) # tf=True means to accept a lower limit for tf calcs.
               
            elif function == "Integrated yields":
                self.all_integrated_yields = the_experiment_manager.parse_gosia_integrated_yields()
                if not silent:
                    print "\nCalculated yields should now be stored in the GUI memory.  Check for errors above.\n"

            elif function == "Deorientation coeff.":
                # Just parse the output and print a table of G-factors.
                the_experiment_manager.parse_deorientation_coefficients(lifetimes = True, deorientation = True)

            elif function == "Calculate lifetimes":
                the_experiment_manager.parse_deorientation_coefficients(lifetimes = True, deorientation = False)

            elif function == "Make simulated yields":
                # If the function was to make simulated yields, then save yields 
                # to a yield (*.yld) file and read into GUI memory, if the user chooses.
                self.all_integrated_yields = the_experiment_manager.parse_gosia_integrated_yields()
                print "Calculated yields are stored in the GUI memory now."
                print "\nAnswering \"no\" to the save prompt will NOT update the experimental yields in memory!\n"
                save_simulated_yields = yes_no_prompt("Save simulated yields as experimental data in .yld file and in GUI memory [Y/n]? ",True)
                if save_simulated_yields:
                    # The line below saves the yields to the .yld file.
                    # The following line was added as a bug-fix on June 9 2011.
                    the_experiment_manager.write_simulated_yld_file(save_simulated_yields)
                    # Read them back from the gosia yield file.  Doing it this
                    # way ensures that the experimental yields in memory are
                    # the same as what gosia gets for a fit.
                    the_experiment_manager.read_experimental_yields()
            return full_output


        elif action == "Save gosia input":
            # Write the gosia input to a file.
            gosia_input_file_name = self.base_file_name + ".inp"
            write_lines_to_file(gosia_input_file_name,full_gosia_input,force=True)
            return full_gosia_input


    def op_file_header(self,substitution_dict={}):
        """Generate the text lines for OP,FILE and return as a list of strings

        No \n termination here.
        The file def dict has the appropriate file extensions, status and format numbers,
        keyed by file number.  See the header definitions.

        Each file name specified in the substitution dict will replace the
        default file, or add the file name and number to OP,FILE, if it is not
        in the defaults.

        The dict format must be:
            {99:{"extension":"amp","status":"3","format":1}, 89:{"extension":"jnk","status":"3","format":1}...}

        """

        # Copy the default dict (deepcopy so that we don't change it permanently).
        local_file_def_dict = copy.deepcopy(FILE_DEF_DICT)
        # Add or substitue each file number in the user's substitution dict.
        # The file number is the file number.  See the global defs at the top of rachel.py.
        for one_key in substitution_dict:
            local_file_def_dict[one_key] = copy.deepcopy(substitution_dict[one_key])
        # Check the substitution dict.
        # Begin the output string list:
        op_file_strings = ["OP,FILE"]
        file_number_keys = local_file_def_dict.keys()
        file_number_keys.sort()
        for file_number in file_number_keys:
            file_def = local_file_def_dict[file_number]  # This is a dict itself to look up extension, status, format
            full_file_name = self.base_file_name + "." + file_def["extension"]
            file_number_string = str(file_number)
            status_string = str(file_def["status"])
            format_string = str(file_def["format"])
            file_numbers_line = file_number_string + "," + status_string + "," + format_string
            # append the file info into the op file list
            op_file_strings.extend([file_numbers_line,full_file_name])
                         
        # Finish op,file with the 0,0,0 termination code
        op_file_strings.append("0,0,0")
        return op_file_strings


    def op_gdet_input(self):
        """Generate an OP,GDET input for gosia.

        Gets the main op,gdet lines from a detectormanager object.
        """
        # Need an op,file header
        op_file_lines = self.op_file_header()

        # Get the op,gdet lines from the detectormanager object.
        op_gdet_lines = the_detector_manager.generate_op_gdet()

        # Put the input together.
        full_input_lines = op_file_lines
        full_input_lines.extend(op_gdet_lines)
        full_input_lines.extend(["OP,EXIT"," "])

        return full_input_lines

    def generate_cont_lines(self,extra_options = None,extra_controls = None,silent=False):
        """Generates the CONTrol block lines.

        Adds print options in extra_options, if any are requested.
        extra_options = ["9,1","10,1"...]

        Extra controls (other than printing) can be sent in a list similarly in
        extra_controls.

        The maximum allowed Q-value (least upper bound) is calculated here to
        change NCM to the ground state if necessary.

        """

        cont_lines = ["CONT"]
        number_of_experiments = the_experiment_manager.getnumberofexperiments()
        int_string = "INT,"+ str(number_of_experiments) + "."
        cont_lines.append(int_string)
        for i in range(number_of_experiments):
            accuracy_line = str(i+1) + ",1000"
            cont_lines.append(accuracy_line)

        if not (extra_controls == None):
            cont_lines.extend(extra_controls)

        cont_lines.extend(["SPL,1.",\
                          "PRT,",\
                          "1,-1",\
                          "2,0",\
                          "4,0",\
                          "5,1",\
                          "11,0",\
                          "12,0",\
                          "14,0",\
                          "15,1",\
                          "16,0"])

        # Add extra options if they were passed in.
        if not extra_options == None:
            cont_lines.extend(extra_options)
        else:
            cont_lines.extend(["9,99999"])  # This turns off the collision function output that I accidentally defaulted to print in Gosia.

        cont_lines.append("0,0")

        if self.add_vac_controls:
            # Add the user's specified vacuum depolarization option(s).
            cont_lines.append("VAC,")
            for one_parameter_number in VAC_PARAMETER_NUMBER_DICT.keys():
                one_parameter_name = VAC_PARAMETER_NUMBER_DICT[one_parameter_number]
                if one_parameter_name in self.vac_control_dict.keys():
                    parameter_value = self.vac_control_dict[one_parameter_name]
                    parameter_line = str(one_parameter_number) + ","+str(parameter_value)
                    cont_lines.append(parameter_line)
            cont_lines.append("0,0.")

        # Add the excited state for kinematics calculation, if it is set, or if
        # it must be the ground state for one or more experiments, because the
        # exit energy is too low for the Q-value of an excited state.
        # 
        # For a stopped (or nearly stopped) beam, the Q-value needs to be zero.
        # This is equivalent to setting the NCM flag to 1.
        # In general, need to set the Q-value low enough that it can be excited at the exit energy.
        current_Q_value = the_gosia_shell.return_kinematics_state_data()[2]  # In KEV!
        # Step through all experiments to get the minimum Q-value of all from each exit energy.
        maximum_Q_values = []
        for one_experiment in the_experiment_manager.allexperiments:
            # Get the maximum Q-value for this experiment.
            this_maximum_Q_value = one_experiment.get_maximum_possible_Q_value()
            maximum_Q_values.append(this_maximum_Q_value)
        the_maximum_Q_value = min(maximum_Q_values)  # The LOWEST maximum!
            
        # Arbitrary 100 keV maximum difference until full inelastic max Q-value calculation is ready.
        if (the_maximum_Q_value - current_Q_value) < 100.0:    # keV
            # We don't try to set any level number other than the ground state.
            # The user must make an intelligent choice if she doesn't want the
            # ground state set here.
            the_gosia_shell.set_gosia_kinematics_state(silent=True,gosia_level_number=1)
            if not silent:
                print "  The maximum possible excitation energy (Q-value) for all experiments is ",the_maximum_Q_value, "keV."
                print "    This is defined by the beam energy and the energy loss in the target."
                print "    The energy of the final state chosen for kinematics calculations"
                print "    is too high."
                print "    The scattering kinematics state has been reset to the ground state."
                print "    You can change this using the \"Gosia controls\" button.  "
                print "    Be sure to choose a state with an excitation energy <=",the_maximum_Q_value, "."

        if not self.gosia_kinematics_state == None:
            kinematics_state_line = "NCM," + str(self.gosia_kinematics_state) + "."
            cont_lines.append(kinematics_state_line)

        # Append the END, marker and a blank line required by gosia in the input.
        cont_lines.extend(["END, ","     "])   # The last is the required blank line after END,

        return cont_lines

    def op_star_input(self,output_options = {}):
            """Generate an OP,STAR input
            
            Poll the nucleus for level scheme information, the experiment
            manager for experiment info, etc., for gosia.

            See method "generate" for information on output options.

            """

            # Need an op,file header
            op_file_lines = self.op_file_header()

            # Get the nucleus information
            level_scheme_lines = investigated_nucleus.generate_gosia_input()

            # Get the EXPT section 
            expt_lines = the_experiment_manager.generate_expt()

            # Get the CONT block
            if "amplitudes" in output_options.keys():
                if output_options["amplitudes"]:
                    extra_options = ["9,11"]  # output of a(omega)
            elif "collision function" in output_options.keys():
                if output_options["collision function"]:
                    multipole_flag = -1 * output_options["collision function"]
                    print_option_string = "9," + str(multipole_flag)
                    extra_options = [print_option_string]  # output of Q(omega)

            # Get the EXPT section 
            expt_lines = the_experiment_manager.generate_expt()

            # Control block
            cont_lines = self.generate_cont_lines(extra_options)

            # Generate OP,BRIC
            bric_lines = ["OP,BRIC",\
                          GLOBAL_SETUP_DICT["BRICC_IDX_FILE"],\
                          GLOBAL_SETUP_DICT["BRICC_ICC_FILE"]]


            # Generate OP,YIEL
            # This requires polling the detector manager as well.
            yiel_lines = the_experiment_manager.generate_yiel("intg")
            if "Error" in yiel_lines[0]:
                return -1

            # Put together the full input
            full_gosia_input = op_file_lines
            full_gosia_input.extend(level_scheme_lines)
            full_gosia_input.extend(expt_lines)
            full_gosia_input.extend(cont_lines)
            full_gosia_input.extend(bric_lines)
            full_gosia_input.extend(yiel_lines)

            # Put on the op,poin command.
            op_poin_lines = ["OP,STAR"]
            full_gosia_input.extend(op_poin_lines)

            # Put an op,exit on the end and a blank line to finish.
            full_gosia_input.extend(["OP,EXIT"," "])

            return full_gosia_input
            
    def op_poin_input(self,ncm_override=False,amplitudes=False,IFL=0,file_extension_substitution_dict={},YLIM=0):
            """Generate an OP,POIN input
            
            Poll the nucleus for level scheme information, the experiment
            manager for experiment info, etc., for gosia.

            Added a flag ncm_override, which sets the NCM state to 1.  This is
            used now only by the methods to evaluate couplings of states, and
            NCM=1 avoids errors in inverse kinematics cases.

            """

            # Need an op,file header
            op_file_lines = self.op_file_header(file_extension_substitution_dict)

            # Get the nucleus information
            level_scheme_lines = investigated_nucleus.generate_gosia_input()

            # Get the EXPT section 
            expt_lines = the_experiment_manager.generate_expt()

            # Get the CONT block
            if amplitudes:
                # Tell Gosia to write out the a(w) amplitude data.
                extra_options = ["9,11"]  # output of a(omega)
            else:
                extra_options = ["9,99999"]  # I accidentally defaulted to output a collision function in Gosia.  This turns it off.
            if ncm_override:
                extra_controls = ["NCM,1."]
            else:
                extra_controls = None
            cont_lines = self.generate_cont_lines(extra_options,extra_controls)

            # Generate OP,BRIC
            bric_lines = ["OP,BRIC",\
                          GLOBAL_SETUP_DICT["BRICC_IDX_FILE"],\
                          GLOBAL_SETUP_DICT["BRICC_ICC_FILE"]]


            # Generate OP,YIEL
            # This requires polling the detector manager as well.
            yiel_lines = the_experiment_manager.generate_yiel("intg")
            if "Error" in yiel_lines[0]:
                return -1

            # Put together the full input
            full_gosia_input = op_file_lines
            full_gosia_input.extend(level_scheme_lines)
            full_gosia_input.extend(expt_lines)
            full_gosia_input.extend(cont_lines)
            full_gosia_input.extend(bric_lines)
            full_gosia_input.extend(yiel_lines)

            # Put on the op,poin command.  Normally, the second argument would
            # be zero, and the lower yield limit would be irrelevant.  If we
            # are making a .cor file, we need to tell Gosia to write it.  See
            # IFL and YLIM in the OP,POIN section of the manual.
            arguments_line = str(IFL) + ", " + str(YLIM)
            op_poin_lines = ["OP,POIN",arguments_line]
            full_gosia_input.extend(op_poin_lines)

            # Put an op,exit on the end and a blank line to finish.
            full_gosia_input.extend(["OP,EXIT"," "])

            return full_gosia_input
            

    def op_intg_input(self,op_corr=False):
            """Generate an OP,INTG input
            
            Poll the nucleus for level scheme information, the experiment
            manager for experiment info, etc., for gosia.

            If op_corr is set to True, then it will tell the yield lines generator
            to pick the appropriate settings and also add OP,CORR after OP,INTG.
            """

            # Need an op,file header
            op_file_lines = self.op_file_header()

            # Get the nucleus information
            level_scheme_lines = investigated_nucleus.generate_gosia_input()

            # Get the EXPT section 
            expt_lines = the_experiment_manager.generate_expt()

            # Get the CONT block
            cont_lines = self.generate_cont_lines()

            # Generate OP,BRIC
            bric_lines = ["OP,BRIC",\
                          GLOBAL_SETUP_DICT["BRICC_IDX_FILE"],\
                          GLOBAL_SETUP_DICT["BRICC_ICC_FILE"]]


            # Generate OP,YIEL
            # This requires polling the detector manager as well.
            if op_corr:
                yiel_lines = the_experiment_manager.generate_yiel("corr")
                if "Error" in yiel_lines[0]:
                    return -1
            else:
                yiel_lines = the_experiment_manager.generate_yiel("intg")
                if "Error" in yiel_lines[0]:
                    return -1

            # Generate the OP,INTG section
            intg_lines = the_experiment_manager.generate_intg()

            # Put together the full input
            full_gosia_input = op_file_lines
            full_gosia_input.extend(level_scheme_lines)
            full_gosia_input.extend(expt_lines)
            full_gosia_input.extend(cont_lines)
            full_gosia_input.extend(bric_lines)
            full_gosia_input.extend(yiel_lines)
            full_gosia_input.extend(intg_lines)

            # If this is for OP,CORR, then put in the OP,CORR line.
            if op_corr:
                full_gosia_input.append("OP,CORR")

            # Put an op,exit on the end and a blank line to finish.
            full_gosia_input.extend(["OP,EXIT"," "])

            return full_gosia_input
            
    def op_mini_input(self,do_map_instead=False,file_name_substitution_dict={}):
            """Generates OP,MINI *or* OP,MAP input.

            If do_map_instead is set to True, then an OP,MAP input is generated
            instead.

            """

            # Poll the nucleus for level scheme information, the experiment
            # manager for experiment info, etc., and generate an OP,MINI input
            # for gosia.

            # Need an op,file header
            op_file_lines = self.op_file_header(file_name_substitution_dict)

            # Get the nucleus information
            level_scheme_lines = investigated_nucleus.generate_gosia_input()

            # Get the EXPT section 
            expt_lines = the_experiment_manager.generate_expt()

            # Get the CONT block
            cont_lines = self.generate_cont_lines()

            # Generate OP,BRIC
            bric_lines = ["OP,BRIC",\
                          GLOBAL_SETUP_DICT["BRICC_IDX_FILE"],\
                          GLOBAL_SETUP_DICT["BRICC_ICC_FILE"]]


            # Generate OP,YIEL
            # This requires polling the detector manager as well.
            yiel_lines = the_experiment_manager.generate_yiel("mini")
            if "Error" in yiel_lines[0]:
                return -1

            # DOING MAP AND MINI IN ONE CALL DOES NOT WORK ON SOME SYSTEMS.

            # If the call was for OP,MAP, add the OP,MAP line; otherwise the OP,MINI lines.

            if do_map_instead:
                print "Calculating the q-parameter map (OP,MAP) in a separate call to Gosia."
                final_lines = ["OP,MAP"]

            else:
                # Generate the OP,MINI section.  Go through the minimization
                # parameter dictionary and set string values from it.
                final_lines = ["OP,MINI"]
                if self.minimization_parameter_dict["fast_approximation"][0]:
                    mini_parameters_line = "1"
                else:
                    mini_parameters_line = "2"
                if self.minimization_parameter_dict["steepest_descent"][0]:
                    mini_parameters_line = mini_parameters_line + "0"
                else:
                    mini_parameters_line = mini_parameters_line + "1"
                if self.minimization_parameter_dict["absolute_change"][0]:
                    mini_parameters_line = mini_parameters_line + "0"
                else:
                    mini_parameters_line = mini_parameters_line + "1"
                if self.minimization_parameter_dict["linear_yields"][0]:
                    mini_parameters_line = mini_parameters_line + "0"
                else:
                    mini_parameters_line = mini_parameters_line + "1"
                mini_parameters_line = mini_parameters_line + ", " + str(self.minimization_parameter_dict["max_steps"][0])
                mini_parameters_line = mini_parameters_line + ", " + str(self.minimization_parameter_dict["chi_squared_limit"][0])
                mini_parameters_line = mini_parameters_line + ", " + str(self.minimization_parameter_dict["convergence_criterion"][0])
                mini_parameters_line = mini_parameters_line + ", " + str(self.minimization_parameter_dict["recalc_test"][0])
                if self.minimization_parameter_dict["lockf"][0]:
                    mini_parameters_line = mini_parameters_line + ", 1"
                else:
                    mini_parameters_line = mini_parameters_line + ", 0"
                mini_parameters_line = mini_parameters_line + ", " + str(self.minimization_parameter_dict["nlock"][0])
                if self.minimization_parameter_dict["forward_backward"][0]:
                    mini_parameters_line = mini_parameters_line + ", 1"
                else:
                    mini_parameters_line = mini_parameters_line + ", 0"
                if self.minimization_parameter_dict["lock_less_effective"][0]:
                    mini_parameters_line = mini_parameters_line + ", 1"
                else:
                    mini_parameters_line = mini_parameters_line + ", 0"
                mini_parameters_line = mini_parameters_line + ", " + str(self.minimization_parameter_dict["dlocks"][0])
                final_lines.append(mini_parameters_line)



            # Put together the full input
            full_gosia_input = op_file_lines
            full_gosia_input.extend(level_scheme_lines)
            full_gosia_input.extend(expt_lines)
            full_gosia_input.extend(cont_lines)
            full_gosia_input.extend(bric_lines)
            full_gosia_input.extend(yiel_lines)
            full_gosia_input.extend(final_lines)  # OP,MAP or OP,MINI

            # Put an op,exit on the end and a blank line to finish.
            full_gosia_input.extend(["OP,EXIT"," "])

            return full_gosia_input


    def lifetimes_input(self):
        """Generates an input for lifetimes only.
        
        This uses one phoney experiment to calculate lifetimes.  It is done
        with phoney setup so that the user does not need to complete the setup
        to get lifetimes; it can be done as soon as the level scheme and a
        matrix element are in memory.


        """

        # Need an op,file header
        op_file_lines = self.op_file_header({9:{"extension":"rachel_dummy_gdt_file","status":"3","format":1}})

        # Get the nucleus information
        level_scheme_lines = investigated_nucleus.generate_gosia_input(fix_all = True)

        # Get the EXPT section 
        # One dummy experiment with the real Z,A.
        Z = investigated_nucleus.get_value("Z")
        A = investigated_nucleus.get_value("A")
        expt_header_line = "1 " + str(Z) + " " + str(A)
        # Use a forward scattering angle to avoid exceeding a maximum scattering angle.
        # Use something heavy to avoid inverse kinematics.
        dummy_experiment = "92, 238, 100.0, 5.0, 1, 1, 0, 0.0, 360.0, 0, 1 "
        expt_lines = [\
                      "EXPT",\
                      expt_header_line,\
                      dummy_experiment\
                     ]
        # Only important thing is to have the lifetime output turned on and 14 turned on.
        cont_lines = [\
                      "CONT",\
                      "SPL,1.",\
                      "PRT,",\
                      "1,-1",\
                      "2,0",\
                      "4,0",\
                      "5,1",\
                      "11,0",\
                      "12,0",\
                      "14,1,",\
                      "15,1",\
                      "16,0",\
                      "9,99999",\
                      "0,0",\
                      "NCM,1.",\
                      "END, ",\
                      "  "\
                     ]


        # Generate OP,BRIC
        bric_lines = ["OP,BRIC",\
                      GLOBAL_SETUP_DICT["BRICC_IDX_FILE"],\
                      GLOBAL_SETUP_DICT["BRICC_ICC_FILE"]]


        # Generate OP,YIEL and OP,POIN (just dummy fields, except for the bric flags.
        yiel_lines = [\
                      "OP,YIEL",\
                      "1",\
                      "-1,0",\
                      "1.0",\
                      "0  ",\
                      "0  ",\
                      "0.0  ",\
                      "0.0  ",\
                      "2,1",\
                      "1",\
                      "1",\
                      "1",\
                      "0   !NTAP",\
                      "0,0",\
                      "0,0",\
                      "0,0",\
                      "0,0",\
                      "OP,POIN",\
                      "0,0"\
                     ]
 

        # Put together the full input
        full_gosia_input = op_file_lines
        full_gosia_input.extend(level_scheme_lines)
        full_gosia_input.extend(expt_lines)
        full_gosia_input.extend(cont_lines)
        full_gosia_input.extend(bric_lines)
        full_gosia_input.extend(yiel_lines)

        # Put an op,exit on the end and a blank line to finish.
        full_gosia_input.extend(["OP,EXIT"," "])

        return full_gosia_input


    def vacuum_depolarization_input(self,file_extension_substitution_dict = {}):
        """Generates an input for vacuum depolarization coefficiencts

        """

        block_print_with_line_breaks("This function uses a fit of 0 steps to force Gosia to output the vacuum depolarization coefficients.")

        # Make a substitution of file names, since we are faking some files for
        # this calculation and we don't want to overwrite a real file.
        op_file_lines = self.op_file_header(file_extension_substitution_dict)

        # Get the nucleus information
        level_scheme_lines = investigated_nucleus.generate_gosia_input(fix_all = True)

        # Get the EXPT section 
        expt_lines = the_experiment_manager.generate_expt()

        # Get the CONT block
        cont_lines = self.generate_cont_lines()
        # Remove the 14,0 entry, if it exists
        for line_number in range(len(cont_lines)):
            this_line = cont_lines[line_number]
            if this_line.startswith("14,"):
                # Replace it with 14,1.  This will not be necessary when the cont_lines method is rewritten.
                del cont_lines[line_number]
                cont_lines.insert(line_number,"14,1")

        # Generate OP,BRIC
        bric_lines = ["OP,BRIC",\
                      GLOBAL_SETUP_DICT["BRICC_IDX_FILE"],\
                      GLOBAL_SETUP_DICT["BRICC_ICC_FILE"]]


        # Generate OP,YIEL
        # This requires polling the detector manager as well.
        yiel_lines = the_experiment_manager.generate_yiel("deor")
        if "Error" in yiel_lines[0]:
            return -1

        # Generate the OP,MAP line.  This is done "on the fly."  Is that acceptable?
        # THIS IS NOW DONE SEPARATELY, BECAUSE ON SOME SYSTEMS BOTH CANNOT BE DONE IN ONE CALL TO GOSIA.
        #print "Note: calculating the q-parameter map \"on the fly\"..."
        #map_lines = ["OP,MAP"]

        # Generate the OP,MINI section.  Go through the minimization
        # parameter dictionary and set string values from it.
        mini_lines = ["OP,MINI"]
        # We can do a 0-step fit with an unreasonably low chi-squared limit to get the vacuum depol. coefficients.
        mini_lines.append("2100, 0, 0.0, 0.0001, 1.01, 0, 0, 1, 0, 0")

        # Put together the full input
        full_gosia_input = op_file_lines
        full_gosia_input.extend(level_scheme_lines)
        full_gosia_input.extend(expt_lines)
        full_gosia_input.extend(cont_lines)
        full_gosia_input.extend(bric_lines)
        full_gosia_input.extend(yiel_lines)
        full_gosia_input.extend(mini_lines)

        # Put an op,exit on the end and a blank line to finish.
        full_gosia_input.extend(["OP,EXIT"," "])

        return full_gosia_input


    def op_erro_corr_input(self,release=True):
        """Generates the input for the diagonal error calculation.

        """

        # Need an op,file header
        op_file_lines = self.op_file_header()

        # Get the nucleus information
        level_scheme_lines = investigated_nucleus.generate_gosia_input()

        # Get the EXPT section 
        expt_lines = the_experiment_manager.generate_expt()

        # Get the CONT block
        cont_lines = self.generate_cont_lines()

        # Generate OP,BRIC
        bric_lines = ["OP,BRIC",\
                      GLOBAL_SETUP_DICT["BRICC_IDX_FILE"],\
                      GLOBAL_SETUP_DICT["BRICC_ICC_FILE"]]


        # Generate OP,YIEL
        # This requires polling the detector manager as well.
        yiel_lines = the_experiment_manager.generate_yiel("diag")
        if "Error" in yiel_lines[0]:
            return -1

        # Get the largest float on this machine.
        largest_float_string = str(largest_float_on_this_machine())
        op_erro_arguments_line = "1,0,0,1,1," + largest_float_string

        # Generate the op,re and op,erro part.
        if release:
            correlated_error_lines = ["OP,RE,F",\
                                "OP,ERRO",\
                                op_erro_arguments_line,\
                                "OP,EXIT"] 
        else:
            correlated_error_lines = ["OP,ERRO",\
                                op_erro_arguments_line,\
                                "OP,EXIT"] 

        full_gosia_input = op_file_lines
        full_gosia_input.extend(level_scheme_lines)
        full_gosia_input.extend(expt_lines)
        full_gosia_input.extend(cont_lines)
        full_gosia_input.extend(bric_lines)
        full_gosia_input.extend(yiel_lines)
        full_gosia_input.extend(correlated_error_lines)

        return full_gosia_input

    def op_erro_diag_input(self,release=True):
        """Generates the input for the diagonal error calculation.

        """

        # Need an op,file header
        op_file_lines = self.op_file_header()

        # Get the nucleus information
        level_scheme_lines = investigated_nucleus.generate_gosia_input()

        # Get the EXPT section 
        expt_lines = the_experiment_manager.generate_expt()

        # Get the CONT block
        cont_lines = self.generate_cont_lines()

        # Generate OP,BRIC
        bric_lines = ["OP,BRIC",\
                      GLOBAL_SETUP_DICT["BRICC_IDX_FILE"],\
                      GLOBAL_SETUP_DICT["BRICC_ICC_FILE"]]


        # Generate OP,YIEL
        # This requires polling the detector manager as well.
        yiel_lines = the_experiment_manager.generate_yiel("diag")
        if "Error" in yiel_lines[0]:
            return -1

        # Get the largest float on this machine.
        largest_float_string = str(largest_float_on_this_machine())
        op_erro_arguments_line = "0,0,0,0,1," + largest_float_string

        # Generate the op,re and op,erro part.
        if release:
            diagonal_error_lines = ["OP,RE,F",\
                                "OP,ERRO",\
                                op_erro_arguments_line,\
                                "OP,EXIT"] 
        else:
            diagonal_error_lines = [ "OP,ERRO",\
                                op_erro_arguments_line,\
                                "OP,EXIT"] 

        full_gosia_input = op_file_lines
        full_gosia_input.extend(level_scheme_lines)
        full_gosia_input.extend(expt_lines)
        full_gosia_input.extend(cont_lines)
        full_gosia_input.extend(bric_lines)
        full_gosia_input.extend(yiel_lines)
        full_gosia_input.extend(diagonal_error_lines)

        return full_gosia_input

    def read_final_chi_squared_from_gosia(self):
        """Scans the gosia output file for the final chi-squared value.

        The value of final chi-squared that gosia sends to standard-output is
        not necessarily the final value.  It may change in the final full
        calculation.

        """

        # Clear the final chi-squared and the "reason" line from the last fit.
        self.final_chi_squared = None
        self.reason_reported   = None

        # Get the gosia output file name from the gosia shell.
        gosia_output_file_name = self.get_base_file_name() + "." + FILE_DEF_DICT[22]["extension"]

        # Read the gosia output file from disk.  
        with open(gosia_output_file_name,'r') as gosia_output_file:
            gosia_output_lines = gosia_output_file.readlines()

        try:
            # Search for the final chi-squared line in the gosia output.  Test
            # for all possible convergence statements in the gosia output.  The
            # one with the maximum line number should be followed by the final
            # chi-squared value.
            search_strings = ["AT","STEP","ACHIEVED("]  # the line just before the report of final chi-squared value, if the derivative was small.
            final_chisq_line_achieved  = findinlist(gosia_output_lines,search_strings) + 1  # 1 line below the statement of convergence
            search_strings = ["AT", "STEP","CHISQ", "CRITERION", "FULFILLED"]  # the line just before the report of final chi-squared value, if the chi-squared criterion was met.
            final_chisq_line_fulfilled = findinlist(gosia_output_lines,search_strings) + 1  # 1 line below the statement of convergence
            search_strings = ["MINIMIZATION", "STEPS", "EXCEEDED"]  # the line just before the report of final chi-squared value, if the maximum number of minimization steps was exceeded.
            final_chisq_line_steps = findinlist(gosia_output_lines,search_strings) + 1  # 1 line below the statement of convergence
            final_chisq_line = max(final_chisq_line_steps,final_chisq_line_achieved,final_chisq_line_fulfilled)  # The line of the last existing convergence report.
            line_fields = gosia_output_lines[final_chisq_line].split()
            self.final_chi_squared = float(line_fields[2])
        except:
            self.final_chi_squared = None
        # Now try to get the last message in the gosia output that describes why the fit terminated.
        try:
            self.reason_reported = gosia_output_lines[final_chisq_line - 1]
        except:
            self.reason_reported = "(no reason returned from gosia.)"
            

    def return_final_chi_squared(self):
        """Returns the final chi-squared from the last fit, if it exists and the preceding line that may describe the reason the fit stopped.

        Otherwise, [None,None] is returned.

        """
        try:
            chisq = self.final_chi_squared
        except:
            chisq = None 

        try:
            reason_string = self.reason_reported
        except:
            reason_string = ""


        return [chisq,reason_string]
            

class experimentmanager:
    """Manages all instances of class experiment

    Only one object of this should be created.  Since only MAXEXPERIMENTS are
    allowed in gosia, only this many can be selected at output time.  

    This object holds the set of states that can be populated.  This could be
    moved to the nucleus class, but the experiment definition has something to
    do with which states can have a calculated yield above the zero threshold,
    so it is now being stored here.

    """

    def __init__(self):
        self.allexperiments = []  # zero the list of experiment objects
        self.saved_user_experiments = False

        # Changing to labeling of states by (band_name,spin) tuples makes it
        # impossible to store the ground state during the creation of the
        # self.excited_states list.
        self.excited_states = []

        # Set the default efficiency parameters.  The local self.efficiency_parameters variable holds the changeable values.
        self.efficiency_parameters = DEFAULT_EFFICIENCY_PARAMETERS 

    def for_upgrade(self,restored_version):
        """Sets new variables as appropriate for an upgrade from

        version restored_version to present VERSION.

        """

        total_errors = 0
        return_text = []

        if restored_version in []:
            # Add to the list above to select for upgrades by session file's version number.

            try:

                # Add to the commands here to upgrade the object of this class.

                for internal_experiment_number in range(self.getnumberofexperiments()):

                    angular_limit_success_line = "Upgrade of experimental definitions successful for experiment " + str(internal_experiment_number + 1) + "."
                    return_text.extend(textwrap.wrap(angular_limit_success_line,TEXTVIEW_COLUMNS))
            except:
                total_errors += 1
                angular_limit_set_error = "Error in setting angular limits for one or more experiments."
                return_text.extend(textwrap.wrap(angular_limit_set_error,TEXTVIEW_COLUMNS))
            # Examples of syntactically correct error codes are below.
            #total_errors += 1
            #return_text.extend(textwrap.wrap("ipsum lorem blah blah blah",TEXTVIEW_COLUMNS))
                
        return total_errors,return_text

    def experiment_name_is_unique(self,user_name):
        """Returns True if the proposed name user_name is not one of the names of an existing experiment.

        Returns False otherwise.

        """

        unique = True
        for one_experiment in self.allexperiments:
            if user_name == one_experiment.get_name():
                unique = False
                break

        return unique

    def delete_all_but_one_transition(self,requested_initial_band_name=None, requested_initial_spin=None, requested_final_band_name=None, requested_final_spin=None):
        """This is not a user function!

        This is part of an method under testing to measure spin from angular
        distribution data.

        """

        if None in [requested_initial_band_name, requested_initial_spin, requested_final_band_name, requested_final_spin]:
            requested_initial_band_name = raw_input("requested_initial_band_name: ")
            requested_initial_spin = round(float(raw_input("requested_initial_spin: ")),1)
            requested_final_band_name = raw_input("requested_final_band_name: ")
            requested_final_spin = round(float(raw_input("requested_final_spin: ")),1)
            
        # Get the number of experiments to read.
        number_of_experiments = self.getnumberofexperiments()
        # Get a list of the number of detectors for each experiment.
        numbers_of_detectors = self.get_numbers_of_detectors()

        for experiment_number in range(number_of_experiments):
            for detector_number in range(numbers_of_detectors[experiment_number]):
                # Get the yield point for the transition to remain.
                original_yields = self.allexperiments[experiment_number].get_experimental_yields(detector_number)
                for one_yield_list in original_yields:
                    initial_band_name, initial_spin, final_band_name, final_spin, intensity, error = one_yield_list
                    if [initial_band_name, initial_spin, final_band_name, final_spin] == [requested_initial_band_name, requested_initial_spin, requested_final_band_name, requested_final_spin]:
                        # This is the point we want to keep.
                        break

                # Set the yields for this detector to only the transition to keep.
                yield_data = [[requested_initial_band_name, requested_initial_spin, requested_final_band_name, requested_final_spin, intensity, error]]
                # Pass these EXPERIMENTAL yields for one experiment and one detector to the appropriate logical detector.
                self.allexperiments[experiment_number].set_one_detector_experimental_yields(detector_number,yield_data)

        print "All data sets pruned to keep only the transition"
        print requested_initial_band_name, requested_initial_spin, " --> ", requested_final_band_name, requested_final_spin
        print 
        return 0


    def get_experiment_numbers(self):

        """Prompts until a list of valid experiment numbers is entered.

        If the user selects to quit without entering, then -1 is returned.

        """

        experiment_numbers_finished = False # Flag will be set to true when all experiment numbers are valid.

        # Get the number of experiments defined, so that we can check the user
        # input of experiment numbers.
        number_of_experiments = self.getnumberofexperiments()

        # all_experiments is a SET to check overlap with user's choices (that the user chooses a subset).
        all_experiments_set = set(range(number_of_experiments))

        while not experiment_numbers_finished:
            print "Enter a list of experiment numbers to add this array to, \n  e.g. 1,2,4,7 "
            try:
                experiment_numbers_string = raw_input("Experiment numbers [or \"all\" or \"q\" to quit]: ").lower()
                if not len(experiment_numbers_string) == 0:
                    if experiment_numbers_string[0] == "q":
                        print "Operation cancelled."
                        return -1
                    elif experiment_numbers_string[0] == "a":
                        internal_experiment_numbers_set = set([])
                        experiment_numbers = all_experiments_set
                        for one_experiment_number in experiment_numbers:
                            internal_experiment_number = int(one_experiment_number) 
                            internal_experiment_numbers_set.add(internal_experiment_number)
                        print "Chosen experiment numbers are: ",
                        for i in internal_experiment_numbers_set:
                            # Convert to user/gosia base 1 experiment numbers.
                            print i + 1,"  ",
                        print ""
                        experiment_numbers_finished = True
                    else:
                        # Convert to a set of integers.
                        list_of_strings = experiment_numbers_string.split(",")
                        # Convert the string-numbers to internal experiment
                        # numbers (base 0) by converting to an int and
                        # subtracting 1.
                        internal_experiment_numbers_set = set([])
                        for one_string in list_of_strings:
                            internal_experiment_number = int(one_string) - 1
                            internal_experiment_numbers_set.add(internal_experiment_number)
                        if internal_experiment_numbers_set.issubset(all_experiments_set) or internal_experiment_numbers_set == all_experiments_set:
                            print "Chosen experiment numbers are: ",
                            for i in internal_experiment_numbers_set:
                                # Convert to user/gosia base 1 experiment numbers.
                                print i + 1,"  ",
                            print ""
                            experiment_numbers_finished = True
                        else:
                            print "Need existing experiment numbers.  Try again."
            except:
                print "Need existing experiment numbers.  Try again."
                print "Enter a COMMA-DELIMITED list of experiment numbers."

        return internal_experiment_numbers_set



    def auto_load_yield_data(self):
        """Auto-loads data into every Ge or cluster for the requested experiments.

        """

        
        #Prompt for the set of experiment numbers to add the detectors to.
        internal_experiment_numbers_set = self.get_experiment_numbers()
        if internal_experiment_numbers_set == -1:
            print "No valid experiment_numbers chosen.  No data were loaded."
            return -1

        # Step through the requested experiment numbers and auto-load data for
        # each Ge detector and cluster.
        for internal_experiment_number in internal_experiment_numbers_set:
            print "Experiment # ", internal_experiment_number + 1, ":"
            for internal_detector_number in range(self.allexperiments[internal_experiment_number].get_number_of_detectors()):
                print "  Detector # ", internal_detector_number + 1,
                # See if this detector can auto-load.
                if self.allexperiments[internal_experiment_number].get_detector_information(internal_detector_number,"can_auto_load"):
                    print "  can auto-load."
                    # Ask the detector for the file name to load data.  
                    auto_load_file_name = self.allexperiments[internal_experiment_number].get_detector_information(internal_detector_number,"yield_data_file_name")
                    # Ask which file type (ags or txt right now; gosia yield file will load all detectors)
                    auto_load_file_type = self.allexperiments[internal_experiment_number].get_detector_information(internal_detector_number,"yield_data_file_type")
                    print "  File type: ",auto_load_file_type,", name: ", auto_load_file_name 
                    # Load the data into this detector.
                    if auto_load_file_type == "txt":
                        self.read_txt_file_yields(auto_load_file_name,internal_experiment_number,internal_detector_number)
                    elif auto_load_file_type == "ags":
                        self.read_ags_file_yields(auto_load_file_name,internal_experiment_number,internal_detector_number)
                    else:
                        print "File type for experiment ", internal_experiment_number + 1, ", detector ", internal_detector_number + 1, " not understood."
                else:
                    print "cannot auto-load.\n"

    def full_auto_load_yield_data(self):
        """Auto-loads data into every Ge or cluster 

        This is the "fully" automatic method where experiment names are used 
        to specify systematic data file names.

        All files must be of the same type--ags or txt

        """

        # AGS or TXT files?
        block_print_with_line_breaks("The \"fully\"-automatic loading requires:\n  that all files be of the same type (ags or txt)\n  that a file exists for every detector in every experiment\n  that the file names follow the convention \"expt_[experiment_name]_det_[#].[ags/txt]\", where experiment_name is the name entered by the user when it was defined and [#] is the logical detector number in the order it was added.\nIf detector arrays were defined by file (Tools: \"id\"), then the numbering of detectors follows the order in the detector array file.",60)

        txt_or_ags = raw_input("Import from AGS[a] or TXT[t] files [return to quit]? ").lower()[0]

        if txt_or_ags == "t":
            file_extension = "txt"
        elif txt_or_ags == "a":
            file_extension = "ags"
        else:
            print "Invalid choice.  Cancelled."
            return 0

        return_code = 0

        # Step through all experiments and auto-load data for
        # each Ge detector and cluster.
        for internal_experiment_number in range(self.getnumberofexperiments()):
            one_experiment = self.allexperiments[internal_experiment_number] # the object
            experiment_name = one_experiment.get_name()
            print "Experiment \"" + experiment_name + "\":"
            for internal_detector_number in range(one_experiment.get_number_of_detectors()):
                detector_number = internal_detector_number + 1
                print "  Detector # ", detector_number ,
                # Construct the systematic file name.
                file_name = "expt_" + experiment_name + "_det_" + str(detector_number) + "." + file_extension
                print "  Trying to auto-load from file \"" + file_name + "\"."
                if file_extension == "txt":
                    try:
                        self.read_txt_file_yields(file_name,internal_experiment_number,internal_detector_number)
                    except:
                        print "  COULD NOT LOAD THIS FILE.  Please check the name and format."
                        return_code = -1
                elif file_extension == "ags":
                    try:
                        self.read_ags_file_yields(file_name,internal_experiment_number,internal_detector_number)
                    except:
                        print "  COULD NOT LOAD THIS FILE.  Please check the name and format."
                        return_code = -1

        print "Done."
        return return_code


    def any_raw_detectors(self):
        """Returns True if any raw Ge clusters are in use; otherwise False.

        """


        for one_experiment in self.allexperiments:
            if one_experiment.any_raw_detectors():
                return True

        # If no clusters were found, return False.
        return False


    def display_Ge_detectors_for_all_experiments(self):
        """Displays the Ge detectors for all experiments.
        
        Calls a popup object that displays to the terminal if popups are off.

        """

        detector_display_lines = []
        number_of_experiments = self.getnumberofexperiments()
        for n in range(number_of_experiments):
            # Get the lists of detector type, theta_ge and phi_ge from the experiment.
            raw_detector_type_list, raw_theta_list, raw_phi_list = self.allexperiments[n].get_all_detector_numbers_and_angles(True)
            theta_list = []
            phi_list   = []
            detector_type_list = []
            for one_type in raw_detector_type_list:
                if one_type == None:
                    one_type = "Cluster"
                detector_type_list.append(str(one_type).ljust(8))
            for one_theta in raw_theta_list:
                theta_list.append(format(one_theta,".2f").ljust(8))
            for one_phi in raw_phi_list:
                phi_list.append(format(one_phi,".2f").ljust(8))
            header_line = "Experiment " + str(n + 1)
            detector_display_lines.append(header_line)
            detector_line = str(detector_type_list).strip('[]').replace(",","").replace("'","")
            theta_line = str(theta_list).strip('[]').replace("'","").replace(",","")
            phi_line = str(phi_list).strip('[]').replace("'","").replace(",","")
            detector_line = "Type:        " + detector_line
            theta_line    = "Theta (deg): " + theta_line
            phi_line      = "Phi   (deg): " + phi_line
            bar_line = max(max(len(detector_line),len(theta_line),len(phi_line),20),80) * "-"  # To generate a line of the appropriate length
            detector_display_lines.append(bar_line)
            detector_display_lines.extend([detector_line,theta_line,phi_line])
            detector_display_lines.append(bar_line)

        create_dialog_popup({"text_lines":detector_display_lines,"title":"Detector catalog"})


    def plot_all_detectors(self):
        """Plots the detectors for a chosen experiment.

        """

        while True:
            self.print_experiment_catalog()
            gosia_experiment_number = prompt_number("Enter experiment number: ","i") 

            if gosia_experiment_number == "quit":
                print "Quitting."
                return 0

            internal_experiment_number = gosia_experiment_number - 1  # Subtract one to convert to internal numbering.
            self.allexperiments[internal_experiment_number].plot_all_detectors()

        return 0



    def is_populated(self,level_key):
        """Returns false if the level is not populated (see full doc string).

        If the level is populated in any 1 detector (or more), then return True;
        else return False.

        This is not the best way to do this.  The release version should check
        that the level is populated in each detector and omit data for states
        that don't have a calculated yield above threshold in each detector's
        data set.

        level_key is now a tuple of (band_name,spin)

        """

        # Change the level key to the primary level key, if this key is a
        # pseudonym.  (Pseudonyms are not in the populated list.)
        level_key = investigated_nucleus.get_primary_level_key_from_pseudonym(level_key)  # Now the primary reference to the level.

        # If this level is not known, then the level_key returned will be None.
        # In this case, the state is obviously not populated.  Return False.
        if level_key == None:
            return False

        band_name, spin = level_key

        # See if this is the ground state.  The ground state is always
        # populated.  The ground state must be the first state in the sorted
        # unique level keys.  The internal level number is calculated in this
        # version of the code, since level objects are stored by
        # (band_name,spin) tuple keys.
        internal_level_number = investigated_nucleus.lookup_internal_level_by_band_spin(band_name,spin)
        if internal_level_number == 0:
            return True

        # If this was not the ground state, then search the excited_states sets
        # to see if this state is included.

        for internal_experiment_number in range(len(self.excited_states)):
            this_experiment_list = self.excited_states[internal_experiment_number]
            for internal_detector_number in range(len(this_experiment_list)):
                one_detector_calculated_states = this_experiment_list[internal_detector_number]
                if level_key in one_detector_calculated_states:
                    return True

        return False # by default if it did not have a calculated yield in any detector.

    def get_nuclear_data_lines(self,branching_data_weight,lifetime_weight,mixing_ratio_weight,matrix_element_weight):
        """Reads the Rachel nuclear data file and generates lines for OP,YIEL data.

        This method checks that the appropriate states for each level specified
        and type of data are populated, and that the necessary matrix elements
        are defined for the decays referenced.

        Reads nuclear data from the file NUCLEAR_DATA_FILE_NAME 

        according to the formatting and notation below:

        branching initial_band initial_spin final_band_1 final_spin_1 final_band_2 final_spin_2 branching_ratio error
        mixing    initial_band initial_spin final_band final_spin mixing_ratio error
        lifetime band spin lifetime[ps] error[ps]
        < final_band final_spin || multipolarity || initial_band initial_spin > = signed_matrix_element error

        This will zero the nuclear data in memory.  Nuclear data for
        non-existent states will not be used, so the full set of branching data
        can be left in the file.

        """


        # Zero the nuclear data.  This will only be included if it's still in the data file on disk.
        self.branching_data = []  
        self.lifetime_data  = []
        self.mixing_data    = []
        self.measured_matrix_data = []
        print "  Looking for nuclear data in rachel_nuclear_data.txt..."
        try:
            with open(NUCLEAR_DATA_FILE_NAME,"r") as nuclear_data_file:
                nuclear_data_file_lines = nuclear_data_file.readlines()
            print "  READ NEW NUCLEAR DATA FILE."
        except:
            print "  NO NEW NUCLEAR_DATA DATA FILE FOUND.  (This is ok.)"
            empty_data_lines = ["0,0" for n in range(4)]
            return empty_data_lines

        # First, parse the whole file.  Then, if there is no fatal error, call
        # the nucleus methods etc. as necessary to change each entry to the
        # gosia format.
        line_number = 0
        while line_number < len(nuclear_data_file_lines):  # Correction for E.A. McCutchan's bug--no longer requires a blank line to terminate.

            nuclear_data_line = nuclear_data_file_lines[line_number]
            line_fields = nuclear_data_line.split()

            if len(line_fields) > 0:

                if line_fields[0] == "#":

                    # This is a comment line or a "commented-out" line.  Skip.
                    pass

                elif line_fields[0] == "branching":

                    initial_band_name = line_fields[1]
                    final_band_name_1 = line_fields[3]
                    final_band_name_2 = line_fields[5]
                    initial_spin      = round(float(line_fields[2]),1)  # rounded to the tenth place for half-integer cases
                    final_spin_1      = round(float(line_fields[4]),1)  # rounded to the tenth place for half-integer cases
                    final_spin_2      = round(float(line_fields[6]),1)  # rounded to the tenth place for half-integer cases
                    initial_level_key = (initial_band_name, initial_spin)
                    final_level_key_1 = (final_band_name_1, final_spin_1)
                    final_level_key_2 = (final_band_name_2, final_spin_2)
                    r                 = float(line_fields[7])
                    delta_r           = float(line_fields[8])
                    # Append the line data to the list if the data point passes
                    # all of the following tests.  All initial and final states
                    # must exist, must be populated in at least detector (as
                    # calculated by gosia), and there must be at least one
                    # matrix element coupling the initial state to each final
                    # state.
                    can_include = True
                    # Ask the nucleus if these levels exist.
                    initial_level_exists = investigated_nucleus.get_level_information(initial_level_key,"exists")
                    final_level_1_exists = investigated_nucleus.get_level_information(final_level_key_1,"exists")
                    final_level_2_exists = investigated_nucleus.get_level_information(final_level_key_2,"exists")
                    if not (initial_level_exists and final_level_1_exists and final_level_2_exists):
                        # One or more states are not in the level scheme currently.
                        can_include = False
                    if (not investigated_nucleus.are_coupled(initial_level_key,final_level_key_1)) or \
                       (not investigated_nucleus.are_coupled(initial_level_key,final_level_key_2)):
                        # One or both of the decays is not represented by a matrix element.
                        can_include = False
                    if (not self.is_populated(initial_level_key)) or (not self.is_populated(final_level_key_1)) \
                      or (not self.is_populated(final_level_key_2)):
                        # One or more states are not populated in any Ge detector.
                        can_include = False
                    # Check that gosia believes that this state has a finite
                    # (measurable) lifetime.  If not, then there is a problem
                    # calculating for this state.  This test should be
                    # redundant in terms of checking with Gosia.
                    if investigated_nucleus.get_level_information(initial_level_key,"calculated lifetime") == None:
                        can_include = False
                    if can_include:
                        self.branching_data.append([initial_band_name,initial_spin,final_band_name_1,final_spin_1,final_band_name_2,final_spin_2,r,delta_r])

                elif line_fields[0] == "<":

                    # Throw out the <, ||, >, = symbols, if any (replace with whitespace).
                    stripped_line = eliminate_characters("<>|=",nuclear_data_line," ")
                    new_line_fields = stripped_line.split()
                    initial_band_name = new_line_fields[3]
                    final_band_name   = new_line_fields[0]
                    initial_spin      = round(float(new_line_fields[4]),1)  # rounded to the tenth place for half-integer cases
                    final_spin        = round(float(new_line_fields[1]),1)  # rounded to the tenth place for half-integer cases
                    initial_level_key = (initial_band_name, initial_spin)
                    final_level_key   = (final_band_name, final_spin)
                    multipole_text    = new_line_fields[2]
                    multipole_code    = MULTIPOLE[multipole_text]
                    reduced_matrix_element = float(new_line_fields[5])
                    error                  = float(new_line_fields[6])

                    # Get the level indices that will be sent to Gosia so that
                    # we can check whether the matrix element will need to be
                    # time-reversed.

                    gosia_initial_level_number = investigated_nucleus.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
                    gosia_final_level_number   = investigated_nucleus.lookup_gosia_level_by_band_spin(final_band_name,final_spin)
                    # If either of the levels does not exist now, then this should be skipped.
                    if not None in [gosia_initial_level_number, gosia_final_level_number]:

                        if gosia_final_level_number < gosia_initial_level_number:
                            # Time-reverse data that were entered in the downward direction, and flip the initial and final states.
                            # so that the matrix element follows gosia (and internal) conventions.
                            #Syntax: time_reversal(I_a,I_b,multipole_text,a_to_b_matrix_element)
                            reduced_matrix_element = time_reversal(initial_spin,final_spin,multipole_text,reduced_matrix_element)
                            final_level_key,initial_level_key = initial_level_key, final_level_key
                            final_band_name, initial_band_name = initial_band_name, final_band_name
                            final_spin, initial_spin = initial_spin, final_spin

                        # Now construct the matrix element key with the proper
                        # direction of initial and final levels.
                        # The existence check for matrix elements does not translate pseudonyms.  Change pseudonyms to current names.
                        primary_initial_level_key = investigated_nucleus.get_primary_level_key_from_pseudonym(initial_level_key)
                        primary_final_level_key   = investigated_nucleus.get_primary_level_key_from_pseudonym(final_level_key)
                        # If either of the level keys does not exist now, then this should be skipped.
                        if not None in [primary_initial_level_key, primary_final_level_key]:
                            primary_initial_band_name = primary_initial_level_key[0]
                            primary_final_band_name   = primary_final_level_key[0]

                            matrix_element_key = (multipole_code,primary_initial_band_name,initial_spin,primary_final_band_name,final_spin)

                            # Append the m.e. data to the list if the data point passes
                            # all of the following tests.  All initial and final states
                            # must exist, must be populated in at least detector (as
                            # calculated by gosia), and the matrix element must exist
                            # in the present matrix.
                            can_include = True
                            initial_level_exists = investigated_nucleus.get_level_information(initial_level_key,"exists")
                            final_level_exists   = investigated_nucleus.get_level_information(final_level_key,"exists")
                            if not (initial_level_exists and final_level_exists):
                                # One or more states are not in the level scheme currently.
                                can_include = False
                            if (not self.is_populated(initial_level_key)) or (not self.is_populated(final_level_key)):
                                # Either the initial or final state is not populated by gosia calculations.
                                can_include = False
                            matrix_element_exists = investigated_nucleus.matrix_element_exists(matrix_element_key)
                            if not matrix_element_exists:
                                # This matrix element does not exist in the current matrix.
                                can_include = False
                            # Check that gosia believes that the initial state has a finite
                            # (measurable) lifetime.  If not, then there is a problem
                            # calculating for this state.  This test should be
                            # redundant in terms of checking with Gosia.

                            # We get first the initial gosia level number to see if
                            # this is the ground state (which will not have a
                            # calculated lifetime.  If the lifetime is not calculated,
                            # but it is the ground state, then we can include this
                            # matrix element anyway.

                            initial_gosia_level_number = investigated_nucleus.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
                            if (investigated_nucleus.get_level_information(initial_level_key,"calculated lifetime")) == None and (not initial_gosia_level_number == 1):
                                can_include = False
                            if can_include:
                                self.measured_matrix_data.append([initial_band_name, final_band_name, initial_spin, final_spin, multipole_code, reduced_matrix_element, error])


                elif line_fields[0] == "lifetime":

                    initial_band_name = line_fields[1]
                    initial_spin      = round(float(line_fields[2]),1)  # rounded to the tenth place for half-integer cases
                    initial_level_key = (initial_band_name, initial_spin)
                    tau               = float(line_fields[3])
                    delta_tau         = float(line_fields[4])
                    # Check that gosia believes that this state has a finite (measurable) lifetime.
                    if not investigated_nucleus.get_level_information(initial_level_key,"calculated lifetime") == None:
                        self.lifetime_data.append([initial_band_name, initial_spin, tau, delta_tau])

                elif line_fields[0] == "mixing":

                    initial_band_name = line_fields[1]
                    final_band_name   = line_fields[3]
                    initial_spin      = round(float(line_fields[2]),1)  # rounded to the tenth place for half-integer cases
                    final_spin        = round(float(line_fields[4]),1)  # rounded to the tenth place for half-integer cases
                    initial_level_key = (initial_band_name, initial_spin)
                    final_level_key   = (final_band_name, final_spin)
                    mixing_ratio      = float(line_fields[5])
                    error             = float(line_fields[6])
                    # Append the mixing ratio to the list if the data point passes
                    # all of the following tests.  The initial and final states
                    # must exist, must be populated in at least detector (as
                    # calculated by gosia), and the E2 and M1 matrix elements 
                    # must both exist in the present matrix.
                    can_include = True
                    initial_level_exists = investigated_nucleus.get_level_information(initial_level_key,"exists")
                    final_level_exists   = investigated_nucleus.get_level_information(final_level_key,"exists")
                    if not (initial_level_exists and final_level_exists):
                        # One or more states are not in the level scheme currently.
                        can_include = False
                    if (not self.is_populated(initial_level_key)) or (not self.is_populated(final_level_key)):
                        # Either the initial or final state is not populated by gosia calculations.
                        can_include = False
                    # Bug fix:
                    # Note that the matrix element may be in either order for
                    # Gosia, whereas the decay direction should have been given
                    # by the user in the nuclear data file.
                    e2_excitation_matrix_element_key = (2,initial_band_name,initial_spin,final_band_name,final_spin)
                    m1_excitation_matrix_element_key = (7,initial_band_name,initial_spin,final_band_name,final_spin)
                    e2_reversed_matrix_element_key   = (2,final_band_name,final_spin,initial_band_name,initial_spin)
                    m1_reversed_matrix_element_key   = (7,final_band_name,final_spin,initial_band_name,initial_spin)
                    e2_matrix_element_exists = investigated_nucleus.matrix_element_exists(e2_excitation_matrix_element_key) or\
                                               investigated_nucleus.matrix_element_exists(e2_reversed_matrix_element_key)
                    m1_matrix_element_exists = investigated_nucleus.matrix_element_exists(m1_excitation_matrix_element_key) or\
                                               investigated_nucleus.matrix_element_exists(m1_reversed_matrix_element_key)
                    if not e2_matrix_element_exists:
                        # This E2 matrix element does not exist in the current matrix.
                        can_include = False
                    if not m1_matrix_element_exists:
                        # This M1 matrix element does not exist in the current matrix.
                        can_include = False
                    # Check that gosia believes that this state has a finite
                    # (measurable) lifetime.  If not, then there is a problem
                    # calculating for this state.  This test should be
                    # redundant in terms of checking with Gosia.
                    # We get first the initial gosia level number to see if
                    # this is the ground state (which will not have a
                    # calculated lifetime.  If the lifetime is not calculated,
                    # but it is the ground state, then we can include this
                    # matrix element anyway.

                    initial_gosia_level_number = investigated_nucleus.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
                    if (investigated_nucleus.get_level_information(initial_level_key,"calculated lifetime")) == None and (not initial_gosia_level_number == 1):
                        can_include = False
                    if can_include:
                        self.mixing_data.append([initial_band_name, final_band_name, initial_spin, final_spin, mixing_ratio, error])

                else:

                    # This line does not have one of the four markers
                    # "lifetime", "<" (m.e.), "branching" or "mixing."  Skip
                    # this line and continue.
                    pass

            line_number += 1  # increment the line number.

        measured_branching_lines = []
        measured_mixing_lines    = []
        measured_me_lines        = []
        measured_lifetime_lines  = []
        
        if not len(self.branching_data) == 0:
            branching_header_line = str(len(self.branching_data)) + " " + str(branching_data_weight)
            measured_branching_lines = [branching_header_line]
            for one_datum in self.branching_data:
                initial_band_name,initial_spin,final_band_name_1,final_spin_1,final_band_name_2,final_spin_2,r,delta_r = one_datum
                initial_gosia_level_number = investigated_nucleus.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
                final_gosia_level_number_1 = investigated_nucleus.lookup_gosia_level_by_band_spin(final_band_name_1,final_spin_1)
                final_gosia_level_number_2 = investigated_nucleus.lookup_gosia_level_by_band_spin(final_band_name_2,final_spin_2)
                this_line = str(initial_gosia_level_number) + " " +  str(final_gosia_level_number_1) + " " + \
                  str(initial_gosia_level_number) + " " + str(final_gosia_level_number_2) + " " + \
                  str(r) + " " + str(delta_r) 
                measured_branching_lines.append(this_line)
        else:
            measured_branching_lines = ["0,0"]
        if not len(self.lifetime_data) == 0:
            lifetime_header_line = str(len(self.lifetime_data)) + " " + str(lifetime_weight)
            measured_lifetime_lines = [lifetime_header_line]
            for one_datum in self.lifetime_data:
                initial_band_name, initial_spin, tau, delta_tau = one_datum
                initial_gosia_level_number = investigated_nucleus.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
                this_line = str(initial_gosia_level_number) + " " + str(tau) + " " + str(delta_tau) 
                measured_lifetime_lines.append(this_line)
        else:
            measured_lifetime_lines = ["0,0"]
        if not len(self.mixing_data) == 0:
            mixing_header_line = str(len(self.mixing_data)) + " " + str(mixing_ratio_weight)
            measured_mixing_lines = [mixing_header_line]
            for one_datum in self.mixing_data:
                initial_band_name, final_band_name, initial_spin, final_spin, mixing_ratio, error = one_datum
                initial_gosia_level_number = investigated_nucleus.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
                final_gosia_level_number = investigated_nucleus.lookup_gosia_level_by_band_spin(final_band_name,final_spin)
                this_line = str(initial_gosia_level_number) + " " +  str(final_gosia_level_number) + " " + str(mixing_ratio) + " " + str(error) 
                measured_mixing_lines.append(this_line)
        else:
            measured_mixing_lines = ["0,0"]
        if not len(self.measured_matrix_data) == 0:
            matrix_element_header_line = str(len(self.measured_matrix_data)) + " " + str(matrix_element_weight)
            measured_matrix_element_lines = [matrix_element_header_line]
            for one_datum in self.measured_matrix_data:
                initial_band_name, final_band_name, initial_spin, final_spin, multipole_code, matrix_element, error = one_datum
                initial_gosia_level_number = investigated_nucleus.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
                final_gosia_level_number = investigated_nucleus.lookup_gosia_level_by_band_spin(final_band_name,final_spin)
                this_line = str(multipole_code) + " " + str(initial_gosia_level_number) + " " +  \
                  str(final_gosia_level_number) + " " + str(matrix_element) + " " + str(error) 
                measured_matrix_element_lines.append(this_line)
        else:
            measured_matrix_element_lines = ["0,0"]


        gosia_nuclear_data_lines = measured_branching_lines + measured_lifetime_lines + measured_mixing_lines + measured_matrix_element_lines 

        # Now return the data lines in gosia format.
        return gosia_nuclear_data_lines


    def generate_angular_meshpoints(self, theta_lab_min, theta_lab_max, number_of_meshpoints, annular=True):
        """Generates angular meshpoints by a fast method.

        I am just using equally-spaced meshpoints now; fancier methods were
        difficult and leaving large gaps in theta for inverse kinematics.


        """

        # Linspace method:
        if annular:
            # azimuthally symmetric detector or a sector of same
            list_of_meshpoints = list(numpy.linspace(theta_lab_min,theta_lab_max,number_of_meshpoints))
            return list_of_meshpoints
        else:
            # arbitrary detector shape defined by user.  Same method for now.
            list_of_meshpoints = list(numpy.linspace(theta_lab_min,theta_lab_max,number_of_meshpoints))
            return list_of_meshpoints
            

    def reset_optimum_angular_meshpoints(self,all=False,internal_experiment_number=None):
        """Resets the optimum number of theta meshpoints for all experiments.

        """
        if all:
            experiment_list = range(len(self.allexperiments))
        else:
            experiment_list = [internal_experiment_number]

        # Loop to get the normalizations for all experiments.
        for one_internal_experiment_number in experiment_list:
            one_experiment = self.allexperiments[one_internal_experiment_number]
            # For this experiment, get the information necessary to calculate the mean scattering angle and the differential cross section.
            E_mean_lab = one_experiment.get_parameter("E_mean")
            Z_1 = one_experiment.get_parameter("Z_1")
            A_1 = one_experiment.get_parameter("A_1")
            Z_n = one_experiment.get_parameter("Z_n")
            A_n = one_experiment.get_parameter("A_n")
            excited_target = one_experiment.get_parameter("excited_target")
            annular = one_experiment.get_parameter("annular")  
            I_kin = one_experiment.get_parameter("I_kin")
            # Determine which are the beam and target particles.
            if excited_target:
                Z_projectile = Z_n
                A_projectile = A_n
                Z_target = Z_1
                A_target = A_1
            else:
                Z_projectile = Z_1
                A_projectile = A_1
                Z_target = Z_n
                A_target = A_n
            normal_kinematics = not one_experiment.is_inverse_kinematics()
            theta_lab_max = one_experiment.get_parameter("theta_lab_max")
            theta_lab_min = one_experiment.get_parameter("theta_lab_min")
            detected_particle = one_experiment.get_parameter("detected_particle")
            
            if not annular:
                # Need a lot of meshpoints to define smoothly an arbitrary
                # shaped detector.  This can be done with less memory in the
                # future by adding the delta-phi data.
                recommended_number_of_meshpoints = DEFAULT_THETA_MESHPOINTS * 2
            elif normal_kinematics:
                theta_lab_projectile_mean = one_experiment.mean_scattering_angle()
                if detected_particle == "t":
                    recommended_number_of_meshpoints = max(DEFAULT_THETA_MESHPOINTS,int((abs(theta_lab_max - theta_lab_min) / 90.) * MAXTHETAMESHPOINTS))
                else:
                    # Beam detection
                    recommended_number_of_meshpoints = max(DEFAULT_THETA_MESHPOINTS,int((abs(theta_lab_max - theta_lab_min) / 180.) * MAXTHETAMESHPOINTS))
            else:
                theta_lab_projectile_mean = one_experiment.mean_scattering_angle()
                # Inverse kinematics
                # Get the maximum scattering angle in the lab.
                if detected_particle == "t":
                    # Target detection.
                    recommended_number_of_meshpoints = max(DEFAULT_THETA_MESHPOINTS,int((abs(theta_lab_max - theta_lab_min) / 90.) * MAXTHETAMESHPOINTS))
                else:
                    # Beam detection.

                    # (There was a misunderstanding of the solutions treated by
                    # OP,INTI for beam detection, resulting in a lot of code
                    # here in older versions.  Now we can take a simple
                    # average.)

                    # The approximate range is all that is necessary to
                    # estimate the required number of meshpoints.  Since this
                    # may be called before the exit energy is known, we assume
                    # elastic collisions.  (Ebeam = 1 MeV, Q = 0)
                    theta_scat_max_lab = inelastic_maximum_scattering_angle(A_projectile,A_target,1.,0)
                    recommended_number_of_meshpoints = max(DEFAULT_THETA_MESHPOINTS,int((abs(theta_lab_max - theta_lab_min) / theta_scat_max_lab) * MAXTHETAMESHPOINTS))

            one_experiment.set_parameter("number_of_theta_meshpoints",recommended_number_of_meshpoints)
            one_experiment.set_parameter("number_of_energy_meshpoints",DEFAULT_ENERGY_MESHPOINTS)


        return 0

    def define_rectilinear_detector_interactive(self):
        """Defines the r,theta,phi coordinate data for op,inti

        This is meant to be introduced in a later version of Rachel, 2.0.0.beta

        """

        number_of_interpolation_points = 200 # in each line segment defining the detector boundaries. 


        if not investigated_nucleus.is_ready():
            print "You must define the nucleus before beginning to define the detector shapes."
            return -1
        
        user_satisfied = False # Will be set to true when the user is satisfied with the shape drawn.
        while not user_satisfied:
            block_print_with_line_breaks("Define the shape and size of the rectilinear detector in its plane, by entering x and y coordinates in centimeters with the origin (0,0) at the point of intersection of a normal line from the target.  You do NOT need to enter the initial point again as the final point.  This is handled by the GUI.  Enter only enough points to define linear edges.  Enter \"q\" to end the edge definition.")

            block_print_with_line_breaks("NOTE: if the detector covers a region beyond the maximum scattering angle, then you must define the detection region, not the entire detector.")

            boundary_xy_points = []  # a list of x and y points to be entered by the user
            while True:
                skip = False    # will be set to true if there was an invalid input, to skip processing of that input.
                try:
                    boundary_xy_point = raw_input("x y: ")
                    boundary_xy_point[0]
                except:
                    print "Invalid input. Ignoring last input."
                    skip = True
                if not skip:
                    if boundary_xy_point.lower()[0] == "q":
                        break
                    try:
                        if "," in boundary_xy_point:
                            x = float(boundary_xy_point.split(",")[0])
                            y = float(boundary_xy_point.split(",")[1])
                        else:
                            x = float(boundary_xy_point.split()[0])
                            y = float(boundary_xy_point.split()[1])
                    except:
                        print "Invalid input.  You will have to start over."
                        return -1
                    boundary_xy_points.append([x,y])

            if len(boundary_xy_points) < 3:
                print "Error: you need at least 3 points to define the 2D shape."
                return -1


            # Now we have all the x,y points in the plane of the detector.
            # Check to make sure the user didn't define the last point equal to the first point.
            if round(boundary_xy_points[0][0],1) == round(boundary_xy_points[-1][0],1) and \
              round(boundary_xy_points[0][1],1) == round(boundary_xy_points[-1][1],1):
                # If they are the same within one millimeter, delete the last point.
                del boundary_xy_points[-1]

            # Prompt for the point where the normal from the center of the target
            # intersects the detector.
            while True:
                try:
                    distance_from_target = float(raw_input("Enter distance from the target center along the normal [cm] r : "))
                    theta_r = float(raw_input("Enter the polar angle of the point of normal intersection [deg] : "))
                    phi_r = float(raw_input("Enter the azimuthal angle of the point of normal intersection [deg] : "))
                    break
                except:
                    print "Invalid input. Ignoring last input."

            investigated_nucleus.draw_a_particle_detector(boundary_xy_points,"Shape of detector in its plane","x [cm]","y [cm]",theta_r,phi_r)
                
            check_string = "Check that this is the correct shape and normal position, and that have you defined the coordinates such that the green line is the phi = " + str(round(phi_r,1)) + " degree line that you intended."
            block_print_with_line_breaks(check_string,60)
            user_satisfied = yes_no_prompt("Check the figure window.  Are you satisfied with this definition [Y/n]? ",True)

        # Once the user is satisfied, we can translate this shape and normal
        # position to polar coordinates.  
        x_tuple,y_tuple = zip(*boundary_xy_points)
        max_x = max(x_tuple)
        max_y = max(y_tuple)
        min_x = min(x_tuple)
        min_y = min(y_tuple)

        # WORK IN RADIANS BELOW UNLESS OTHERWISE STATED.
        phi_r = math.radians(phi_r)
        theta_r = math.radians(theta_r)

        # The transformation matrix
        if theta_r <= math.pi/2.:
            theta_rotation_matrix = [[math.cos(theta_r),  0.,  math.cos(abs(math.pi/2. - theta_r)) ],\
                                     [0.,                 1.,  0.],\
                                     [math.cos(math.pi/2. + theta_r),  0., math.cos(theta_r)]]
        else:
            theta_rotation_matrix = [[math.cos(theta_r),  0.,  math.cos(abs(math.pi/2. - theta_r)) ],\
                                     [0.,                 1.,  0.],\
                                     [math.cos(3.*math.pi/2. - theta_r),  0., math.cos(theta_r)]]


        # Now translate each x,y,z point to the rotated frame and convert to r,theta,phi in the lab frame
        # Start with some dummy point so we can pick the correct rotation matrix for a starting point.
        phi_theta_points = []
        p_z = distance_from_target
        for i in range(len(boundary_xy_points)):
            p_x,p_y = boundary_xy_points[i]
            if not i == (len(boundary_xy_points) - 1):  
                # If it's not the last point
                next_p_x,next_p_y = boundary_xy_points[i+1]
            else:
                # This is the last point, so the last line returns to the first
                # point defined.
                next_p_x,next_p_y = boundary_xy_points[0]  # the first point in the list is the normal intersection.  We don't want to draw a line back to that.
            # Interpolate a large set of theta, phi points.  And convert to
            # theta,phi coordinates.  These can be trimmed later to the desired
            # number of meshpoints.

            delta_x = (next_p_x - p_x)/float(number_of_interpolation_points + 1)
            delta_y = (next_p_y - p_y)/float(number_of_interpolation_points + 1)

            theta_lab_max = -100000.
            theta_lab_min = 100000.
            phi_1 = 100000.
            phi_2 = -100000.
            for point in range(-1,number_of_interpolation_points):  # Starting with -1 just to set the theta_lab variable.  This point will be skipped in the output.
                # Now transform to the displaced plane, displaced in the z direction by z_normal_lab.
                # The rotation for theta rotation must be done first!
                if point == -1 and i == 0:
                    # Start with some dummy point to be deleted later
                    theta_lab = 0.1
                position_vector = [p_x,p_y,p_z]
                # rotation matrix about the y axis 

                theta_transformed_vector = [0.,0.,0.]
                for k in range(3):
                    for l in range(3):
                        theta_transformed_vector[k] += theta_rotation_matrix[k][l] * position_vector[l] 

                x_rotated,y_rotated,z_rotated = theta_transformed_vector

                try:
                    # Since the range of atan is restricted to the 0 to 90 deg and 0 to -90 degree quadrants, 
                    # we have to manually correct for the actual quadrant in the x<0 quadrants to 
                    # get phi values between 0 and 360 degrees.  This might fail for very large detectors or 
                    # detectors extremely close to the target.
                    phi_lab = math.atan(y_rotated/x_rotated)
                    if y_rotated >= 0. and x_rotated < 0.:
                        phi_lab   -= math.pi 
                    elif y_rotated <= 0. and x_rotated < 0.:
                        phi_lab   += math.pi 

                    
                    # Since we have defined the 0 x coordinate as the phi_r coordinate, all we have to do to phi is add phi_r
                    # to make the transformation.
                    if math.degrees(phi_r) >= 360.:
                        # Protection against problems defining across the 360 degree boundary
                        phi_r = 0. + phi_r - math.radians(360.)
                    phi_lab += phi_r 

                    # Make the values wrap around to zero, for smooth interpolation. 
                    if phi_lab > (2.*math.pi):
                        phi_lab =  2.*math.pi -  phi_lab 

                    skip = False

                except:
                    skip = True
                if not skip and not point == -1:
                    r = math.sqrt(x_rotated**2 + y_rotated**2 + z_rotated**2)
                    theta_lab = math.acos(z_rotated/r)
                    if theta_lab > math.pi:
                        theta_lab -= math.pi
                    # Store the theta,phi points
                    phi_lab_degrees = math.degrees(phi_lab)
                    theta_lab_degrees = math.degrees(theta_lab)
                    if phi_lab_degrees > phi_2:
                        phi_2 = phi_lab_degrees
                    if phi_lab_degrees < phi_1:
                        phi_1 = phi_lab_degrees
                    if theta_lab_degrees > theta_lab_max:
                        theta_lab_max = theta_lab_degrees
                    if theta_lab_degrees < theta_lab_min:
                        theta_lab_min = theta_lab_degrees
                    phi_theta_points.append([phi_lab_degrees,theta_lab_degrees])

                # Increment the point p (z is same, because we are in the plane parallel to the x,y plane.
                if not point == -1:
                    p_x += delta_x
                    p_y += delta_y

        return theta_lab_max,theta_lab_min,phi_2,phi_1,phi_theta_points,theta_r,phi_r

    def make_NFI_list(self,phi_theta_points,number_of_theta_meshpoints):
        """Generates the NFI dictionary for the experiment under construction.

        This is only appropriate for "arbitrary" detector shapes, defined in 2D
        by the user.

        """

        # Unzip the phi_theta_points to get the min,max
        phi_list,theta_list = zip(*phi_theta_points)
        theta_lab_min = min(theta_list)
        theta_lab_max = max(theta_list)

        # Trace around the detector edges and record a dictionary of phi angles for each theta meshpoint reference by its index in the meshpoint list.
        NFI_list = []

        # Move just off of the edges to get a finite range for each interpolation point.
        theta_sample_list = list(numpy.linspace(theta_lab_min + 0.01,theta_lab_max - 0.01,number_of_theta_meshpoints))  

        for meshpoint_counter in range(number_of_theta_meshpoints):
            theta_sample = theta_sample_list[meshpoint_counter]
            temporary_meshpoint_phi_list = [theta_sample]
            for exact_shape_point_counter in range(len(phi_theta_points)):
                this_phi   = phi_theta_points[exact_shape_point_counter][0]
                this_theta = phi_theta_points[exact_shape_point_counter][1]
                next_phi   = phi_theta_points[(exact_shape_point_counter + 1) % (len(phi_theta_points) - 1)][0]  # "wrap" around to the beginning, if we hit the end.
                next_theta = phi_theta_points[(exact_shape_point_counter + 1) % (len(phi_theta_points) - 1)][1]
                if (this_theta < theta_sample and theta_sample < next_theta) or (theta_sample > next_theta and theta_sample < this_theta):
                    interpolated_phi = this_phi + (theta_sample - this_theta)*(next_phi - this_phi)/(next_theta - this_theta)
                    # Add to dictionary
                    temporary_meshpoint_phi_list.append(interpolated_phi)
            NFI_list.append(temporary_meshpoint_phi_list)

        # Now we have all the phi angles for each meshpoint.
        # Make sure there are a maximum of 4 and only an even number for each.
        for i in range(len(NFI_list)):
            this_theta = NFI_list[i][0]
            phi_list = NFI_list[i][1:]
            phi_list.sort()
            if len(phi_list) < 2:
                # Must have sampled at a local minimum or maximum.
                phi_list_previous = NFI_list[i - 1]
                try:
                    phi_list_next     = NFI_list[i + 1]
                except:
                    phi_list_next     = NFI_list[i - 1]
                try:
                    phi_list = [(min(phi_list_previous) + min(phi_list_next))/2.,(max(phi_list_previous) + max(phi_list_next))/2.]
                except:
                    phi_list = phi_list_next
            # Correct for an odd number of phi points or too many samples for gosia.
            while len(phi_list) > 8 or (not (len(phi_list) % 2) == 0):
                # an odd number of phi points.  Delete the middle one.
                del phi_list[len(phi_list)/2]
            if len(phi_list) >= 2:  # Don't add unless there is a line defined.
                NFI_list[i] = [this_theta]
                NFI_list[i].extend(phi_list)
                    
        return theta_lab_min,theta_lab_max,theta_sample_list,NFI_list

    def plot_sampled_detector_shape(self,phi_theta_points,NFI_list):
        """ Generates the sampled shape theta,phi data and calls the nucleus to draw it.

        Right now, it only draws for irregular shapes.

        """

        
        # Trace around the detector edges and record a dictionary of phi angles
        # for each theta meshpoint reference by its index in the meshpoint
        # list.  Overlay the exact shape on the downsampled shape:

        plot_points = phi_theta_points  

        # Get the exact minimum and maximum theta values.
        minimum_theta = 181.  
        maximum_theta = -1.
        for i in range(len(phi_theta_points) - 1):
            this_point = phi_theta_points[i]
            this_theta = this_point[1]
            this_phi   = this_point[0]
            if this_theta < minimum_theta:
                theta_lab_min = this_theta
            if this_theta > maximum_theta:
                theta_lab_max = this_theta


        title = "Exact and down-sampled detector shape"
        x_label = "phi [degrees]"
        y_label = "theta [degrees]"


        # Now add to the plot the phi ranges
        sample_lines = []   # The downsampled shape given to gosia as a list of lines to plot:
        #[[theta,phi_1,phi_2,],[theta,phi_1,phi_2,phi_3,phi_4],...]
        for i in range(len(NFI_list)):
            theta = NFI_list[i][0]   
            phi_list = NFI_list[i][1:]
            number_of_segments = len(phi_list)/2
            samples_for_this_theta = []
            for one_segment in range(number_of_segments):
                low_phi = phi_list[2 * one_segment]
                high_phi = phi_list[2 * one_segment + 1]
                samples_for_this_theta.extend([low_phi,high_phi])
            sample_lines.append(samples_for_this_theta)

        investigated_nucleus.draw_a_particle_detector(plot_points,title,x_label,y_label,None,None,NFI_list)

        return 0

    def print_all_meshpoints(self):
        """Prints the number of meshpoints for all experiments.

        """

        print "                 beam    scattering"
        print "                 energy  theta"
        print "-----------------------------------------------"
        for internal_experiment_number in range(len(self.allexperiments)):
            gosia_experiment_number = internal_experiment_number + 1
            print "Experiment ",gosia_experiment_number,":   ",self.allexperiments[internal_experiment_number].get_parameter("number_of_energy_meshpoints"),"    ",self.allexperiments[internal_experiment_number].get_parameter("number_of_theta_meshpoints")

        return 0

    def check_for_problems(self,quiet=True):
        """Returns text output and advice if there are problems with the setup.

        If the setup seems ok, 0 is returned.  If there are problems that will
        crash Gosia, returns -1.

        if quiet is True, then only problems are reported.  If quiet is False,
        then a report is printed even if there are no problems.

        """

        warning_lines = []
        warning_issued = False


        # A list of warnings with the limits of Gosia included.
        too_many_data_sets = "There are too many data sets (individual Ge crystals + Ge clusters) in the following experiments.  The limit in Gosia is " + str(MAXIMUM_DETECTORS_PER_EXPERIMENT) + " data sets per experiment.  You will have to delete one or more detectors from these experiment before running Gosia.\nIf you have just added detectors, you can use the \"Undo\" button to remove them.\n"
        too_many_data_sets_text = block_print_with_line_breaks(too_many_data_sets,line_length=50,silent=True)
        too_many_experiments = "There are too many experiments defined.  The limit in Gosia is " + str(MAXIMUM_EXPERIMENTS) + " experiments.  You will have to delete one or more experiments before running Gosia.\nIf you have just added detectors, you can use the \"Undo\" button to remove them.\n"
        too_many_experiments_text = block_print_with_line_breaks(too_many_experiments,line_length=50,silent=True)

        # Check to see if there are too many experiments.
        if self.getnumberofexperiments() > MAXIMUM_EXPERIMENTS:
            warning_lines.extend(too_many_experiments_text)
            warning_issued = True

        # Check for too many detectors in an experiment.
        numbers_of_data_sets = self.get_numbers_of_detectors()
        data_sets_warning_issued = False
        number_of_experiments = self.getnumberofexperiments()
        for internal_experiment_number in range(number_of_experiments):
            gosia_experiment_number = internal_experiment_number + 1
            experiment_object = self.allexperiments[internal_experiment_number]
            number_of_data_sets = numbers_of_data_sets[internal_experiment_number]
            if number_of_data_sets > MAXIMUM_DETECTORS_PER_EXPERIMENT:
                warning_issued = True
                if not data_sets_warning_issued:
                    # Issue the general warning about numbers of detectors only once.
                    warning_lines.extend(too_many_data_sets_text)

                # Add a notice about this experiment if it has too many detectors.
                detectors_in_this_experiment = experiment_object.get_number_of_detectors()
                this_warning_text = "Experiment " + str(gosia_experiment_number) + " has " + str(detectors_in_this_experiment) + " detectors."
                warning_lines.append(this_warning_text)
                

        # Loop over experiments to search for problems with the setup.
        for internal_experiment_number in range(number_of_experiments):
            gosia_experiment_number = internal_experiment_number + 1
            experiment_object = self.allexperiments[internal_experiment_number]

            # Check this experiment for quantities that exceed Gosia's memory limits.
            # UNFINISHED!
                
        if not warning_issued:
            warning_lines.append("No problems found in the experiment definitions.")

        if warning_issued:
            setup_problems_popup = dialog_popup({"text_lines":warning_lines,"title":"Experimental setup issues that need attention"})
        elif not quiet:
            setup_problems_popup = dialog_popup({"text_lines":warning_lines,"title":"Experimental setup issues that need attention"})

        if warning_issued:
            return -1
        else:
            return 0
        
    def is_ready(self):
        """Returns true if at least one experiment is defined and each experiment has at least one detector.

        Otherwise, returns False.

        """

        if self.getnumberofexperiments() == 0:
            return False
        else:
            for one_experiment in self.allexperiments:
                if one_experiment.get_number_of_detectors() == 0:
                    return False

        return True


    def save_current_experiments(self):
        self.saved_experiments = copy.deepcopy(self.allexperiments) # need deepcopy?
        self.saved_user_experiments = True
        return 0

    def restore_saved_experiments(self):
        if self.saved_user_experiments:
            self.delete_experiment(True)  # True forces with no interactive prompting.
            self.allexperiments = copy.deepcopy(self.saved_experiments)
            self.saved_user_experiments = False
            print "Original experiments have been restored."
            return 0
        else:
            print "No experiments were temporarily saved."
            return -1
            


    def test_integration_convergence(self):
        """Generates experiments to integrate piecewise, and sums the resulting yields.

        This is meant to test that an integration or simulated yield
        calculation resulting in no errors reported by Gosia has actually
        converged.

        """

        block_print_with_line_breaks("\nThis test evaluates only one selected experiment each time it is run.  It may take a long time for large level schemes (expect about 1--2 minutes per matrix element), but once it is complete, if it reports that your integration accuracy (Help topic \"integrationaccuracy\") is satisfactory, then you will be able to trust all future calculations with this experiment, level scheme and matrix.\n")

        if not yes_no_prompt("Do you want to continue [Y/n]? ",True):
            return 0
        print ""

        # Don't want too many pieces, or the yields will be below threshold.
        pieces = max(2 * int(max(float(MAXENERGYMESHPOINTS)/float(DEFAULT_ENERGY_MESHPOINTS),float(MAXTHETAMESHPOINTS)/float(DEFAULT_THETA_MESHPOINTS))),10)# The number of piecewise integrations (plus one)

        
        self.print_experiment_catalog()
        while True:
            try:
                internal_experiment_number = prompt_number("Enter the experiment number to base the test on, or \"q\" to quit: ","i")
                if internal_experiment_number == "quit":
                    return 0
                internal_experiment_number -= 1
                self.allexperiments[internal_experiment_number] # test for existence of the experiment
                break
            except:
                print "Please enter an existing experiment number."

        # Save the current experimental setup, so that it can be restored after deleting experiments for the test.
        self.save_current_experiments()

        percent_discrepancy_limit_for_reporting = prompt_number("Minimum % error in convergence for reporting: ","f")
        if percent_discrepancy_limit_for_reporting == "quit":
            return 0
        
        
        print "Start of test ti: ",get_system_time_stamp()

        # Save the gosia.gdt file to a temporary list
        with open("gosia.gdt","r") as gdt_file:
            original_gdt_lines = gdt_file.readlines()

        new_gdt_file_lines = ["1\n",\
                          "25.250000000000000     \n",\
                            "5.00000007450580597E-002\n",\
                            "0.  0.  0.99514773792810363 \n",\
                            "0.  0.  0.98549026565841702 \n",\
                            "0.  0.  0.97112111660820433 \n",\
                            "0.  0.  0.95217917281887521 \n",\
                            "0.  0.  0.93794497620683592 \n",\
                            "0.  0.  0.90134856707041400 \n",\
                            "0.  0.  0.86994669878926978 \n",\
                            "0.  0.  0.83493976674575587 \n"]

        # Write a 4pi detector to a new gdt file:
        # Gosia doesn't seem to complain if it can't find the detector in the gdt file and defaults to det # 1.
        with open("gosia.gdt","w") as gdt_file:
            gdt_file.writelines(new_gdt_file_lines)

        # DO THIS FASTER BY INTEGRATING ONLY THE TEST EXPERIMENT!
        experiments_to_delete = range(len(self.allexperiments))
        experiments_to_delete.remove(internal_experiment_number)
        # work backward when deleting from a list!
        experiments_to_delete.reverse()
        for one_experiment in experiments_to_delete:
            error_code = self.delete_experiment(False,one_experiment)
            if error_code == -1:
                # Restore the old gdt file
                with open("gosia.gdt","w") as gdt_file:
                    gdt_file.writelines(original_gdt_lines )
                print "Could not perform test \"ti\"."
                self.restore_saved_experiments()
                return -1
        # Now the experiment is number 0 (internal)
        internal_experiment_number = 0
        self.allexperiments[internal_experiment_number].set_parameter("LN",1)

        # Get the yields for this experiment integrated in one piece.
        try:
            error_code = the_gosia_shell.generate("Integrated yields","Run gosia input")
        except:
            print "This test cannot continue because of the error reported above."
            self.restore_saved_experiments()
            return -1
        if error_code == -1:
            print "Gosia killed by user or cannot run Gosia.  Check for errors above."
            self.restore_saved_experiments()
            return -1

        # Get the yields for detector 0 (4pi Ge)
        full_integration_yields = self.allexperiments[internal_experiment_number].get_calculated_yields(0)
        full_integration_yields.sort()

        #print "Now testing a piecewise integration.  This may take a long time...\n"
        # Now the piecewise test.
        # Generate a list of theta limits for the piecewise integration.
        test_experiment_parameter_dict = copy.deepcopy(self.allexperiments[internal_experiment_number].parameter_dict)
        theta_lab_min = test_experiment_parameter_dict["theta_lab_min"]
        theta_lab_max = test_experiment_parameter_dict["theta_lab_max"]
        theta_list = list(numpy.linspace(theta_lab_min,theta_lab_max,pieces))

        subdivision_iteration_counter = 0
        meshpoint_iteration_counter = 0

        original_Ge_detectors = copy.deepcopy(self.allexperiments[internal_experiment_number].Ge_detectors)

        result = False
        while not result:
            # Delete all experiments
            self.delete_experiment(True)   # True means to delete all without interactive prompting.

            # Generate new experiments to integrate piecewise.
            for i in range(len(theta_list) - 1):
                parameter_dict = copy.deepcopy(test_experiment_parameter_dict)
                parameter_dict["theta_lab_min"] = theta_list[i]
                parameter_dict["theta_lab_max"] = theta_list[i + 1]
                #Ge_detectors = [[0, 0.0, 0.0]]
                #parameter_dict["Ge Normalizations"] = [1.0]
                parameter_dict["number_of_energy_meshpoints"] = 20 - (10 * meshpoint_iteration_counter)
                parameter_dict["number_of_theta_meshpoints"] = 40 - (10 * meshpoint_iteration_counter)

                if parameter_dict["number_of_theta_meshpoints"] <= 10 or parameter_dict["number_of_energy_meshpoints"] <=10:
                    parameter_dict["theta_subdivisions"] = 100 - (10 * subdivision_iteration_counter)
                    parameter_dict["energy_subdivisions"] = 100 - (10 * subdivision_iteration_counter)
                else:
                    parameter_dict["theta_subdivisions"] = 100 
                    parameter_dict["energy_subdivisions"] = 100 

                if parameter_dict["theta_subdivisions"] <= 0 or parameter_dict["energy_subdivisions"] <=0 or\
                  parameter_dict["number_of_energy_meshpoints"] <=0 or parameter_dict["number_of_theta_meshpoints"] <=0:
                    print "Could not perform piecewise integration part of test."
                    print "Please report this as a possible bug."
                    # Restore the old gdt file
                    with open("gosia.gdt","w") as gdt_file:
                        gdt_file.writelines(original_gdt_lines )
                    self.restore_saved_experiments()
                    return -1
                self.allexperiments.append(copy.deepcopy(experiment(parameter_dict,False,True)))
                # Put the original Ge detectors on this experiment
                self.allexperiments[-1].Ge_detectors = copy.deepcopy(original_Ge_detectors)

            # Run the piecewise integrations
            try:
                # Replace this line after debugging.
                error_code = the_gosia_shell.generate("Integrated yields","Run gosia input",False,True)  # False means not for tf point calcs; True means to act silently.
                #error_code = the_gosia_shell.generate("Integrated yields","Run gosia input")
                result = True
            except:
                print "Gosia ran out of memory for the test.  Iterating to find maximum E-theta mesh space.\nPlease wait..."
                if parameter_dict["number_of_theta_meshpoints"] <= 10 or parameter_dict["number_of_energy_meshpoints"] <=10:
                    subdivision_iteration_counter += 1
                meshpoint_iteration_counter += 1
                result = False

            if error_code == -1:
                print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                self.restore_saved_experiments()
                return -1

        # Now we have integrated yields for many experiments that can be summed.
        self.parse_gosia_integrated_yields(True) # True usually means for the tf function, but it really just sets a lower limit for accepting yields.
        yield_set = []
        for i in range(pieces-1):
            yield_set.append(self.allexperiments[i].get_calculated_yields(0))  
        # Sort yields by initial, final state number
        yield_set[i].sort()

    
        # Make a list of all the transitions that have a yield above the
        # threshold from the experiment with the longest list of yields.
        maximum_transitions = 0
        for i in range(pieces-1):
            transitions_in_this_set = len(yield_set[i])
            if transitions_in_this_set > maximum_transitions:
                maximum_transitions = transitions_in_this_set
                longest_set_index = i

        # Start the sum with the longest set
        sum_of_piecewise_yields = yield_set[longest_set_index]

        # Now sum all of the observable transitions
        for j in range(len(sum_of_piecewise_yields)):
            one_entry = sum_of_piecewise_yields[j]
            for i in range(len(yield_set)):
                if not i == longest_set_index:
                    one_set = yield_set[i]
                    for one_yield in one_set:
                        # Get the level keys for this transition
                        initial_band_name, initial_spin, final_band_name, final_spin, calculated_yield = one_yield
                        initial_level_key = (initial_band_name, initial_spin)
                        final_level_key = (final_band_name, final_spin)
                        if one_yield[:4] == one_entry[:4]:
                            one_entry[4] += one_yield[4]
                            # Replace new subtotal entry in sum_of_piecewise_yields
                            sum_of_piecewise_yields[j] = one_entry


        # Now compare the piecewise sum with the 4pi integrated yields:
        list_of_compared_yields = []
        maximum_percent_discrepancy = 0.
        for j in range(len(full_integration_yields)):
            one_4pi_entry = full_integration_yields[j]
            for i in range(len(sum_of_piecewise_yields)):
                one_piecewise_entry = sum_of_piecewise_yields[i]
                if one_4pi_entry[:4] == one_piecewise_entry[:4]:
                    four_pi_yield = one_4pi_entry[4]
                    piecewise_total_yield = one_piecewise_entry[4]
                    percent_discrepancy = ((four_pi_yield - piecewise_total_yield) * 100.)/piecewise_total_yield
                    comparison_entry = one_4pi_entry[:4]
                    comparison_entry.extend([four_pi_yield,piecewise_total_yield,percent_discrepancy])
                    if abs(percent_discrepancy) > abs(maximum_percent_discrepancy):
                        maximum_percent_discrepancy = percent_discrepancy
                    list_of_compared_yields.append(comparison_entry)

        report_string = "\nMaximum error in convergence for all yields in this experiment is " +\
          str(round(maximum_percent_discrepancy,1)) +"%\n"
        print report_string
        print "Read topic integrationaccuracy using the Help button, if this error is unacceptable."

        # Restore the old gdt file
        with open("gosia.gdt","w") as gdt_file:
            gdt_file.writelines(original_gdt_lines )


        # For now, print the discrepancies.  Later, they can be drawn on the level scheme (the large ones).
        reported_a_discrepancy = False
        for one_entry in list_of_compared_yields:
            initial_band_name, initial_spin, final_band_name, final_spin, integration_over_full_range, piecewise_integration, percent_discrepancy = one_entry
            if abs(percent_discrepancy) > abs(percent_discrepancy_limit_for_reporting):
                if not reported_a_discrepancy:
                    print "                                         Convergence error in"
                    print "Transition                               this transition   "
                    print "-------------------------------------------------------------"
                discrepancy_string = str(round(percent_discrepancy,max(int(-1.*(math.log10(percent_discrepancy_limit_for_reporting)))+2,1)))
                length_of_discrepancy_string = len(discrepancy_string)+8
                if percent_discrepancy < 0.:
                    length_of_discrepancy_string -= 1
                line_to_print = initial_band_name.ljust(10) + " " + str(initial_spin).ljust(4) + " --> " +\
                final_band_name.ljust(10) + " " + str(final_spin).ljust(4) + "   "\
                + discrepancy_string.rjust(length_of_discrepancy_string) + "%"
                print line_to_print
                reported_a_discrepancy = True

        block_print_with_line_breaks("If the error(s) reported above are unacceptable, you may want to run test \"tf\" under the same Tools button to search for high-adiabaticity or high-eccentricity problems that may be causing the divergence.")

        print "End of test ti: ",get_system_time_stamp()
        self.restore_saved_experiments()
        return 0



    def generate_one_4pi_integration(self,internal_experiment_number):
        """Generates one experiment covering nearly the full scattering range.

        """

        experiment_parameter_dict = self.allexperiments[internal_experiment_number].get_full_parameter_dict()
        A_proj = self.allexperiments[internal_experiment_number].A_projectile()
        A_targ = self.allexperiments[internal_experiment_number].A_target()
        detected_particle = self.allexperiments[internal_experiment_number].get_parameter("detected_particle")
        is_inverse = self.allexperiments[internal_experiment_number].is_inverse_kinematics()
        if is_inverse:
            theta_lab_max = 89.
        else:
            theta_lab_max = 178.
        theta_lab_min = 10.
        self.delete_experiment(True)   # True means to delete all without interactive prompting.
        self.newexperiment(True,experiment_parameter_dict)
        self.allexperiments[0].set_parameter("detected_particle", "t")
        self.allexperiments[0].set_parameter("theta_lab_min", theta_lab_min)
        self.allexperiments[0].set_parameter("theta_lab_max", theta_lab_max)
        theta_lab_mean = (theta_lab_min + theta_lab_max)/2.
        self.allexperiments[0].set_parameter("theta_lab_mean",theta_lab_mean)
        self.allexperiments[0].set_parameter("LN",1)
        # Add one Ge detector
        Ge = [[0, 0.0, 0.0]]
        self.allexperiments[0].set_parameter("Ge",Ge)
        self.allexperiments[0].set_parameter("Ge Normalizations", [1.0])

        print "Test experiment generated.  No errors."
        return 0

    def generate_4pi_experiments(self,dependent_norm=False):
        """Generates 50 experiments covering almost 0 to 90 degrees.

        If this is based on an inverse-kinematics experiment, then the
        experiments stop a few degrees before the maximum scattering angle, but
        50 are generated in any case.

        This must be run after save_current_experiments.

        If "dependent_norm" is set to True, then all experiments are normalized
        to experiment 1.  This makes no difference to integrations, so if this
        is only used for the adiabaticity and convergence tests, there should
        be no need to set this parameter.

        """
        theta_subdivisions = 50
        energy_subdivisions = 20

        self.print_experiment_catalog()
        good_experiment = False
        while not good_experiment:
            internal_experiment_number = prompt_number("Which experiment would you like to base the tests on? ","i")
            if internal_experiment_number == "quit":
                return 0
            internal_experiment_number -= 1

            try:
                parameter_dict = copy.deepcopy(self.allexperiments[internal_experiment_number].parameter_dict)
                good_experiment = True
            except:
                pass

        print "Generating point calculations..."
        print ""

        A_proj = self.allexperiments[internal_experiment_number].A_projectile()
        A_targ = self.allexperiments[internal_experiment_number].A_target()
        detected_particle = self.allexperiments[internal_experiment_number].get_parameter("detected_particle")
        is_inverse = self.allexperiments[internal_experiment_number].is_inverse_kinematics()

        # Get the Ge detectors from this experiment before deleting it.
        original_ge_detectors = self.allexperiments[internal_experiment_number].Ge_detectors

        # Set the kinematics state to the ground state, so that we can
        # calculate the maximum scattering angle consistent with the temporary
        # setting of NCM=1.
        the_gosia_shell.gosia_kinematics_state = 1

        if  is_inverse:
            if detected_particle == "b":
                theta_lab_max = min(70.,inelastic_maximum_scattering_angle(A_proj,A_targ,1.0,0.0))  # Elastic: Q=0, Ebeam is irrelevant.
            elif detected_particle == "t":
                theta_lab_max = 70.
        else:
            # Normal kinematics
            theta_lab_max = 89.
            #if detected_particle == "b":
                #theta_lab_max = 179.
            #elif detected_particle == "t":
                #theta_lab_max = 89.

        # Generate a list of angles in the range determined above.
        theta_values_list = list(numpy.linspace(0.1,theta_lab_max,51))
        

        experiment_counter = 0
        self.delete_experiment(True)   # True means to delete all without interactive prompting.
        for i in range(len(theta_values_list)-1):
            parameter_dict["theta_lab_min"] = theta_values_list[i]
            parameter_dict["theta_lab_max"] = theta_values_list[i+1]
            theta_lab_mean = (theta_values_list[i] + theta_values_list[i+1])/2.
            parameter_dict["theta_lab_mean"] = theta_lab_mean
            if dependent_norm:
                parameter_dict["LN"] = 1
            else:
                parameter_dict["LN"] = i + 1
            # Add the experiment
            #print "parameter_dict: ",parameter_dict
            self.allexperiments.append(copy.deepcopy(experiment(parameter_dict,True,True)))
            self.allexperiments[i].set_theta_subdivisions(theta_subdivisions)
            self.allexperiments[i].set_energy_subdivisions(energy_subdivisions)
            # Add the Ge detectors from the original experiment.  This is done without an accessor.
            self.allexperiments[i].Ge_detectors = copy.deepcopy(original_ge_detectors)
            # Now add YNRM values of 1.0 for all Ge detectors.
            Ge = self.allexperiments[i].Ge_detectors
            for ge_detector in Ge:
                ge_detector.set_normalization_constant(1.)
            experiment_counter += 1
            if experiment_counter == 50:
                break

        print "All test experiments generated.  No errors."
        return internal_experiment_number


    def read_Q_vs_time(self,lambda_number):
        """Reads collision function vs. omeaga for all experiments.

        """

        step_size               = 0.03 # Assumes a fixed step size in gosia output.

        # Get the gosia output file name and the name of the amplitude file
        # from the gosia shell.  Note that the amplitude file is only generated
        # by a special patched gosia version for Rachel.

        gosia_collision_function_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[99]["extension"]

        print "  Reading Gosia output..."
        # Read the gosia amplitude file lines.
        with open(gosia_collision_function_file_name,'r') as gosia_collision_function_file:
            gosia_collision_function_lines = gosia_collision_function_file.readlines()

        print "  Done."

        number_of_experiments = self.getnumberofexperiments()

        print "  Collecting collision function data.  This may take a few minutes..."

        collision_function_line_number = 0

        # Each experiment has a table produced twice (probably for
        # symmetrization of quantities before and after the collision).  I am
        # skipping the second one for now...

        for table_number in range(2 * number_of_experiments):
            print "Table",table_number
            if (table_number % 2) == 0:  
                # Skip every other table.
                collision_functions_dictionary = {}
                while True:
                    if collision_function_line_number < (len(gosia_collision_function_lines)):  # Not at end of the file.
                        collision_function_line = gosia_collision_function_lines[collision_function_line_number].replace("D","E")
                        if not "The" in collision_function_line and not "mu" in collision_function_line and not "Qe" in collision_function_line:
                            # this is a data line.
                            line_fields = collision_function_line.split()
                            integration_step_number = int(line_fields[0])
                            maximum_mu = lambda_number   # only tabulated for positive values of lambda.
                            for mu in range(maximum_mu + 1):
                                # Q is calculated by a polynomial in hyperbolic
                                # sin, cos, etc., so step "1" should correspond to
                                # omega = 0, unlike the quantities calculated by
                                # the predictor-corrector method.
                                omega = (integration_step_number - 1) * step_size  # dimensionless parameter omega
                                column_number = mu * 3 + 2
                                Q = float(line_fields[column_number])
                                collision_function_list = [omega,Q]
                                if mu in collision_functions_dictionary.keys():
                                    collision_function_data = collision_functions_dictionary[mu]
                                    collision_function_data.append(collision_function_list)
                                else:
                                    collision_function_data = [collision_function_list]
                                collision_functions_dictionary[mu] = collision_function_data

                            if lambda_number == 3 and omega > 4.34:
                                # Then I have run into the next collision function.
                                # Store the data for this table.
                                data_storage_key = "collision function data " + str(table_number / 2)  # only works for storing even tables
                                temporary_data_storage.set(data_storage_key,collision_functions_dictionary)
                                collision_function_line_number +=255  # Skip to next table
                                break

                            if integration_step_number == 200:
                                # The next line corresponds to the next experiment.
                                # Store the data for this table.
                                data_storage_key = "collision function data " + str(table_number / 2)  # only works for storing even tables
                                temporary_data_storage.set(data_storage_key,collision_functions_dictionary)
                                collision_function_line_number +=201  # Skip to next table
                                break

                        collision_function_line_number += 1
                    else:
                        break



        print "  Done."

        return 0

    def read_amplitudes_vs_time(self):
        """Reads amplitude vs. omeaga for all states.

        Reads the standard gosia output from op,star first to assemble a
        catalog of gosia substate index vs. internal level number and magnetic
        substate.

        This only works following an op,star calculation.

        """

        # Get the gosia output file name and the name of the amplitude file
        # from the gosia shell.  Note that the amplitude file is only generated
        # by a special patched gosia version for Rachel.

        gosia_output_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[22]["extension"]
        gosia_amplitude_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[99]["extension"]

        print "  Reading Gosia output..."
        # Read the gosia output file from disk.  
        with open(gosia_output_file_name,'r') as gosia_output_file:
            gosia_output_lines = gosia_output_file.readlines()

        # Read the gosia amplitude file lines.
        with open(gosia_amplitude_file_name,'r') as gosia_amplitude_file:
            gosia_amplitude_lines = gosia_amplitude_file.readlines()

        print "  Done."

        number_of_experiments = self.getnumberofexperiments()

        # Lookup by I,Mf returns gosia substate number.
        substate_dictionary = {}  
        # Reverse substate_dictionary: key (gosia_substate_number) will point to
        # internal level number and M substate
        reverse_substate_dictionary = {}

        gosia_substate_number = 1  

        print "  Collecting magnetic substate catalog data..."

        while True:
            # Parse the output file for a catalog of substate number and internal
            # level number, magnetic substate.
            initial_substate_line = findinlist(gosia_output_lines,["EXCITATION","AMPLITUDES"]) + 2
            if initial_substate_line == 1:
                # No more data in file.
                break
            initial_substate_line_fields = gosia_output_lines[initial_substate_line].split()
            initial_M = round(float(initial_substate_line_fields[1]),1) # rounded to the nearest half integer


            internal_experiment_number = int(initial_substate_line_fields[3]) - 1  # internal numbering
            level_line = initial_substate_line + 5  # the first line containing level amplitude data.

            # Note that "initial_M" is the ground state initial polarization, while
            # "M" below is the final magnetic quantum number for a given state.


            while True:
                # Step through all lines for this experiment to get the level indices.
                line = gosia_output_lines[level_line]
                line_fields = line.split()
                if len(line_fields) < 2:
                    # No more data for this experiment
                    break  # out of nearest while loop to read substate data.
                level_string, spin_string, M_string, real_string, imaginary_string = line_fields
                # Not keeping the final amplitudes.
                internal_level_number = int(level_string) - 1  # internal numbering
                spin = round(float(spin_string),1)   # rounded to the nearest half integer
                Mf   = round(float(M_string),1)      #    "

                final_real_amplitude = float(real_string)
                final_imaginary_amplitude = float(imaginary_string)
                final_probability = final_real_amplitude**2 + final_imaginary_amplitude**2
                final_probability_string = str(final_probability)
                # Add this substate to the dictionary for this experiment
                reverse_substate_dictionary[gosia_substate_number] = [internal_level_number,Mf]
                substate_dictionary[(internal_level_number,Mf)] = gosia_substate_number  # reverse lookup
                r_s = str(reverse_substate_dictionary[gosia_substate_number]) + str(substate_dictionary[(internal_level_number,Mf)])

                # Increment the gosia substate number. 
                gosia_substate_number += 1

                level_line += 1
                l_s = str(gosia_substate_number) + str(level_line)

            break  # For now, trusting that all experiments have (possibly zero) population data for all levels.
            #del gosia_output_lines[:level_line]  # Delete the lines parsed from the list 
            # Now the file lines can be searched for the next appearance of "EXCITATION AMPLITUDES".

        print "  Done."

        # Give the substate dictionary to the nucleus:
        investigated_nucleus.substate_dictionary = substate_dictionary
        investigated_nucleus.reverse_substate_dictionary = reverse_substate_dictionary

        all_gosia_substates = reverse_substate_dictionary.keys()
        all_gosia_substates = list(all_gosia_substates)
        all_gosia_substates.sort()  # low to high substate number

        # Step through the amplitude vs. time lines and save each a(w) list for
        # each substate in each experiment.  Experiments are separated by a
        # blank line, and there is one blank line at the beginning of the file.
        amplitude_line_number = 1

        print "  Collecting amplitude a(w) data..."

        for internal_experiment_number in range(self.getnumberofexperiments()):
            amplitudes_dictionary = {}
            last_integration_step_number = 10000
            while True:
                if amplitude_line_number < (len(gosia_amplitude_lines)):  # Not at end of the file.
                    amplitude_line = gosia_amplitude_lines[amplitude_line_number].replace("D","E")
                    line_fields = amplitude_line.split()
                    if len(line_fields) > 2:
                        integration_step_number = int(line_fields[0])
                        step_size               = float(line_fields[1])
                        if integration_step_number < last_integration_step_number:
                            omega = -1. * (integration_step_number + 1) * step_size  # dimensionless parameter omega
                        else:
                            # Crossed omega=0.  The first three steps aren't
                            # included, because the derivatives are still being
                            # calculated.
                            omega = (integration_step_number - 3) * step_size  # dimensionless parameter omega

                        for gosia_substate_number in all_gosia_substates:
                            internal_level_number, M = investigated_nucleus.reverse_substate_dictionary[gosia_substate_number]
                            # The column number formula assumes that only positive substates were store in the substate dictionary.
                            column_number = (gosia_substate_number - 1) * 4 + 2
                            this_state_fields = line_fields[column_number:column_number + 4]
                            substate_string, real_string, imaginary_string, probability_string = this_state_fields
                            this_substate_number = int(substate_string)
                            real_part = float(real_string)
                            imaginary_part = float(imaginary_string)
                            probability = float(probability_string)
                            if not this_substate_number == gosia_substate_number:
                                print "Error parsing a(omega) output."
                                return -1
                            amplitude_list = [omega,real_part,imaginary_part,probability]
                            if gosia_substate_number in amplitudes_dictionary.keys():
                                amplitudes_dictionary[gosia_substate_number].append(amplitude_list)
                            else:
                                amplitudes_dictionary[gosia_substate_number] = [amplitude_list]

                        last_integration_step_number = integration_step_number
                        amplitude_line_number += 1
                    else:
                        # This is the end of the experiment.
                        amplitude_line_number += 1
                        break # out of while loop for this experiment.

                else:
                    # Reached end of file.
                    #print "reached end of file."
                    break  # out of experiment counter loop

            #print "saving experiment ", internal_experiment_number
            data_storage_key = "amplitude data " + str(internal_experiment_number)
            temporary_data_storage.set(data_storage_key,amplitudes_dictionary)
            #print "example: ",amplitudes_dictionary[1][:5]

        print "  Done."

        return 0


    def plot_Q_vs_time(self,lambda_number):
        """Plots collision functions stored in temporary memory.

        """

        plot_data_file_name = "temporary_rachel_collision.txt"

        # Check that there are data in memory to plot.
        data_storage_key = "collision function data " + str(0)   # stored according to mu value
        try:
            temporary_data_storage.get(data_storage_key)
        except:
            return -2  

        # Let the user examine plots by level number and magnetic substate and experiment number.
        while True:
            self.print_experiment_catalog()
            gosia_experiment_number = prompt_number("Experiment number: ","i") 
            if gosia_experiment_number == "quit":
                return 0
            internal_experiment_number = gosia_experiment_number - 1
            mu          = prompt_number("Enter mu as in Q(lambda,mu): ","i")
            if mu < 0:
                mu = abs(mu)
                print "mu taken as +",mu, " (Refer to the Gosia manual for symmetry properties.)"
            if mu == "quit":
                return 0

            # Should use the before & after tables for this experiment to get a
            # symmetrized value.  NOT DOING THIS YET.

            table_number = internal_experiment_number
            data_storage_key = "collision function data " + str(table_number)
            all_mu_data = temporary_data_storage.get(data_storage_key)
            all_data_before  = all_mu_data[mu]

            omega_list = []
            Q_before   = []
            Q_after    = []
            Q_symmetrized = []

            # Get maximum Q:
#            temporary_omega_list, temporary_Q_before = zip(*all_data_before)
#            if max(temporary_Q_before) <= 0.:
#                sign = -1.
#            else:
#                sign = 1.

            for i in range(len(all_data_before)):
                omega = all_data_before[i][0]
                omega_list.append(omega)
                #Q_symmetrized.append((all_data_before[i][1] + all_data_after[i][1]) / 2.)
                #this_Q = sign * all_data_before[i][1]  # making at least some of the Q values positive.
                this_Q = abs(all_data_before[i][1])  
                Q_before.append(this_Q)  # Absolute value!
                #Q_after.append(all_data_after[i][1])

            # Generate files for gnuplot
            lines_to_write = []
            lines_to_write.append("#Magnitude of electric collision function \n")
            description = "#expt. " + str(internal_experiment_number + 1) + "\n"
            lines_to_write.append(description)
            description = "#lambda = " + str(lambda_number) + "\n"
            lines_to_write.append(description)
            description = "#mu = " + str(mu) + "\n"
            lines_to_write.append(description)
            nonzero = False
            for i in range(len(omega_list)):
                x = omega_list[i]
                y = Q_before[i]
                if not y==0.0:
                    nonzero = True
                this_text_line = str(x) + "     " + str(y) + "\n"
                lines_to_write.append(this_text_line)
            lines_to_write.append("\n\n")  # two blank lines to separate sets
            if not nonzero:
                return -1

            with open(plot_data_file_name,"w") as plot_data_file: 
                plot_data_file.writelines(lines_to_write)
            print "Data for this plot were written to the file \"" + plot_data_file_name + "\"."

            x_label = "w"
            y_label = "Q"
            calculated_legend = ["abs(Q[w])"]

            experimental_legend = None
            better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend)

        return 0



    def plot_amplitudes_vs_time(self):
        """Plots amplitude vs. time for all states.

        It is meant to be run only using the Tools "ta" function!

        This only works if the required file "*.amp" has been generated with a
        special patched version of gosia.


        """

        # Check that there are data in memory to plot.
        data_storage_key = "amplitude data " + str(0)  # Test for experiment 0
        try:
            temporary_data_storage.get(data_storage_key)
        except:
            return -2  # Flag to let the GUI know it needs to be re-integrated.

        plot_data_file_name = "rachel_amplitude_plot_data.txt"

        # Let the user examine plots by level number and magnetic substate and experiment number.
        self.print_experiment_catalog()
        while True:
            good_state = True
            print "Enter \"q\" to quit."
            gosia_experiment_number = prompt_number("Experiment number: ","i") 
            if gosia_experiment_number == "quit":
                return 0
            internal_experiment_number = gosia_experiment_number - 1
            if not (internal_experiment_number <= self.getnumberofexperiments()):
                good_state = False
            band_number = prompt_number("Band number: ","i")
            if band_number == "quit":
                break
            band_name   = investigated_nucleus.get_primary_band_name_from_band_number(band_number)
            if band_name == None:
                good_state = False
            I           = prompt_number("Spin: ","r")
            if I == "quit":
                break
            Mf          = prompt_number("Final polarization, Mf: ","r")
            if Mf == "quit":
                break

            # Get the real, imaginary parts of a and the probability and a list of omega points.
            data_storage_key = "amplitude data " + str(internal_experiment_number)
            all_data = temporary_data_storage.get(data_storage_key)

            internal_level_number = investigated_nucleus.lookup_internal_level_by_band_spin(band_name,I)

            # Get the data for this experiment and state.
            try:
                gosia_substate_number = investigated_nucleus.substate_dictionary[(internal_level_number,Mf)]
            except:
                good_state = False
                print "I,Mf = ", I,Mf, " substate not found."

            try:
                all_data[1]
            except:
                print "a(omega) data not found."
                return -1

            if good_state:
                # Sort for plotting by omega
                a_and_p_vs_omega = all_data[gosia_substate_number]
                a_and_p_vs_omega.sort()
                #print a_and_p_vs_omega
                omega, real_amplitude, imaginary_amplitude, probability = zip(*a_and_p_vs_omega)

                # Generate files for gnuplot
                lines_to_write = []
                for j in range(3):
                    for i in range(len(omega)):
                        x = a_and_p_vs_omega[i][0]
                        y = a_and_p_vs_omega[i][j + 1]
                        this_text_line = str(x) + "     " + str(y) + "\n"
                        lines_to_write.append(this_text_line)
                    lines_to_write.append("\n\n")  # two blank lines to separate sets

                with open(plot_data_file_name,"w") as plot_data_file: 
                    plot_data_file.writelines(lines_to_write)
                print "Data for this plot were written to the file \"" + plot_data_file_name + "\"."

                title_string = "Probability vs. time for Experiment " + str(gosia_experiment_number) +\
                  "\nI,M = " + str(I) + ", " + str(Mf) + " state averaged over initial Mi."
                x_label = "w"
                y_label = ""
                calculated_legend = ["Re[a(w)]","Im[a(w)]","P(w)"]

                low_x = min(omega)
                high_x = max(omega)
                low_p = min(probability)
                high_p = max(probability)
                low_r = min(real_amplitude)
                high_r = max(real_amplitude)
                low_i = min(imaginary_amplitude)
                high_i = max(imaginary_amplitude)

                experimental_legend = None
                better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend)

        return 0


    def find_all_inaccurate_transitions(self):
        """Tests for accuracy errors due to high adiabaticity and eccentricity.

        It is meant to be run only using the Tools "tf" function!

        """

        def find_yield_from_level_keys(initial_level_key,final_level_key,yield_list):
            for i in range(len(yield_list)):
                this_initial_band_name, this_initial_spin, this_final_band_name, this_final_spin, this_yield = yield_list[i]
                this_initial_level_key = (this_initial_band_name, this_initial_spin)
                this_final_level_key = (this_final_band_name, this_final_spin)
                if initial_level_key == this_initial_level_key and final_level_key == this_final_level_key:
                    return this_yield

        # Lists of flagged transitions that the user should investigate.
        adiabaticity_problem_transitions = []
        eccentricity_problem_transitions = []
        plots_to_make = []

        # Get the parameter dict from an arbitrary experiment
        experiment_parameter_dict = self.allexperiments[48].get_full_parameter_dict()
        # Detector 0 should give as good a test as any, because it is  the convergence
        # of the Coulex point calculations that are expected to diverge.
        all_calculated_yields_48 = self.allexperiments[48].get_calculated_yields(0)  
        all_calculated_yields_2 = self.allexperiments[2].get_calculated_yields(0)  
        if len(all_calculated_yields_48) > len(all_calculated_yields_2):
            all_calculated_yields = all_calculated_yields_48
        else:
            all_calculated_yields = all_calculated_yields_2
            
        # Find out if it's inverse or normal kinematics
        is_inverse = self.allexperiments[0].is_inverse_kinematics()

        # Form a list of all transitions in the calculation:
        list_of_transitions_to_test = []
        for one_yield_entry in all_calculated_yields:
            #initial_internal_level,final_internal_level,calculated_yield,normalized_yield = one_yield_entry
            initial_band_name, initial_spin, final_band_name, final_spin, calculated_yield = one_yield_entry
            initial_level_key = (initial_band_name, initial_spin)
            final_level_key = (final_band_name, final_spin)
            list_of_transitions_to_test.append([initial_level_key,final_level_key])

        for one_transition_to_test in list_of_transitions_to_test:
            slope_list = []
            mean_angle_list = []
            for internal_experiment_number in range(len(self.allexperiments)-1):
                this_experiment = self.allexperiments[internal_experiment_number]
                initial_level_key,final_level_key = one_transition_to_test
                yield_list = this_experiment.get_calculated_yields(0) # Detector 0 as good as any
                this_mean_angle = this_experiment.get_parameter("theta_lab_mean")
                mean_angle_list.append(this_mean_angle)
                this_calculated_yield = find_yield_from_level_keys(initial_level_key,final_level_key,yield_list)
                next_experiment = self.allexperiments[internal_experiment_number + 1]
                next_yield_list = next_experiment.get_calculated_yields(0)
                next_calculated_yield = find_yield_from_level_keys(initial_level_key,final_level_key,next_yield_list)
                if this_calculated_yield > 0. and next_calculated_yield > 0.:
                    if next_calculated_yield > this_calculated_yield:
                        slope_list.append(1)
                    elif next_calculated_yield < this_calculated_yield:
                        slope_list.append(-1)
                    else:
                        # They're equal--very strange
                        slope_list.append(0)


            eccentricity_test_angle = 0.2*max(mean_angle_list) # Check for eccentricity problems forward of ~20% of the max scattering angle in the test runs.
            # Find the index in the slope_list where the angle crosses the eccentricity test angle
            for i in range(len(mean_angle_list)-1):
                if mean_angle_list[i] == eccentricity_test_angle  or (mean_angle_list[i] < eccentricity_test_angle  and mean_angle_list[i+1] > eccentricity_test_angle ):
                    eccentricity_test_index = i
                    break

            # If it's target detection, then we should look from the end to the beginning
            if experiment_parameter_dict["detected_particle"] == "t":
                zipped_list = zip(mean_angle_list,slope_list)
                zipped_list.reverse()
                # Now unzip the lists:
                mean_angle_tuple,slope_tuple = zip(*zipped_list)
                mean_angle_list = list(mean_angle_tuple)
                slope_list = list(slope_tuple)

            # Count the forward oscillations.
            number_of_oscillations_forward = 0
            angle_of_first_forward_oscillation = 0
            test_list = range(eccentricity_test_index)
            for i in test_list:
                if not slope_list[i] == slope_list[i+1]:
                    angle_of_first_forward_oscillation = mean_angle_list[i+2]  # will be backward-most oscillation forward of 20 degrees or 0 at end of loop
                    number_of_oscillations_forward = number_of_oscillations_forward + 1

            # Count the backward oscillations.
            number_of_oscillations_backward = 0
            for i in range(eccentricity_test_index,len(slope_list)-2):
                if not slope_list[i] == slope_list[i+1]:
                    number_of_oscillations_backward += 1

            
            if number_of_oscillations_backward > 4:
                #Append this experiment and detector to the list of possible adiabaticity problems.
                adiabaticity_problem_transitions.append(one_transition_to_test)

            if number_of_oscillations_forward > 1:
                #Append this transition to the list of possible eccentricity problems.
                eccentricity_problem_transitions.append([one_transition_to_test,angle_of_first_forward_oscillation])
            

        # Now print a list of transitions to check more carefully.
        print ""
        print "Transitions whose initial states may have adiabaticity-limit problems:"
        print "--------------------------------------------------------------------------------"
        if len(adiabaticity_problem_transitions) == 0:
            print "None detected."
        else:
            for one_transition in adiabaticity_problem_transitions:
                initial_level_key,final_level_key = one_transition
                initial_band_name, initial_spin = initial_level_key
                final_band_name, final_spin = final_level_key
                initial_band_number = investigated_nucleus.get_band_number_for_display(initial_band_name)
                final_band_number = investigated_nucleus.get_band_number_for_display(final_band_name)
                print initial_band_name,initial_spin,"-->",final_band_name,final_spin,"Oscillations at backward-scattering angles."
                plots_to_make.append([initial_band_number,final_band_number,initial_spin,final_spin,"\nAdiabaticity problem--note oscillations at backward scattering angles.\nThis version of Gosia may not be the appropriate tool for this experiment.\nConsider the magnitude of these oscillations, and consult the Gosia manual."])
        print "--------------------------------------------------------------------------------"
        if (len(eccentricity_problem_transitions) + len(adiabaticity_problem_transitions)) > 0:
            print " ADIABATICITY PROBLEMS MAY LEAD TO EXTREMELY INACCURATE YIELD CALCULATIONS"
            print " AND VERY POOR FITS!"
        print ""

        print "Transitions whose initial states may have eccentricity-limit problems at forward angles:"
        print "--------------------------------------------------------------------------------"
        if len(eccentricity_problem_transitions) == 0:
            print "None detected."
        else:
            for i in range(len(eccentricity_problem_transitions)):
                one_transition = eccentricity_problem_transitions[i][0]
                initial_level_key,final_level_key = one_transition
                initial_band_name, initial_spin = initial_level_key
                final_band_name, final_spin = final_level_key
                initial_band_number = investigated_nucleus.get_band_number_for_display(initial_band_name)
                final_band_number = investigated_nucleus.get_band_number_for_display(final_band_name)
                eccentricity_limit_angle = eccentricity_problem_transitions[i][1]
                initial_state = str(initial_level_key).strip("()")
                final_state = str(final_level_key).strip("()")
                if experiment_parameter_dict["detected_particle"] == "t":
                    direction_symbol = "<="
                    beam_or_target = "target"
                    backward_forward = "forward"
                else:
                    direction_symbol = ">="
                    beam_or_target = "beam"
                    backward_forward = "backward"
                print initial_state,"-->",final_state,"May have exceeded the eccentricity limit at ",direction_symbol,eccentricity_limit_angle,"degrees (",beam_or_target,")"
                error_string = "\nEccentricity limit MAY have been reached at "+direction_symbol+ str(eccentricity_limit_angle) + " degrees("+beam_or_target+").\nYou may want to limit your integration to a range "+backward_forward+" of this angle.\n(Adiabaticity problems can mimic eccentricity problems.)"
                plots_to_make.append([initial_band_number,final_band_number,initial_spin,final_spin,error_string])
        print "--------------------------------------------------------------------------------"


        # Concatenate the plots to make, so the same one doesn't have to be
        # viewed twice if it has an adiabaticity problem and an eccentricity
        # problem.
        set_of_states = set()
        for plot_to_make in plots_to_make:
            plots_states = tuple(plot_to_make[:4])
            set_of_states.add(plots_states)
        unique_plot_states = list(set_of_states)

        unique_plots = []  # make a list to return, so that if one transition has two errors (adiab & eccent), it won't be plotted twice.
        for plot_states in unique_plot_states:
            unique_plots.append(list(plot_states))
            for plot_to_make in plots_to_make:
                if list(plot_states) == plot_to_make[:4]:
                    unique_plots[-1].append(plot_to_make[4])  # Append the error string


        return unique_plots


    def print_all_subdivisions(self):
        """Prints a catalog of E,theta subdivisions for all experiments.

        """

        print "                 beam    scattering"
        print "                 energy  theta"
        print "-----------------------------------------------"
        for internal_experiment_number in range(len(self.allexperiments)):
            gosia_experiment_number = internal_experiment_number + 1
            print "Experiment ",gosia_experiment_number,":   ",self.allexperiments[internal_experiment_number].get_energy_subdivisions(),"    ",self.allexperiments[internal_experiment_number].get_theta_subdivisions()

    def getnumberofexperiments(self):
        """Returns the number of experiments

        This is the actual count, whether they are complete or not
        """
        return len(self.allexperiments)

    def examine_stopping_power_interactive(self):
        """Allows the user to examine and change stopping power data.

        """

        while True:
            self.print_experiment_catalog()
            gosia_experiment_number = prompt_number("Gosia experiment number or \"q\" to quit: ","i")
            if gosia_experiment_number == "quit":
                return 0
            # Convert to the internal (base 0) numbering.
            internal_experiment_number = gosia_experiment_number - 1

            yes_or_no = yes_no_prompt("Plot and print stopping power data [Y/n]? ",True)

            if yes_or_no:
                print "Enter \"q\" at the gnuplot prompt to quit."
                self.allexperiments[internal_experiment_number].plot_stopping_power_data()

            block_print_with_line_breaks("\nThe current version of Rachel uses a command-line version of elast.c (Oak Ridge), based on older Ziegler calculations to estimate stopping power data.  These numbers may deviate by as much as 10--15% from new SRIM calculations.  For accurate calculations, SRIM is recommended.  If you do not have SRIM locally, you can call the Rochester SRIM server to get new stopping power data.  Choose [e]last, [m]anual entry of your own calculated stopping powers, or [r]ochester SRIM server call.",60)

            choice = raw_input("[s]mooth [e]last, [m]anual entry, [r]ochester SRIM server, or RETURN to quit: ").lower()
            try:
                if choice[0] == "e":
                    self.allexperiments[internal_experiment_number].calculate_elast_stopping_powers()
                    print "Stopping powers for this experiment have been reset to Elast values."
                elif choice[0] == "s":
                    energies, stopping_powers = self.allexperiments[internal_experiment_number].stopping_power_data
                    smoothed_stopping = gaussian_smooth(stopping_powers,strippedXs=False,degree=3)
                    self.allexperiments[internal_experiment_number].stopping_power_data = energies, smoothed_stopping
                elif choice[0] == "m":
                    self.allexperiments[internal_experiment_number].get_user_stopping_powers()
                elif choice[0] == "r":
                    self.allexperiments[internal_experiment_number].get_stopping_power_data_from_rochester_server()
                else:
                    print "Quitting."
                    return 0
                replot = yes_no_prompt("Replot [Y/n]? ",True)
                if replot:
                    self.allexperiments[internal_experiment_number].plot_stopping_power_data()
            except:
                # The user hit return without typing anything.
                print "Quitting."
                return 0

                


    def examine_data_interactive(self):
        """Allows the user to examine the yield data in brief form."

        """

        # The plot information is stored as a dict so that data can be appended
        # to each marker easily without a search in a list.

        decay_data_plot_dict = {}  # a dictionary for plotting using nucleus method draw_decays.
        level_data_plot_dict = {}  # a dictionary for plotting using nucleus method draw_level_data

        def append_one_label(dictionary,key,new_label):
            if key in dictionary.keys():
                current_plot_label = dictionary[key][1]
                new_plot_label = current_plot_label + "\n" + new_label[1]  # Only append the new string to the current string; don't change color.
                dictionary[key][1] = new_plot_label
                return 0
            else:
                dictionary[key] = new_label
                return 0

        # Test to see if yields can be evaluated accurately.
        try:
            self.branching_data
            self.lifetime_data
            self.mixing_data
            self.measured_matrix_data
        except:
            print "Can't select yield and nuclear data until Gosia is called "
            print "  for a fit calculation.  Select \"View Gosia input\" and"
            print "  \"Fit\", click \"Go,\" then try again."
            return 0


        data_type = raw_input("[Y]ields or [n]uclear data? ").lower()

        if data_type == "n":
            # Similar to yield data, as below. 

            # Clear the level scheme window.
            investigated_nucleus.draw_level_scheme()

            block_print_with_line_breaks("Enter 'q' to quit.  Note: only the nuclear data which can be included in a fit using the current set of matrix elements are shown.  Yield and nuclear data will be updated in the next fit or error calculation.",60)
                        
            for index in range(len(self.branching_data)):
                # Rewritten Aug. 22 2011.
                one_datum = self.branching_data[index]
                initial_band_name,initial_spin,final_band_name_1,final_spin_1,final_band_name_2,final_spin_2,r,delta_r = one_datum
                # Print the branching data to the terminal.
                print "I(",initial_band_name,",",initial_spin,"-->",final_band_name_1,",",final_spin_1,") / I(",initial_band_name,",",initial_spin,"-->",final_band_name_2,",",final_spin_2,") = ",r," +/- ",delta_r

                color = 'k'

                label_text = "r_1 = " + str(r) + " +/- " + str(delta_r)
                # Add to the plotting dictionary for plotting.
                append_one_label(decay_data_plot_dict, (initial_band_name,final_band_name_1,initial_spin,final_spin_1) , [color,label_text])


                # Add the r2 branch of this branching ratio.
                label_text = "r_2 = 1"
                color = 'k'  
                # Add to the plotting dictionary for plotting.
                append_one_label(decay_data_plot_dict,  (initial_band_name,final_band_name_2,initial_spin,final_spin_2) , [color,label_text])

            for index in range(len(self.mixing_data)):
                # Rewritten Aug. 22 2011.
                one_datum = self.mixing_data[index]
                initial_band_name, final_band_name, initial_spin, final_spin, mixing_ratio, error = one_datum
                print "delta(",initial_band_name,",",initial_spin,"-->",final_band_name,",",final_spin,") = ",mixing_ratio," +/- ",error
                label_text = "d = " + str(mixing_ratio) + " +/- " + str(error)
                color = 'b'  
                # Add to the plotting dictionary for plotting.
                append_one_label(decay_data_plot_dict,  (initial_band_name,final_band_name,initial_spin,final_spin), [color,label_text])

            for index in range(len(self.measured_matrix_data)):
                # Rewritten Aug. 22 2011.
                one_datum = self.measured_matrix_data[index]
                initial_band_name, final_band_name, initial_spin, final_spin, multipole_code, reduced_matrix_element, error = one_datum
                units = UNITS_DICT[REVERSE_MULTIPOLE[multipole_code]]
                print "< ",final_band_name,",",final_spin," ||" + REVERSE_MULTIPOLE[multipole_code] + "|| ",initial_band_name,",",initial_spin," > = ",reduced_matrix_element," +/- ",error
                label_text = " < f||" + REVERSE_MULTIPOLE[multipole_code] + "||i> = (" + str(reduced_matrix_element) + " +/- " + str(error) + ") " + units
                color = 'r'  
                # Add to the plotting dictionary for plotting.
                append_one_label(decay_data_plot_dict,  (initial_band_name,final_band_name,initial_spin,final_spin), [color,label_text])

            for index in range(len(self.lifetime_data)):
                # Rewritten Aug. 22 2011.
                one_datum = self.lifetime_data[index]
                initial_band_name, initial_spin, tau, delta_tau = one_datum
                print "tau( " + initial_band_name + str(initial_spin) + ") = " + str(tau) + " +/- " + str(delta_tau) + " ps"
                label_text = "tau = (" + str(tau) + " +/- " + str(delta_tau) + ") ps"
                color = 'g'  
                # Add to the plotting dictionary for plotting.
                append_one_label(level_data_plot_dict,  (initial_band_name,initial_spin), [color,label_text])

            # Plot the spectroscopic data if there are any in each set.
            if len(decay_data_plot_dict) > 0:
                investigated_nucleus.draw_decays(decay_data_plot_dict)
                # Force an update of the drawing.
                investigated_nucleus.set_axes_nicely(investigated_nucleus.number_of_bands(),investigated_nucleus.maximum_level_energy())
            else:
                print "No branching, m.e. or mixing ratio data to draw."
            if len(level_data_plot_dict) > 0:
                investigated_nucleus.draw_level_data(level_data_plot_dict)
            else:
                print "No lifetime data to draw."

        if data_type == "y":

            while True:
                decay_data_plot_dict = {}

                self.print_experiment_catalog()

                block_print_with_line_breaks("Enter 'q' to quit.  Note: data which can be included in a fit using the current set of matrix elements are shown in black.  Yield and nuclear data will be updated in the next fit or error calculation.",60)

                experiment_number = prompt_number("Which experiment number? ","i") 
                if experiment_number == "quit":
                    break # out of yield while loop
                self.allexperiments[experiment_number - 1].print_detector_catalog()
                detector_number = prompt_number("Which detector number? ","i") 
                if detector_number == "quit":
                    break # out of yield while loop

                internal_experiment_number = experiment_number - 1
                internal_detector_number   = detector_number   - 1

                # Clear the level scheme window.
                investigated_nucleus.draw_level_scheme()
                        
                one_data_set_yields = self.allexperiments[internal_experiment_number].get_experimental_yields_with_requested_normalization(internal_detector_number)
                number_of_yields = len(one_data_set_yields)  # for this data set in this experiment
                for yield_number in range(number_of_yields):
                    
                    initial_band_name, initial_spin, final_band_name, final_spin, intensity, intensity_error = one_data_set_yields[yield_number]
                    
                    # Is the initial state populated, and is there at least
                    # one matrix element coupling the initial and final states
                    # for this data point?  If so, then draw in black.
                    # Otherwise, draw in red.
                    
                    initial_level_key = (initial_band_name, initial_spin)
                    final_level_key   = (final_band_name, final_spin)
                    if not investigated_nucleus.get_level_information(initial_level_key,"calculated lifetime") == None and \
                      self.is_populated(initial_level_key) and investigated_nucleus.are_coupled(initial_level_key,final_level_key):
                        color = 'k'
                    else:
                        color = 'r'

                    # Get the band and spin for the initial and final states.
                    fractional_error = float(intensity_error)/float(intensity)
                    intensity = float(intensity)  # Make sure these are converted to floats if they were integer counts.
                    intensity_error = float(intensity)  # Make sure these are converted to floats if they were integer counts.
                    intensity_text = str(intensity)
                    intensity_error_text = str(intensity_error)
                    #label_text = intensity_text  + " +/- " + intensity_error_text   # too cluttered in plot for yield data.
                    label_text = ""
                    # Add to the plotting dictionary for plotting.
                    append_one_label(decay_data_plot_dict, (initial_band_name,final_band_name,initial_spin,final_spin), [color,label_text])

                # Call the nucleus method to display these yields.
                if len(decay_data_plot_dict) > 0:
                    investigated_nucleus.draw_decays(decay_data_plot_dict)
                else:
                    print "No data to draw."


        return 0


    def user_set_experiment_normalizations(self):
        """Allows the user to inspect and change normalizations of experiments.

        """
        while True:
            self.print_experiment_catalog()
            try:
                gosia_experiment_number = int(raw_input("Experiment number to change normalization or return to quit: "))
                experiment_number = gosia_experiment_number - 1
            except:
                print "Quitting."
                return -1

            # Make sure the experiment that the user wants to renormalize is in memory.
            try:
                self.allexperiments[experiment_number]
            except:
                print "That experiment number is invalid.\nCancelled."
                return -1

            self.internal_set_experimental_normalization(experiment_number)
            return 0

    def internal_set_experimental_normalization(self,internal_experiment_number):
        """Internal use only.

        experiment_number uses internal numbering!

        """
        gosia_experiment_number = internal_experiment_number + 1
        good_normalization = False
        while not good_normalization:
            string_new_gosia_normalizing_experiment = raw_input("Number of experiment to normalize to or \"self\": ")
            if string_new_gosia_normalizing_experiment.lower().strip() == "self":
                new_gosia_normalizing_experiment = gosia_experiment_number
                good_normalization =  True
            else:
                new_gosia_normalizing_experiment = int(string_new_gosia_normalizing_experiment)
                # Check the normalizing experiment exists and that the user is
                # not trying to chain normalizations, e.g. 3-->2-->1.
                try: 
                    self.allexperiments[new_gosia_normalizing_experiment - 1]
                    # If this did not raise an exception, then the normalizing experiment exists.
                    good_normalization = True
                    # Check that the normalization is not chained.
                    if not self.allexperiments[new_gosia_normalizing_experiment - 1].get_parameter("LN") == \
                      new_gosia_normalizing_experiment:
                        # This would result in a chain condition.
                        good_normalization = False
                        print "You cannot chain experiment normalizations"
                        print " e.g. 3 normalized to 2 and 2 normalized to 1."
                        print " Instead, try normalizing this experiment to "
                        print " experiment #",self.allexperiments[new_gosia_normalizing_experiment - 1].get_parameter("LN") 
                except:
                    # The normalizing experiment does not exist.
                    good_normalization = False
                    print "The experiment you have chosen to normalize to does not exist!"

            
        # Set the normalization.
        self.allexperiments[internal_experiment_number].parameter_dict["LN"] = new_gosia_normalizing_experiment


    def print_experiment_catalog(self):
        """Prints a catalog of experiments in memory.

        The gosia experiment numbers 1--n are given, not internal numbers.

        """
        # Number of spaces per experiment column
        column_spaces = 12
        # Create empty strings to be appended with each experiment's values:
        header_line            = "Experiment catalog" + "\n" # + \
                                 #"----------------------------------------------------"
        experiment_number_line = "#                        "
        name_line              = "Name                     "
        theta_min_line         = "theta_min                "
        theta_max_line         = "theta_max                "
        phi_min_line           = "phi_min                  "
        phi_max_line           = "phi_max                  "
        which_excited_line     = "Excited                  "
        un_Z_line              = "un-inv. Z                "
        un_A_line              = "un-inv. A                "
        E_beam_line            = "Ebeam                    "
        E_exit_line            = "Eexit                    "
        safe_energy_line       = "Safe energy              "
        target_line            = "Tgt. thickness [mg/cm^2] "
        detected_particle_line = "Detected                 "
        inverse_line           = "Inverse kin.             "
        kinematic_solution_line= "Kinematic solution       "
        normalization_line     = "Norm to expt #           "
        sommerfeld_line        = "Somm. param.             "
        ge_detector_line       = "# of Ge detectors*       "
        comment_line           = " *clusters counted as single detectors"
                                                           
        low_sommerfeld = False  # Will be marked true if an experiment has a low Sommerfeld parameter.
        unsafe_energy  = False  # Will be marked true if an experiment has an energy above the Cline safe energy estimate.
        missing_ge_detectors = False
                                                           
        for i in range(self.getnumberofexperiments()):     
            gosia_experiment_number = i + 1
            name_line = name_line + str(self.allexperiments[i].get_name()).ljust(column_spaces)
            experiment_number_line = experiment_number_line + str(gosia_experiment_number).ljust(column_spaces)
            target_line    = target_line + str(round(self.allexperiments[i].get_parameter("target_thickness",),1)).ljust(column_spaces)
            theta_min_line = theta_min_line + str(round(self.allexperiments[i].get_parameter("theta_lab_min"),1)).ljust(column_spaces)
            theta_max_line = theta_max_line + str(round(self.allexperiments[i].get_parameter("theta_lab_max"),1)).ljust(column_spaces)
            phi_min_line   = phi_min_line + str(round(self.allexperiments[i].get_parameter("phi_1"),1)).ljust(column_spaces)
            phi_max_line   = phi_max_line + str(round(self.allexperiments[i].get_parameter("phi_2"),1)).ljust(column_spaces)
            un_Z_line      = un_Z_line      + str(self.allexperiments[i].get_parameter("Z_n")).ljust(column_spaces)
            un_A_line      = un_A_line      + str(self.allexperiments[i].get_parameter("A_n")).ljust(column_spaces)
            this_E_beam = round(self.allexperiments[i].get_parameter("E_beam"),1)
            this_E_exit = round(self.allexperiments[i].get_parameter("E_exit"),1)
            this_E_mean = self.allexperiments[i].get_parameter("E_mean")
            detected_particle      = self.allexperiments[i].get_parameter("detected_particle")
            detected_particle_line = detected_particle_line + str(detected_particle).ljust(column_spaces)
            is_inverse             = self.allexperiments[i].is_inverse_kinematics()
            inverse_line           = inverse_line + str(is_inverse).ljust(column_spaces)
            # Give which excited (beam or target).
            if self.allexperiments[i].get_parameter("excited_target"):
                excited_string = "target"
            else:
                excited_string = "beam"
            which_excited_line     = which_excited_line + excited_string.ljust(column_spaces)
            # Only output the kinematic solution for beam detection in inverse kinematics.
            if is_inverse and detected_particle == "b":
                I_kin = self.allexperiments[i].get_parameter("I_kin")
                if I_kin == 0:
                    kinematic_solution_string = "b com"
                else:
                    kinematic_solution_string = "f com"
            else:
                kinematic_solution_string = "--"
            kinematic_solution_line = kinematic_solution_line + kinematic_solution_string.ljust(column_spaces)
            normalization_line = normalization_line + str(self.allexperiments[i].get_parameter("LN")).ljust(column_spaces)
            # Get the sommerfeld parameter for this experiment.
            Z_proj = self.allexperiments[i].Z_projectile()
            A_proj = self.allexperiments[i].A_projectile()
            Z_targ = self.allexperiments[i].Z_target()
            A_targ = self.allexperiments[i].A_target()
            this_safe_energy = int(safe_energy(Z_proj,A_proj,Z_targ,A_targ))
            if this_E_beam - this_safe_energy > 1.0:
                unsafe_energy = True
                E_beam_line    = E_beam_line    + "!" + str(this_E_beam).ljust(column_spaces-1)
            else: 
                E_beam_line    = E_beam_line    +  str(this_E_beam).ljust(column_spaces)
            E_exit_line    = E_exit_line    +  str(this_E_exit).ljust(column_spaces)
            safe_energy_line = safe_energy_line + str(this_safe_energy).ljust(column_spaces)
            if investigated_nucleus.is_ready():
                energy_of_first_excited_state = investigated_nucleus.get_level_information(1,"energy")
                sommerfeld_value = round(sommerfeld_parameter(Z_proj,A_proj,Z_targ,A_targ,this_E_mean,energy_of_first_excited_state))
                if sommerfeld_value < 20.0:
                    sommerfeld_string = "*" + str(sommerfeld_value)
                    low_sommerfeld = True
                else:
                    sommerfeld_string = str(sommerfeld_value)
                sommerfeld_line = sommerfeld_line + sommerfeld_string.ljust(column_spaces)
            # Get the number of Ge detectors on this experiment.
            ge_detector_number = self.allexperiments[i].get_number_of_detectors()
            if ge_detector_number == 0:
                ge_detector_string = "@0".ljust(column_spaces - 1)
                missing_ge_detectors = True
            else:
                ge_detector_string = str(ge_detector_number).ljust(column_spaces)
            ge_detector_line = ge_detector_line + ge_detector_string

        lines_to_display = [header_line, experiment_number_line, name_line, theta_min_line, theta_max_line, phi_min_line,\
          phi_max_line, which_excited_line, un_Z_line, un_A_line, E_beam_line, E_exit_line, safe_energy_line, target_line,\
          detected_particle_line, inverse_line, kinematic_solution_line, normalization_line, sommerfeld_line, ge_detector_line,comment_line,""]

        #print header_line
        #print experiment_number_line 
        #print theta_min_line         
        #print theta_max_line         
        #print phi_min_line   
        #print phi_max_line   
        #print un_Z_line              
        #print un_A_line              
        #print E_beam_line            
        #print safe_energy_line
        #print target_line
        #print detected_particle_line
        #print inverse_line
        #print normalization_line 
        #print sommerfeld_line
        #print ge_detector_line
        #print ""
        if low_sommerfeld:
            sommerfeld_warning = block_print_with_line_breaks("*Indicates a sommerfeld parameter much less than 100.  See help topic \"sommerfeld\" before continuing with your analysis.",60,True)
            lines_to_display.extend(sommerfeld_warning)
        if unsafe_energy:
            unsafe_warning = block_print_with_line_breaks("!Experiments with a beam energy above the Cline \"safe energy\" may result in significant errors.  Refer to the help topic \"safeenergy\".",60,True)
            lines_to_display.extend(unsafe_warning)
        if missing_ge_detectors:
            ge_detector_warning = block_print_with_line_breaks("@This experiment has no Ge detectors attached.",60,True)
            lines_to_display.extend(ge_detector_warning)

        create_dialog_popup({"text_lines":lines_to_display,"title":"Experiment Catalog"})

        return 0
            
    def examine_setup_interactive(self):
        """Prompts the user repeatedly to display setup of experiments.

        """
        print "Note: \"physical\" detectors are the types of crystals\n",\
              "  or arrays that have been defined.  \"Logical\" detectors\n",\
              "  are detectors defined with a position in the laboratory.\n",\
              "  For example, a Gammasphere crystal may have been defined\n",\
              "  as detector type 1.  This is a physical detector.  If\n",\
              "  this detector is placed at theta,phi = 45 deg, 0 deg\n",\
              "  and 90 deg, 90 deg in the lab, then these are two \n",\
              "  \"logical\" detectors for which a yield calculation\n",\
              "  may be done, experimental data may be added, etc."
        the_detector_manager.display_all_physical_detectors()
        self.print_experiment_catalog()
        while True:
            gosia_experiment_number = prompt_number("Which experiment number (or 'q' to quit)? ","i")
            if gosia_experiment_number == "quit":
                investigated_nucleus.draw_level_scheme()
                return 0
            internal_experiment_number = gosia_experiment_number - 1 # Change to internal numbering
            investigated_nucleus.draw_level_scheme()
            annular = self.allexperiments[internal_experiment_number].get_parameter("annular")
            if not annular:
                phi_theta_points = self.allexperiments[internal_experiment_number].get_parameter("phi_theta_points")
                NFI_list         = self.allexperiments[internal_experiment_number].get_parameter("NFI_list")
                self.plot_sampled_detector_shape(phi_theta_points,NFI_list)
            self.allexperiments[internal_experiment_number].print_detector_catalog(internal_experiment_number)  # For now, just passing the experiment number in to reprint.
            print ""

        
    def delete_experiment(self,allexpts=False,internal_experiment_number=None):
        """Deletes a selected experiment from memory.

        """
        if not internal_experiment_number == None:
            try:
                del self.allexperiments[internal_experiment_number]
                return 0
            except:
                return -1

        elif not allexpts:
            # Ask user for the one to delete.
            string_gosia_experiment_number_to_delete = raw_input("Which experiment to DELETE (or \"all\")? ").lower().strip()
            if string_gosia_experiment_number_to_delete == "all":
                if yes_no_prompt("Are you sure [y/N]? ",False):
                    # Delete all experiments
                    self.allexperiments = []
                    print "Deleted all experiments."
                    return 0
                else:
                    print "Cancelled."
                    return -1
            else:
                try:
                    gosia_experiment_number_to_delete = int(string_gosia_experiment_number_to_delete)
                except:
                    print "Bad experiment number.  Cancelled."
                    return -1
                # Convert to internal numbering
                internal_experiment_number_to_delete = gosia_experiment_number_to_delete - 1
                if yes_no_prompt("Are you sure [y/N]? ",False):
                    # Make a list of the previous LN values to help with updating.
                    previous_LN_values = []
                    for internal_experiment_number in range(self.getnumberofexperiments()):
                        previous_LN_values.append(self.allexperiments[internal_experiment_number].get_parameter("LN"))
                    try:
                        del self.allexperiments[internal_experiment_number_to_delete]
                    except:
                        print "Invalid experiment number."
                        return -1
                    # Cycle through the experiments and update their LN values if
                    # necessary.  This mess could be avoided if, instead of storing
                    # LN, we stored a pointer to an experiment object.  This should
                    # be done in a later version.
                    for former_internal_experiment_number in range(internal_experiment_number_to_delete,len(previous_LN_values)):
                        if not former_internal_experiment_number == internal_experiment_number_to_delete:
                            former_gosia_experiment_number = former_internal_experiment_number + 1
                            if previous_LN_values[former_internal_experiment_number] == former_gosia_experiment_number or\
                               previous_LN_values[former_internal_experiment_number] > gosia_experiment_number_to_delete:
                                # This one was normalized to a higher experiment number than the
                                # one deleted.  Decrement its LN value.
                                self.allexperiments[former_internal_experiment_number - 1].parameter_dict["LN"] = previous_LN_values[former_internal_experiment_number] - 1
                    for internal_experiment_number in range(internal_experiment_number_to_delete):
                        # If the LN value refers to the deleted one, then make it self-normalized.
                        this_gosia_experiment_number = internal_experiment_number + 1
                        this_LN = self.allexperiments[internal_experiment_number].get_parameter("LN")
                        if this_LN  == gosia_experiment_number_to_delete:
                            self.allexperiments[internal_experiment_number].parameter_dict["LN"] = this_gosia_experiment_number
                            print "Experiment number ",this_gosia_experiment_number,"was dependent on the deleted experiment."
                            print "It has been self-normalized."
                    # Show the final normalizations, and ask the user if normalizations should be updated further manually?
                    self.print_experiment_catalog()
                    if yes_no_prompt("Do you want to change experiment normalizations [y/N]: "):
                        self.user_set_experiment_normalizations()
                    print "If you have experimental (or simulated) data, \n then you will need to rewrite the gosia yield file now."
                    print "(Button \"Write Gosia yld file\")"
                    return 0
                else:
                    print "Cancelled."
                    return -1

        else:
            # Delete all experiments
            self.allexperiments = []
            if not allexpts:
                print "Deleted all experiments."
            return 0

    def newexperiment(self,tf=False,parameter_dict=None,Force=False):
        """Creates a new experiment.

        """

        # Check that there are fewer than 50 experiments defined.
        if self.getnumberofexperiments() > (MAXIMUM_EXPERIMENTS - 1):
            error_text = "Only " + str(MAXIMUM_EXPERIMENTS) + " experiments can be defined using Gosia.\nYou will need to delete one or more experiments before adding new ones."
            blocked_error_text = block_print_with_line_breaks(error_text,50,True)
            dialog_popup({"text_lines":blocked_error_text,"title":"Experimental setup issues that need attention"})

            return -1

        if not tf:
            # Create a dict of parameters for the new experiment.

            # Start by requiring a unique name for this experiment for future
            # fully-automatic loading of data by prescribed file names.
            print "The name for this experiment will be used to fully automate loading of"
            print "experimental data from files \"expt_[name]_detector_1.txt\" or .ags."
            print "(This feature is not available yet.)"
            unique = False
            while not unique:
                user_name = raw_input("Enter a short name for this experiment (~8 characters, alphanumeric only): ")
                if user_name.isalnum():
                    # is alphanumeric with no whitespace
                    # Check for uniqueness.
                    unique = self.experiment_name_is_unique(user_name)
                    if not unique:
                        print "This name is already in use.  Enter a unique name."
                else:
                    # prompt again
                    print "The name must be alphanumeric with no whitespace."


            parameter_dict = {}
            # Add the user's name to the parameter dict.
            parameter_dict["user_name"] = user_name

            parameter_dict["Z_1"] = investigated_nucleus.get_value("Z")
            parameter_dict["A_1"] = investigated_nucleus.get_value("A")
            # The experiment can only be added if the investigated nucleus is
            # known, because it is needed to calculate stopping powers.
            if parameter_dict["Z_1"] == None or parameter_dict["A_1"] == None:
                print "The experiment can only be added if the investigated nucleus is"
                print "  defined, because its Z,A are needed to calculate the "
                print "  necessary kinematics and stopping powers."
                print "  Read in a level scheme before adding experiments, or load a"
                print "  saved session."
                print "Finished."
                return -1
            try:  
                # Ask for experimental parameters
                beam_or_target_excitation = raw_input("Is beam or target excited [b/t]?").lower()  # convert to lower case
                if beam_or_target_excitation[0] == "t":
                    parameter_dict["excited_target"] = True
                elif beam_or_target_excitation[0] == "b":
                    parameter_dict["excited_target"] = False
                else:
                    return "Error - invalid selection of beam or target excitation."
                parameter_dict["Z_n"] = int(raw_input("Z of UNinvestigated nucleus: "))
                parameter_dict["A_n"] = int(raw_input("A of UNinvestigated nucleus: "))

                # Determine which is the target and which is the beam.
                if parameter_dict["excited_target"]:
                    A_target     = parameter_dict["A_1"]
                    Z_target     = parameter_dict["Z_1"]
                    A_projectile = parameter_dict["A_n"]
                    Z_projectile = parameter_dict["Z_n"]
                else:
                    A_projectile = parameter_dict["A_1"]
                    Z_projectile = parameter_dict["Z_1"]
                    A_target     = parameter_dict["A_n"]
                    Z_target     = parameter_dict["Z_n"]
                # Determine whether this is a normal or inverse kinematics
                # experiment.  If the projectile mass is >= the target mass, then
                # it is inverse kinematics.
                if A_projectile < A_target:
                    # This is normal kinematics
                    normal_kinematics = True
                else:
                    # Inverse kinematics
                    normal_kinematics  = False

                # Give the user the safe beam energy, in case this is a simulation.
                the_safe_energy = safe_energy(Z_projectile,A_projectile,Z_target,A_target)
                print "The safe energy for this experiment is " + str(round(the_safe_energy)) + " MeV."
                parameter_dict["E_beam"] = float(raw_input("Initial beam energy in MeV: "))

                # Get the target thickness.
                parameter_dict["target_thickness"] = float(raw_input("Target thickness in mg/cm^2: "))
                detected_particle_understood = False
                block_print_with_line_breaks("\nEnter the particle for which the scattering angle will be defined.")
                if not normal_kinematics:
                    block_print_with_line_breaks("For inverse kinematics, if the detected range spans the maximum scattering angle, you must select the target particle as the detected particle, and enter the corresponding range in target recoil angle!  If you specify beam detection, you will be prompted to choose the kinematic solution for the calculations.")
                while not detected_particle_understood:
                    parameter_dict["detected_particle"] = raw_input("Which particle? Enter \"[b]eam\" or \"[t]arget\": ").lower()[0]
                    if parameter_dict["detected_particle"] in ["b","t"]:
                        detected_particle_understood = True

                if parameter_dict["detected_particle"] == "b" and not normal_kinematics:
                    use_forward_solution = yes_no_prompt("Do you want to detect the forward kinematic solution (\"y\" for forward, \"n\" for backward)?  ")
                    if use_forward_solution:
                        print "Calculating for the forward-c.o.m. scattering solution."
                        parameter_dict["I_kin"] = 1
                    else:
                        print "Calculating for the backward-c.o.m. scattering solution."
                        parameter_dict["I_kin"] = 0
                else:
                    # If this is normal kinematics or target detection, then
                    # I_kin is ignored in OP,INTI, so set it arbitrarily to 0.
                    parameter_dict["I_kin"] = 0

                    # This value of I_kin must be set to correspond to the fwd
                    # or bkwd c.o.m. scattering solution for the mean target
                    # recoil angle if this is inverse kinematics.  This is done after calls to
                    # def mean_scattering_angle(), e.g. in generate_expt().

                block_print_with_line_breaks("Is this experiment (data partition) for particle scattering in an azimuthally symmetric sector (or a full annulus) ?  (Answer \"n\" if this is a rectilinear particle detector or data partition--the only other option at present.) ",60)
                annular = yes_no_prompt("Sector (or annulus) [Y/n]? ",True)
                if annular:
                    parameter_dict["annular"] = True
                    if parameter_dict["detected_particle"] == "b":
                        print "Enter the polar beam scattering angle range in the lab frame."
                    else:
                        print "Enter the polar target recoil angle range in the lab frame."
                    if not normal_kinematics and parameter_dict["detected_particle"] == "t":
                        print "Both kinematic solutions will be calculated, if this is consistent with the range selected."
                    block_print_with_line_breaks("NOTE: if the detector covers a region beyond the maximum scattering angle, then you must define the detection region, not the entire detector.")
                    parameter_dict["theta_lab_min"] = float(raw_input("LAB frame MINimum polar angle: "))
                    parameter_dict["theta_lab_max"] = float(raw_input("LAB frame MAXimum polar angle: "))
                    print "Polar scattering angle meshpoint spacing will be set automatically."

                    print ""
                    block_print_with_line_breaks("You can choose to partition data for an azimuthally symmetric annulus, or a sector with boundaries of constant polar and azimuthal angle.")
                    if not yes_no_prompt("Is this particle detector (data partition) for the full 2pi azimuthal range [Y/n]? ",True):
                        phi_min = prompt_number("Minimum azimuthal angle for the detected particle [deg]: ","f")
                        phi_max = prompt_number("Maximum azimuthal angle for the detected particle [deg]: ","f")
                        if phi_max < phi_min:
                            phi_max, phi_min = phi_min, phi_max
                        parameter_dict["phi_1"] = phi_min
                        parameter_dict["phi_2"] = phi_max
                        parameter_dict["I_ax"]  = 1
                        parameter_dict["annular"] = True
                    else:
                        parameter_dict["phi_1"] = 0.
                        parameter_dict["phi_2"] = 360.
                        parameter_dict["I_ax"]  = 0
                        parameter_dict["annular"] = True

                else:
                    # Must be a rectilinear detector.
                    parameter_dict["annular"] = False


                print "For information on experimental data normalizations, "
                print "  refer to the Gosia manual entry on \"EXPT\"."
                print ""
                if self.getnumberofexperiments() == 0:
                    # This is the first experiment.  Must be self-normalized for now.
                    LN = 1
                    print "Since this is the first experiment, it must be self-normalized for now."
                    print "  You can change the normalization of this experiment if a second "
                    print "  experiment is added later.  Use the button \"Gosia controls\","
                    print "  option \"n\"."
                else:
                    self.print_experiment_catalog()
                    good_normalization = False
                    if parameter_dict["detected_particle"] == "t":
                        block_print_with_line_breaks("NOTE: The present version of Gosia requires that target-detection experiments be independently normalized.  That is, it must not be normalized to another experiment, nor can any other experiment be normalized to it.  See the topic \"targetdetection\" using the Help button.")
                        LN = self.getnumberofexperiments() + 1 # in gosia numbers
                    else:
                        while not good_normalization:
                            string_new_gosia_normalizing_experiment = raw_input("Number of experiment to normalize to or \"self\": ")
                            if string_new_gosia_normalizing_experiment.lower().strip() == "self":
                                LN = self.getnumberofexperiments() + 1  # In gosia numbers
                                good_normalization = True
                            else:
                                try:
                                    new_gosia_normalizing_experiment = int(string_new_gosia_normalizing_experiment)
                                    # Check the normalizing experiment exists and that the user is
                                    # not trying to chain normalizations, e.g. 3-->2-->1.
                                    try: 
                                        self.allexperiments[new_gosia_normalizing_experiment - 1]
                                        # If this did not raise an exception, then the normalizing experiment exists.
                                        good_normalization = True
                                        # Check that the normalization is not chained.
                                        if not self.allexperiments[new_gosia_normalizing_experiment - 1].get_parameter("LN") == \
                                          new_gosia_normalizing_experiment:
                                            # This would result in a chain condition.
                                            good_normalization = False
                                            print "You cannot chain experiment normalizations"
                                            print " e.g. 3 normalized to 2 and 2 normalized to 1."
                                            print " Instead, try normalizing this experiment to "
                                            print " experiment #",self.allexperiments[new_gosia_normalizing_experiment - 1].get_parameter("LN") 
                                        else:
                                            LN = new_gosia_normalizing_experiment
                                            good_normalization = True
                                    except:
                                        # The normalizing experiment does not exist.
                                        good_normalization = False
                                        print "The experiment you have chosen to normalize to does not exist!"
                                        print "  You can change the normalizing experiment number later using"
                                        print "  the button \"Gosia controls\", option \"n\"."
                                except:
                                    print "Invalid entry.  Must be an integer."
                                    good_normalization = False

                # Finally, a valid normalization has been entered.
                print "This new experiment is normalized to experiment " + str(LN) + "."
                parameter_dict["LN"] = LN

            except:  # if error, then cancel the operation
                print "Error--type of last entry was incorrect."
                return -1

        if tf:
            self.allexperiments.append(copy.deepcopy(experiment(parameter_dict,True)))  # deepcopy is required here.  Otherwise, the objects in the list get confused.
        else:
            if parameter_dict["annular"]:
                self.allexperiments.append(copy.deepcopy(experiment(parameter_dict)))       # deepcopy is required here.  Otherwise, the objects in the list get confused.
                internal_experiment_number = self.getnumberofexperiments() - 1
                self.reset_optimum_angular_meshpoints(False,internal_experiment_number)     # Pick the best spacing of theta meshpoints.
            elif not parameter_dict["annular"]:
                theta_lab_max,theta_lab_min,phi_2,phi_1,phi_theta_points,theta_normal,phi_normal = self.define_rectilinear_detector_interactive()
                parameter_dict["theta_normal"] = math.degrees(theta_normal)
                parameter_dict["phi_normal"] = math.degrees(phi_normal)
                parameter_dict["theta_lab_max"] = theta_lab_max  # temporary, inaccurate.  
                parameter_dict["theta_lab_min"] = theta_lab_min
                parameter_dict["phi_1"] = phi_1
                parameter_dict["phi_2"] = phi_2
                parameter_dict["phi_theta_points"] = phi_theta_points
                self.allexperiments.append(copy.deepcopy(experiment(parameter_dict)))       # deepcopy is required here.  Otherwise, the objects in the list get confused.
                internal_experiment_number = self.getnumberofexperiments() - 1
                self.reset_optimum_angular_meshpoints(False,internal_experiment_number)  # the number of meshpoints, not their values
                number_of_theta_meshpoints = self.allexperiments[internal_experiment_number].get_parameter("number_of_theta_meshpoints")
                theta_lab_min,theta_lab_max,theta_meshpoints,NFI_list = self.make_NFI_list(phi_theta_points,number_of_theta_meshpoints)
                # Set accurate min, max theta values.  These represent the detected particle.
                theta_lab_mean = (theta_lab_min + theta_lab_max) / 2.
                self.allexperiments[internal_experiment_number].set_parameter("theta_lab_min",theta_lab_min)
                self.allexperiments[internal_experiment_number].set_parameter("theta_lab_max",theta_lab_max)
                self.allexperiments[internal_experiment_number].set_parameter("theta_lab_mean",theta_lab_mean)
                self.allexperiments[internal_experiment_number].set_parameter("theta_meshpoints",theta_meshpoints)
                # Set the new, accurate theta limits.
                self.allexperiments[internal_experiment_number].set_parameter("NFI_list",NFI_list)

                # Plot the "exact" and down-sampled shape that is passed to Gosia:
                print "Plotting exact and down-sampled shape..."
                self.plot_sampled_detector_shape(phi_theta_points,NFI_list)
                print "Finished."

            self.print_experiment_catalog()
            print "Be sure to attach Ge detectors to this experiment."
            print "Experiment added."

        return 0


    def save_detector_array_to_file(self):
        """Writes the entire detector array of one experiment to a file.

        This writes the robust txt file format which can be read by
        attach_detector_array_from_file().

        The file format is

        crystal    gammasphere   45.00  90.00  txt  somedata.txt
        crystal    gammasphere   90.00  90.00  ags  foo.ags
        cluster    3                           txt  bah.ags
                   clovercrystal 25.00  43.00
                   clovercrystal 20.00  46.00
                   clovercrystal 25.00  46.00
        crystal    gammasphere   90.00 135.00
        ...

        (File types and names are optional.)

        """

        self.print_experiment_catalog()
        internal_experiment_number = prompt_number("Enter experiment number: ",'i') - 1 # Subtract one to convert to internal numbering.

        output_file_name = prompt_for_file_name(prompt_string = "Enter file name to save to (will be overwritten): ")

        crystal_count = 0
        cluster_count = 0

        # Set column widths for the different fields
        crystal_cluster_columns = 9
        theta_columns           = 9  # Round to two digits after the decimal point.
        phi_columns             = 9  # Round to two digits after the decimal point.

        # Get the longest type name, so that the file columns can be aligned for easy reading:
        all_type_names = []
        name_lengths   = []
        number_of_physical_detectors = the_detector_manager.getnumberofdetectors()
        for i in range(number_of_physical_detectors):
            all_type_names.append(the_detector_manager.get_type_name(i))
            name_lengths.append(len(all_type_names[i]))
        maximum_name_length = max(name_lengths)
        name_columns = maximum_name_length + 2

        # A list of lines to write to the file:
        detector_file_lines = []

        # Loop through all logical detectors and clusters in this experiment
        # and store the parameters in the lines to write to the file.
        number_of_Ge_detectors = self.allexperiments[internal_experiment_number].get_number_of_detectors()
        for detector_number in range(number_of_Ge_detectors):
            # Get the type number, theta and phi values.  This works for both crystals and clusters.
            theta = self.allexperiments[internal_experiment_number].get_detector_information(detector_number,"theta")
            phi   = self.allexperiments[internal_experiment_number].get_detector_information(detector_number,"phi")

            # Get the kind of detector (crystal or cluster).
            if self.allexperiments[internal_experiment_number].get_detector_information(detector_number,"is_crystal"):
                # Get the type name from type number.
                type_number = self.allexperiments[internal_experiment_number].get_detector_information(detector_number,"type")
                # Call the physical detector manager to get the type name for this crystal.
                type_name   = the_detector_manager.get_type_name(type_number)
                # Add a line to write to the txt file representing this crystal:
                this_detector_file_line = "crystal".ljust(crystal_cluster_columns) + type_name.ljust(name_columns) \
                  + str(round(theta,2)).rjust(theta_columns) + str(round(phi,2)).rjust(phi_columns)
                detector_file_lines.append(this_detector_file_line)
            else:
                # This is a cluster.  Get lists of crystal type numbers, theta and phi values.
                # Not using the usual accessors here...
                cluster_object = self.allexperiments[internal_experiment_number].Ge_detectors[detector_number]
                type_numbers          = cluster_object.return_type_numbers()
                type_names            = cluster_object.return_names()
                theta_list            = cluster_object.return_thetas()
                phi_list              = cluster_object.return_phis()
                number_of_crystals    = cluster_object.return_number_of_crystals()
                # Make the header line giving the number of crystals.
                header_line = "cluster".ljust(crystal_cluster_columns) + str(number_of_crystals)
                detector_file_lines.append(header_line)
                # Now list all crystals in this cluster:
                for i in range(number_of_crystals):
                    name  = type_names[i]
                    theta = theta_list[i]
                    phi   = phi_list[i]
                    crystal_line = "".ljust(crystal_cluster_columns) + name.ljust(name_columns) \
                      + str(round(theta,2)).rjust(theta_columns) + str(round(phi,2)).rjust(phi_columns)
                    detector_file_lines.append(crystal_line)

        # Write to the requested file, checking whether this overwrites an existing file.
        write_lines_to_file(output_file_name,detector_file_lines)

        return 0


    def attach_detector_array_from_file(self):
        """Allows the user to read a saved Ge array from disk.

        This method will produce an error if a physical detector named is not
        in memory, and the user tries to use it in the file.  (It could be
        confusing to have physical detector definitions appear when reading the
        logical detector file.

        """

        def print_format_error(line_number):
            print "Incorrect file format on line ", line_number + 1, "."  # Add one to give line number base 1.
            return 

        file_name = prompt_for_file_name(prompt_string = "Enter Rachel detector file name: ")

        with open(file_name, 'r') as detector_array_file:
            array_file_lines = detector_array_file.readlines()

        # Prompt for the set of experiment numbers to add the detectors to.
        block_print_with_line_breaks("Note that if auto-load file names are specified in the detector array file, a separate file must be used for each experiment, with unique Ge detector data files for each experiment.")

        internal_experiment_numbers_set = self.get_experiment_numbers()
        if internal_experiment_numbers_set == -1:
            print "No valid experiment_numbers chosen.  No detectors were added."
            return -1

        # See if the user chose to add the array to more than one experiment.
        # If so, then auto-load file names cannot be used.  (Otherwise, all
        # experiments would load the same data.
        if len(internal_experiment_numbers_set) == 1:
            can_set_up_auto_load = True
        else:
            can_set_up_auto_load = False

        # Parse the file lines to get the crystals and clusters to attach to
        # the experiments above.
        line_number = 0
        crystal_count = 0
        cluster_count = 0
        while line_number < len(array_file_lines):
            this_line = array_file_lines[line_number]
            line_fields = this_line.split()
            if len(line_fields) > 0:
                if line_fields[0][0] == "#":
                    # This is a comment.  Don't process this line.
                    line_number += 1
                elif line_fields[0] == "crystal":
                    crystal_parameter_dictionary = {}
                    add_auto_load_file = False  # Will be set to true if the auto-load file and type are found and understood.
                    # A crystal definition only takes one line.
                    if len(line_fields) < 4:
                        # Not enough data to define a logical detector.
                        print_format_error(line_number)
                        print "Skipping this entry."
                    else:
                        # Get the type name, theta and phi values.
                        type_name = line_fields[1]
                        theta     = float(line_fields[2])
                        phi       = float(line_fields[3])
                        # If there is a fifth item on the line, make sure it is
                        # not a comment starting with "#".  If it is not a
                        # comment, save the string as the file name to read
                        # yield data from.
                        if len(line_fields) > 5:
                            # Is this a comment?
                            fifth_field = line_fields[4]
                            if can_set_up_auto_load:
                                if not fifth_field[0] == "#":
                                    # Not a comment.  Assume that this is a file type.
                                    yield_data_file_type = fifth_field
                                    if yield_data_file_type in ["ags","txt"]:
                                        add_auto_load_file = True
                                        # If this is valid auto-load data, then the fourth field must be the file name to auto-load from.
                                        yield_data_file_name = line_fields[5]
                                        print "This crystal will auto-load from file ",yield_data_file_name
                                    else:
                                        print "This crystal is NOT set up to auto-load."

                        # Get the physical detector type number from the name.
                        internal_type_number = the_detector_manager.get_internal_type_number(type_name)
                        if internal_type_number == None:
                            # This detector name was not found.  Skip.
                            print "Detector \"",type_name,"\" was not found.  Quitting.  Click \"Undo to\" restore the former setup!"
                            return 1
                        # The physical detector type number, theta and phi are
                        # all the data needed for a crystal.  Make the
                        # parameter dictionary, and add the crystal logical
                        # detector.
                        crystal_parameter_dictionary = {"identity":"crystal","detector_type_number":internal_type_number, "theta":theta, "phi":phi}
                        # if a valid file type was specified for auto-loading data, add this and the data file name to the dictionary.
                        if add_auto_load_file:
                            # This is a valid file type.
                            crystal_parameter_dictionary["yield_data_file_name"] = yield_data_file_name
                            crystal_parameter_dictionary["yield_data_file_type"] = yield_data_file_type
                        for experiment_number in internal_experiment_numbers_set:
                            self.allexperiments[experiment_number].add_ge_detector(crystal_parameter_dictionary)
                            crystal_count += 1
                            print "Added crystal #",crystal_count, " \"", type_name, "\" theta = ",theta," phi = ",  phi

                        # Increment the line number to the next entry
                        line_number += 1

                elif line_fields[0] == "cluster":
                    cluster_parameter_dictionary = {}
                    add_auto_load_file = False  # will be set to true if the auto-load data are included (file name and "Type" ["ags" or "txt"])
                    # The cluster parameters require that more lines be
                    # processed.  The number of lines to process is the second
                    # entry on the "cluster" line.
                    if len(line_fields) < 2:
                        # Not enough data to define a logical detector.
                        print_format_error(line_number)
                        line_number += 1
                    else:
                        number_of_crystals = int(line_fields[1])
                        # If there is a third item on the line, make sure it is
                        # not a comment starting with "#".  If it is not a
                        # comment, save the string as the file type to read
                        # yield data from.
                        if len(line_fields) > 3:
                            # Is this a comment?
                            third_field = line_fields[2]
                            if can_set_up_auto_load:
                                if not third_field[0] == "#":
                                    # Not a comment.  This should be the ags/txt file type.
                                    yield_data_file_type = third_field.lower()
                                    if yield_data_file_type in ["ags","txt"]:
                                        add_auto_load_file = True
                                        # If this is valid auto-load data, then the fourth field must be the file name to auto-load from.
                                        yield_data_file_name = line_fields[3]
                                        print "This cluster will auto-load from file ",yield_data_file_name
                                    else:
                                        print "This cluster is NOT set up to auto-load."
                        cluster_count += 1
                        print "Reading ", number_of_crystals, "crystals into cluster number ", cluster_count
                        cluster_parameter_dictionary = {"identity":"cluster","detector_type_numbers":[], "thetas":[], "phis":[]}
                        for crystal_number in range(number_of_crystals):
                            # Read the next line defining one of the crystals in the cluster.
                            next_found = False
                            while not next_found:
                                line_number += 1
                                this_line = array_file_lines[line_number]
                                line_fields = this_line.split()
                                if not line_fields[0][0] == "#":
                                    if len(line_fields) < 3:
                                        print "Invalid cluster entry on line ",line_number + 1,".  Quitting.  Click \"Undo to\" restore the former setup!"
                                        return 1
                                    # Get the type name, theta and phi values for this crystal in the cluster.
                                    type_name = line_fields[0]
                                    theta     = float(line_fields[1])
                                    phi       = float(line_fields[2])
                                    # Get the physical detector type number from the name.
                                    internal_type_number = the_detector_manager.get_internal_type_number(type_name)
                                    if internal_type_number == None:
                                        # This detector name was not found.  Skip.
                                        print "Detector \"",type_name,"\" was not found.  Quitting.  Click \"Undo to\" restore the former setup!"
                                        return 1
                                    # The physical detector type number, theta and phi are
                                    # all the data needed for a crystal.  Make the
                                    # parameter dictionary, and add the crystal logical
                                    # detector.
                                    print "  Read crystal ",crystal_number + 1, "\"", type_name, "\" theta = ",theta, " phi = ", phi, "into cluster ",cluster_count
                                    # Add this crystal to the cluster parameter dict:
                                    cluster_parameter_dictionary["detector_type_numbers"].append(internal_type_number)
                                    cluster_parameter_dictionary["thetas"].append(theta)
                                    cluster_parameter_dictionary["phis"].append(phi)
                                    next_found = True
                        line_number += 1

                        if add_auto_load_file:
                            # This is a valid file type.
                            cluster_parameter_dictionary["yield_data_file_name"] = yield_data_file_name
                            cluster_parameter_dictionary["yield_data_file_type"] = yield_data_file_type

                        # Advance to the next crystal or cluster.
                        line_number += 1
                        # Now that all crystals are added from the file, add this cluster to the chosen experiments.
                        for experiment_number in internal_experiment_numbers_set:
                            self.allexperiments[experiment_number].add_ge_detector(cluster_parameter_dictionary)
                            print "Added cluster #",cluster_count, "."

                else:
                    # This line is not properly formatted, or the crystal count in a cluster was too low.
                    print "Format error on line ",line_number,"."
                    try:
                        name_string = str(line_fields[0])
                        theta_float = float(line_fields[1])
                        phi_float   = float(line_fields[2])
                        print "This appears to be an extra entry for a cluster definition on line ",line_number + 1
                        print "Quitting.  Click \"Undo to\" restore the former setup!"
                    except:
                        print "This appears to be a syntax error on line ",line_number + 1
                        print "Quitting.  Click \"Undo to\" restore the former setup!"
                    print "Line ",line_number + 1,": ",this_line
                    # Increment the line number to the next entry
                    line_number += 1
            else:  # no fields on line
                # Skip empty line.
                line_number += 1

        if cluster_count > 0:
            create_popup_tip("gdet_for_clusters")

        return 0


    def attach_detector(self):
        """Lets user attach a detector to an experiment.

        The physical detector type must already be in the detectormanager's
        memory.

        """

        self.print_experiment_catalog()
        experiment_number_answer = raw_input("Which experiment number [or \"list\" or \"all\"]? ").lower()
        if experiment_number_answer[0] == "a":
            # all experiments are to get the same added detector
            internal_experiment_numbers = range(self.getnumberofexperiments())
        elif experiment_number_answer[0] == "l":
            list_syntax_good = False
            while not list_syntax_good:
                # Ask for a list of experiment numbers.
                experiment_list_string = raw_input("Enter a space-delimited list of experiment numbers: ")
                comma_stripped_experiment_list_string = experiment_list_string.replace(","," ")
                experiment_string_list = comma_stripped_experiment_list_string.split()
                internal_experiment_numbers = []
                # Convert to internal numbering and integer type.
                try:
                    for one_item in experiment_string_list:
                        internal_experiment_numbers.append(int(one_item) - 1)  # Convert to internal numbering by subtracting 1.
                    list_syntax_good = True
                except:
                    # User did not enter the list correctly.
                    pass
        else:
            # Just one experiment number
            # Don't use the gosia number; use the internal (base 0) number as stored in the allexperiments list.
            internal_experiment_numbers = [int(experiment_number_answer)-1]
            
        # Ask first if this is a single detector or a cluster to attach.  The
        # latter will create a cluster object, which requires different data
        # and not just one type number.

        block_print_with_line_breaks("----------------------------------------------------------------------\nYou can define a single crystal or a summed cluster.\n  If the detector is defined as a isotropic 4pi array, select \"Y\" as if for a single crystal.  If the detector is to be given as a cluster of Ge crystals at specified theta, phi positions, select \"n.\"\n----------------------------------------------------------------------\n  ",70)
        single_crystal = yes_no_prompt("Single crystal [Y/n]? ",True)

        # Ask for a data file name for auto-loading.
        block_print_with_line_breaks("----------------------------------------------------------------------\nIf you want to import a number of clusters, it will be easier to define them in a Ge detector definition text file.  You can specify a file name for the yield data for this detector, in this experiment.  Every detector with a specified data file name can \"auto-load\" data in one step using \"al\" in the Tools menu.  (The data file can contain the full data set, and Rachel will de-select data automatically if the level scheme or matrix does not contain the appropriate levels or matrix elements.  Note that you cannot auto-load from a gosia-format yield file.)\n----------------------------------------------------------------------\n  ",70)
        want_to_auto_load = yes_no_prompt("Do you want to set up this detector to auto-load yield data [y/N]? ",False)


        if single_crystal:

            # This will be a single Ge crystal.
            identity = "crystal"

            # Show users what detectors there are to choose from.
            the_detector_manager.display_all_physical_detectors()

            # Prompt for the number (internal) of the detector type.
            detector_type_number = prompt_number("Which detector type [number or \"q\" to quit]? ","i")
            if detector_type_number == "quit":
                return 0
            # Internally, detector type numbers begin with 0 as stored in a list.
            # Change this user/gosia identity to the internal number
            internal_detector_type = detector_type_number - 1

            # Get theta,phi angles of this detector in the lab frame.
            theta = prompt_number("Polar angle in lab frame [degrees]? ","f")
            if theta == "quit":
                return -1  # return -1 so that the undo information is not saved.
            phi   = prompt_number("Azimuthal angle in lab frame [degrees]? ","f")
            if phi == "quit":
                return -1  # return -1 so that the undo information is not saved.

            # Attach the detector by calling the experiment object
            for experiment_number in internal_experiment_numbers:  
                ge_detector_parameters = {"identity":identity,"detector_type_number":internal_detector_type,"theta":theta,"phi":phi}
                if want_to_auto_load:
                    # If the auto-load file name was specified, ask for the type of file
                    # and set up the detector to know that it can "auto-load."
                    print "Set up the auto-load file for experiment ",experiment_number + 1, " for this detector."
                    txt_or_ags = raw_input("Is this an AGS[a] or TXT[t] file? ").lower()[0]
                    if txt_or_ags == "t":
                        yield_data_file_type = "txt"
                    elif txt_or_ags == "a":
                        yield_data_file_type = "ags"
                    yield_data_file_name = prompt_for_file_name(prompt_string = "Enter data file name for this detector in this experiment: ")
                    ge_detector_parameters["yield_data_file_name"] = yield_data_file_name
                    ge_detector_parameters["yield_data_file_type"] = yield_data_file_type
                self.allexperiments[experiment_number].add_ge_detector(ge_detector_parameters)

            print "Detector(s) added."

        else:
            # This will be a cluster.
            identity = "cluster"

            # Show users what detectors there are to choose from.
            the_detector_manager.display_all_physical_detectors()

            # Prompt for the ge detectors in the cluster.  
            number_of_detectors = prompt_number("Enter the number of detectors in the cluster: ","i")
            if number_of_detectors == "q":
                print "Attach detector cancelled."
                return -1

            # The following flag will be set to True when all cluster data are entered correctly.
            definition_finished = False

            # Ask for information until the lists are complete:

            # THIS IS NOT DEBUGGED PROPERLY.  IT WILL NOT CATCH STRINGS USING
            # input.  USE raw_input INSTEAD AND REWRITE HERE

            print "Define the detector cluster from these existing physical detector types."
            print "Separate all entries with commas."
            while not definition_finished:
                # Ask for the type numbers
                print "Enter a list of type numbers (integers), e.g. 1,2,1,2,2,3..."
                types_finished = False
                while not types_finished:
                    try:
                        detector_type_numbers = input("Type numbers [\"q\" to quit]: ")
                        if detector_type_numbers == "q" or detector_type_numbers == "Q":
                            print "Attach detector cancelled."
                            return -1
                        if len(detector_type_numbers) == number_of_detectors:
                            external_detector_type_numbers = list(detector_type_numbers)
                            types_finished = True
                        elif len(detector_type_numbers) > number_of_detectors:
                            # Too many were entered.  Restart:
                            print "Too many type numbers.  Please start again."
                            types_finished = False
                        elif len(detector_type_numbers) < number_of_detectors:
                            print "Need ", number_of_detectors, " total detector types.  Please start again."
                            types_finished = False
                    except:
                        print "Enter a COMMA-DELIMITED list of numbers."

                # Change detector type numbers to internal (base 0) numbering.
                detector_type_numbers = []  # re-using this list.
                for one_external_type_number in external_detector_type_numbers:
                    detector_type_numbers.append(one_external_type_number - 1)

                print "Enter a list of polar angles (degrees) for the same \n ordering of detectors as above, e.g. 17., 25., 17., 34.,..."
                polar_finished = False
                while not polar_finished:
                    try:
                        detector_polar_angles = input("Polar angles [\"q\" to quit]: ")
                        if detector_polar_angles == "q" or detector_polar_angles == "Q":
                            print "Attach detector cancelled."
                            return -1
                        if len(detector_polar_angles) == number_of_detectors:
                            detector_polar_angles = list(detector_polar_angles)
                            polar_finished = True
                        elif len(detector_polar_angles) > number_of_detectors:
                            # Too many were entered.  Restart:
                            print "Too many polar angles.  Please start again."
                            polar_finished = False
                        elif len(detector_polar_angles) < number_of_detectors:
                            print "Need ", number_of_detectors, " total polar angles types.  Please start again."
                            polar_finished = False
                    except:
                        print "Enter a COMMA-DELIMITED list of numbers."

                print "Enter a list of azimuthal angles (degrees) for the same \n ordering of detectors as above, e.g. 54., 63., 45.,..."
                azimuthal_finished = False
                while not azimuthal_finished:
                    try:
                        detector_azimuthal_angles = input("Azimuthal angles [\"q\" to quit]: ")
                        if detector_azimuthal_angles == "q" or detector_azimuthal_angles == "Q":
                            print "Attach detector cancelled."
                            return -1
                        if len(detector_azimuthal_angles) == number_of_detectors:
                            detector_azimuthal_angles = list(detector_azimuthal_angles)
                            azimuthal_finished = True
                        elif len(detector_azimuthal_angles) > number_of_detectors:
                            # Too many were entered.  Restart:
                            print "Too many type numbers.  Please start again."
                            azimuthal_finished = False
                        elif len(detector_azimuthal_angles) < number_of_detectors:
                            print "Need ", number_of_detectors, " total azimuthal angles.  Please start again."
                            azimuthal_finished = False
                    except:
                        print "Enter a COMMA-DELIMITED list of numbers."

                # If the previous loops were finished, then the definition was completed.
                definition_finished = True

            # Now attach this cluster by passing the parameter dict to the
            # cluster object init method.
            ge_cluster_parameters = {"identity":identity,"detector_type_numbers":detector_type_numbers,"thetas":detector_polar_angles,"phis":detector_azimuthal_angles}

            for experiment_number in internal_experiment_numbers:  
                if want_to_auto_load:
                    # If the auto-load file name was specified, ask for the type of file
                    # and set up the detector to know that it can "auto-load."
                    print "Set up the auto-load file for experiment ",experiment_number + 1, " for this cluster."
                    txt_or_ags = raw_input("Is this an AGS[a] or TXT[t] file? ").lower()[0]
                    if txt_or_ags == "t":
                        yield_data_file_type = "txt"
                    elif txt_or_ags == "a":
                        yield_data_file_type = "ags"
                    yield_data_file_name = prompt_for_file_name(prompt_string = "Enter data file name for this cluster in this experiment: ")
                    ge_cluster_parameters["yield_data_file_name"] = yield_data_file_name
                    ge_cluster_parameters["yield_data_file_type"] = yield_data_file_type
                self.allexperiments[experiment_number].add_ge_detector(ge_cluster_parameters)

            print "Detector(s) added."

        create_popup_tip("gdet_for_clusters")

        return 0

    def detach_detector(self):
        """Lets user detach a detector in memory from an experiment.

        """

        self.print_experiment_catalog()
        print "Be careful!  This deletes the same *numbered* \n",\
              "detector from all experiments, if \"all\" is selected!\n",\
              "This may or may not be the same detector in the laboratory.\n",\
              "Also, this operation is not fully tested.  Write a new \n",\
              "Gosia yld file and re-run all gosia calculations, to be sure."
        experiment_number_answer = raw_input("Which experiment number [or \"all\"]? ").lower()
        if experiment_number_answer[0] == "a":
            # all experiments are to get the same added detector
            internal_experiment_numbers = range(self.getnumberofexperiments())
        else:
            # Just one experiment number
            # Don't use the gosia number; use the internal (base 0) number as stored in the allexperiments list.
            internal_experiment_numbers = [int(experiment_number_answer)-1]  # Be consistent in type by making this a list.
            
        # Show users what detectors there are to choose from.
        print "Experiment number ",internal_experiment_numbers[0] + 1,"has the following detectors:"
        self.allexperiments[internal_experiment_numbers[0]].print_detector_catalog()

        # Prompt for the number (internal) of the detector.
        detector_number_to_detach = prompt_number("Which detector number to DETACH, or \"q\" to quit? ","i")
        if detector_number_to_detach == "quit":
            return 0
        # Internally, detector numbers begin with 0 as stored in a list.
        # Change this user/gosia identity to the internal number
        internal_detector_number_to_detach = detector_number_to_detach - 1

        # Detach the detector by calling the experiment object
        for experiment_number in internal_experiment_numbers:  
            self.allexperiments[experiment_number].delete_detector(internal_detector_number_to_detach )

        print "Done."

        return 0
            
    def get_all_mean_particle_angles(self):
        """Returns the mean scattering angle for each experiment.

        Returns a list of floats.
        """
        angles = []
        for one_experiment in self.allexperiments:
            mean_particle_angle = one_experiment.get_parameter("theta_lab_mean")
            angles.append(mean_particle_angle)

        return angles

    def get_overall_normalization_for_experimental_yields(self,internal_experiment_number):
        """Gets the correct overall normalization to scale experimental yields.

        This checks to see which experiments are normalized together, collects
        all of their experimental and calculated yields, and calculates the
        normalization for experimental yields by requiring that the total
        intensity of experimental yields matches the total intensity of
        calculated yields.  (This includes only the transitions for which there
        is both a calculated yield and and experimental yield.

        """

        # Collect all experiment numbers (internal) that share a common
        # normalization with this one.
        internal_experiment_numbers_with_common_normalization = []

        # Is this experiment normalized to another?
        this_experiment_ln = self.allexperiments[internal_experiment_number].get_parameter("LN") - 1 # convert to internal numbering.
        if this_experiment_ln == internal_experiment_number:
            self_normalized = True
        else:
            self_normalized = False

        for one_internal_experiment_number in range(self.getnumberofexperiments()):
            if self.allexperiments[one_internal_experiment_number].get_parameter("LN") - 1 == this_experiment_ln:
                internal_experiment_numbers_with_common_normalization.append(one_internal_experiment_number)

        #print "Experiments with common normalization: ",internal_experiment_numbers_with_common_normalization

        # Keep a sum of the weighting factors (1/error**2) in the normalization
        # and the summation of weighted normalization constants to get the
        # weighted mean normalization.
        normalization_constant = 0.0
        sum_of_weight_factors  = 0.0

        # Get the calculated and experimental yields from all detectors in each of these experiments.
        for one_internal_experiment_number in internal_experiment_numbers_with_common_normalization:
            #print "Internal expt number: ",one_internal_experiment_number 
            one_experiment_object = self.allexperiments[one_internal_experiment_number]
            one_experiment_number_of_detectors = one_experiment_object.get_number_of_detectors()
            for one_detector_number in range(one_experiment_number_of_detectors):
                one_detector_object = one_experiment_object.Ge_detectors[one_detector_number]
                # Get all calculated yields for this detector.
                one_detector_calculated_yields = one_detector_object.return_calculated_yields()

                # Get all experimental yields for this detector.
                one_detector_experimental_yields = one_detector_object.return_experimental_yields()

                # Add to the weighted mean ratio of experimental to calculated
                # yield only the ones for which both calculated and
                # experimental yields exist.
                for one_experimental_yield in one_detector_experimental_yields:

                    initial_band_name, initial_spin, final_band_name, final_spin, experimental_yield, experimental_yield_error = one_experimental_yield
                    try:
                        skip = False
                        experimental_initial_state_pointer_string = str(investigated_nucleus.levels[(initial_band_name, initial_spin)])
                        experimental_final_state_pointer_string   = str(investigated_nucleus.levels[(final_band_name, final_spin)])
                    except:
                        skip = True
                    if not skip:
                        for one_calculated_yield in one_detector_calculated_yields:
                            #print "Calc.: ",one_calculated_yield
                            calculated_initial_band_name, calculated_initial_spin, calculated_final_band_name, calculated_final_spin, calculated_yield = one_calculated_yield
                            try:
                                skip_calculated = False
                                calculated_initial_state_pointer_string = str(investigated_nucleus.levels[(calculated_initial_band_name, calculated_initial_spin)])
                                calculated_final_state_pointer_string   = str(investigated_nucleus.levels[(calculated_final_band_name, calculated_final_spin)])
                            except:
                                # One or both levels not found.
                                skip_calculated = True

                            # We need to check pseudonyms also (more work) or just
                            # compare the level pointers to see if the keys point to
                            # the same level.

                            if not skip_calculated and experimental_initial_state_pointer_string == calculated_initial_state_pointer_string and experimental_final_state_pointer_string == calculated_final_state_pointer_string:
                                # This calculated transition matches the
                                # experimental transition.  Add the weighted
                                # normalization constant to the sum.
                        
                                unweighted_normalization_constant = experimental_yield / calculated_yield 
                                # weight_factor = 1.0 / (experimental_yield_error / experimental_yield)**2  # Bad idea if weak transitions are not reproduced well.  Can be very misleading in chisq and plots.
                                # weight_factor = experimental_yield**2  # Heavier than Gosia
                                # Weighting by yield only.
                                weight_factor = experimental_yield  # Gosia does this.
                                weighted_normalization_constant = unweighted_normalization_constant * weight_factor
                                normalization_constant += weighted_normalization_constant 
                                sum_of_weight_factors  += weight_factor 
                                #print calculated_initial_band_name, calculated_initial_spin, calculated_final_band_name, calculated_final_spin, calculated_yield,experimental_yield, experimental_yield_error,experimental_yield/calculated_yield,weight_factor,weighted_normalization_constant

                                break # out of the search for the matching calculated yield.

                

        try:
            weighted_mean_normalization = normalization_constant / sum_of_weight_factors
        except:
            print "Error--there appear to be no calculated yields in memory.\nDid you integrate the yields?"
            return [None,None]

        # Return the internal experiment numbers to which this normalization
        # applies (so it doesn't need to be calculated extra times) and the
        # weighted mean normalization constant.

        return internal_experiment_numbers_with_common_normalization, weighted_mean_normalization 



    def generate_expt(self):
        """Generates a list of strings for the gosia input section EXPT

        This is done here, so that all experiments can be polled with one call,
        and so that records that depend on knowledge of other experiments can
        be generated simply.
        """

        # Begin the list of lines for gosia with "EXPT".
        expt_lines = ["EXPT"]

        # Get the number of experiments.  In the end, we may have to 
        # select based on whether they are "selected" or not.
        number_of_experiments = self.getnumberofexperiments()

        # Get the Z,A of the investigated nucleus.
        Z_1 = self.allexperiments[0].get_parameter("Z_1")
        A_1 = self.allexperiments[0].get_parameter("A_1")

        # The first line of EXPT is number_of_experiments,Z_1,A_1
        line = str(number_of_experiments) + " " + str(Z_1) + " " + str(A_1)
        expt_lines.append(line)

        for experiment_number in range(number_of_experiments):
            Z_n = self.allexperiments[experiment_number].get_parameter("Z_n")
            A_n = self.allexperiments[experiment_number].get_parameter("A_n")
            E_mean = self.allexperiments[experiment_number].get_parameter("E_mean")
            M_c = the_gosia_shell.get_number_of_magnetic_substates()
            M_a = the_gosia_shell.get_number_of_magnetic_substates_for_minimization()
            I_ax = self.allexperiments[experiment_number].get_parameter("I_ax")
            phi_1 = self.allexperiments[experiment_number].get_parameter("phi_1")
            phi_2 = self.allexperiments[experiment_number].get_parameter("phi_2")
            # I_kin is now handled below.
            LN = self.allexperiments[experiment_number].get_parameter("LN")
            excited_target = self.allexperiments[experiment_number].get_parameter("excited_target")
            detected_particle = self.allexperiments[experiment_number].get_parameter("detected_particle")
            is_inverse = self.allexperiments[experiment_number].is_inverse_kinematics()

            # Get the mean projectile scattering angle.  Apply the correct sign
            # flag to the mean polar angle: + for projectile detection; - for
            # target recoil detection
            theta_lab_mean = self.allexperiments[experiment_number].mean_scattering_angle()
            if detected_particle == "t":
                if is_inverse:
                    # If this is an inverse kinematics experiment, we
                    # need to pick the I_kin value corresponding to the mean target
                    # recoil angle.
                    Q_value = the_gosia_shell.return_kinematics_state_data()[2] / 1000. # Convert to MeV
                    # Get the critical angle between the two solutions.
                    if excited_target:
                        # Particle n is the target particle, because this is target detection.
                        A_proj = A_n
                        A_targ = A_1
                    else:
                        A_proj = A_1
                        A_targ = A_n

                    theta_lab_crit = inelastic_maximum_scattering_angle(A_proj,A_targ,E_mean,Q_value)

                    # From this, get the corresponding target angle.  Close to
                    # the critical angle, we can choose arbitrarily one solution
                    # or the other (False, in this case).
                    # Try to get the recoil angle corresponding to the maximum scattering angle.

                    # This can cause overflows, so we iterate this, changing the scattering angle slightly until we don't get an overflow.
                    theta_iterate = theta_lab_crit
                    while True:
                        try:
                            theta_recoil_crit = inelastic_lab_scattering_angle_to_lab_recoil_angle(A_proj,A_targ,theta_iterate,False,E_mean,Q_value)
                            break # Found a value that didn't overflow.
                        except:
                            # Lower the angle by a tiny bit.
                            theta_iterate = 0.99999 * theta_iterate
                            

                    # Get the mean TARGET angle.
                    theta_targ_max = self.allexperiments[experiment_number].get_parameter("theta_lab_max")
                    theta_targ_min = self.allexperiments[experiment_number].get_parameter("theta_lab_min")
                    theta_targ_mean = (theta_targ_max + theta_targ_min) / 2.
                    # If the mean target angle is greater than the critical
                    # TARGET recoil angle, then it is the forward c.o.m.
                    # PROJECTILE solution.
                    if theta_targ_mean >= theta_recoil_crit:
                        # Forward solution.
                        I_kin = 1
                    else:
                        # Backward solution.
                        I_kin = 0

                else:
                    # Simple case of normal kinematics.  I_kin is ignored.
                    I_kin = 0

                # Note the negative flag applied here as a flag to gosia for target detection.
                theta_lab_mean = -theta_lab_mean

            else:
                # Just look up the one the user chose in defining the experiment.
                I_kin = self.allexperiments[experiment_number].get_parameter("I_kin")
                
            # Decide on appropriate +/- sign flag for the Zn entry.  If the beam
            # is excited, then it gets a negative-sign flag; otherwise positive.
            if not excited_target:
                # if the beam is excited, then multiply Z_n by -1
                Z_n = -Z_n
            #print "LN = ",LN, "  debugging"
            # Construct the EXPT line for this experiment (experiment_number)
            line_list = [Z_n, A_n, E_mean, theta_lab_mean, M_c, M_a, I_ax, phi_1, phi_2, I_kin, LN]
            line = str(line_list).strip('[]')   # Turn line_list into a comma-delimited string with 
                                                # the list brackets removed.
            expt_lines.append(line)

        return expt_lines

    def generate_yiel(self,type_of_input):
        """Generates a list of strings for the gosia input section OP,YIEL.

        type_of_input is one of "intg" "mini" "corr" "map" etc.

        This is being modified to handle the OP,RAW format for Ge cluster
        detectors--June 3 2011.


        This also generates the OP,RAW block if necessary, since this is always
        paired with OP,YIEL and uses the same information to generate it.

        The OP,RAW input is hard-coded for a constant efficiency as a function
        of gamma energy.  The user must correct each Ge or cluster data set for
        the relative efficiency of the detector.

        It is not yet clear whether this is robust for mixed single-crystals
        and clusters in a single experiment.

        """

        # Collect a list of experiments which use raw detectors.
        raw_internal_experiment_numbers = []
        #default_raw_efficiency_parameters = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0]
        # The old parameters with 7th entry of 1.0 gives a fast fall-off for energy <~6 keV.

        # The following efficiency parameters for OP,RAW with a 7th term of -50
        # give a flat efficiency of 1 down to <1.0e-10 keV.

        default_raw_efficiency_parameters = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -50.0, 1.0]
        
        # The first line is to turn on or off the gamma-angle correction for
        # decay in flight.  This is now turned on for the first time in version
        # -38.  The next two lines are to run OP,BRIC, which will be the
        # default for now.
        yiel_lines = ["OP,YIEL",\
                      "1",\
                      "-1,0",\
                      "1.0"]

        # The NANG line for number of detectors.  
        # Poll the experiments to see how many detectors are in each one.  Here
        # we need the individual germanium crystals, so clusters have to be
        # handled differently than individual crystals.
        nang_list = []
        for one_experiment in self.allexperiments:
            # number_of_germaniums will be incremented as each crystal or cluster attached to
            # this experiment is evaluated until the full count is obtained.
            number_of_germaniums = 0  
            number_of_clusters_and_crystals = one_experiment.get_number_of_detectors()
            for internal_detector_number in range(number_of_clusters_and_crystals):
                if one_experiment.get_detector_information(internal_detector_number,"is_crystal"):
                    # Increment detector count by one for a single crystal
                    number_of_germaniums += 1
                else:
                    # This is a cluster.  Get the number of Ge detectors in the
                    # cluster and add this to the number_of_germaniums count.
                    number_of_crystals_in_this_cluster = one_experiment.get_detector_information(internal_detector_number,"number_of_crystals")
                    number_of_germaniums += number_of_crystals_in_this_cluster 
                    
            nang_list.append(number_of_germaniums)

        # Make line into one string
        nang_line = ""
        for field in nang_list:
            nang_line = nang_line + str(field) + "  "
        # Now nang_line is complete
        yiel_lines.append(nang_line)

        internal_experiment_number = 0
        # Add detector number, theta, phi for each experiment.

        for one_experiment in self.allexperiments:
            this_experiment_needs_raw = False # Will be marked true if at least one detector is a cluster for this experiment
            detector_line = ""
            theta_line    = ""
            phi_line      = ""
            for internal_detector_number in range(one_experiment.get_number_of_detectors()):
                # Is this a crystal or a cluster?
                if one_experiment.get_detector_information(internal_detector_number,"is_crystal"):
                    # Get the (external, gosia) type number, theta and phi
                    internal_type_number = one_experiment.get_detector_information(internal_detector_number,"type")
                    gosia_type_number    = internal_type_number + 1
                    theta                = one_experiment.get_detector_information(internal_detector_number,"theta")
                    phi                  = one_experiment.get_detector_information(internal_detector_number,"phi")
                    detector_line = detector_line + str(gosia_type_number) + "  " 
                    theta_line    = theta_line    + str(theta)             + "  " 
                    phi_line      = phi_line      + str(phi)               + "  " 
                else:
                    # This is a cluster detector.  Get the lists of type numbers, theta and phi values
                    internal_type_numbers = one_experiment.get_detector_information(internal_detector_number,"types")
                    # Add 1 to each type number to get the base-1 numbers for gosia.
                    gosia_type_numbers = [i+1 for i in internal_type_numbers]  # Adding one to each element.
                    thetas                = one_experiment.get_detector_information(internal_detector_number,"thetas")
                    phis                  = one_experiment.get_detector_information(internal_detector_number,"phis")
                    # Extend the type, theta and phi lines with all detectors in this cluster.
                    detector_line = detector_line + str(gosia_type_numbers).strip('[]').replace(',',' ') + "  " 
                    theta_line    = theta_line    + str(thetas).strip('[]').replace(',',' ')             + "  " 
                    phi_line      = phi_line      + str(phis).strip('[]').replace(',',' ')               + "  " 
                    this_experiment_needs_raw = True

            # Update the list of experiments that need an op,raw input.  If at
            # least one cluster was found in this experiment, then it needs
            # op,raw for all detectors.
            if this_experiment_needs_raw:
                raw_internal_experiment_numbers.append(internal_experiment_number)

            # Increment the internal experiment number, since we are not
            # looping on the index, but using "one_experiment in
            # self.allexperiments" instead.
            internal_experiment_number += 1

            yiel_lines.extend([detector_line,theta_line,phi_line])


        # Call the nucleus object to give the gosia levels for the normalizing
        # transition.
        try:
            normalization_initial_state_key, normalization_final_state_key = investigated_nucleus.get_normalization_transition_keys()
        except:
            block_print_with_line_breaks("You have not yet defined the normalization transition properly, or you have deleted the levels that define the normalization transition.  Use the \"Gosia controls\" button, option \"t\" to define the normalization transition.  See help topic \"normalizationtransition.\"",60)

            return ["Error in generate_yiel."]

        NS1, NS2 = investigated_nucleus.get_gosia_normalization_state_indices()

        if NS1 == None or NS2 == None:
            block_print_with_line_breaks("You have not yet defined the normalization transition properly, or you have deleted the levels that define the normalization transition.  Use the \"Gosia controls\" button, option \"t\" to define the normalization transition.  See help topic \"normalizationtransition.\"",60)
            return ["Error in generate_yiel."]

        # Construct a string entry from the two integers that define the
        # normalization transition.  These are NS1, NS2 in the gosia manual
        # entry for OP,YIEL.
        normalization_line = str(NS1) + "," + str(NS2)
        yiel_lines.append(normalization_line)

        # NDST, UPL, YNRM lines 
        for one_experiment in self.allexperiments:
            ndst = one_experiment.get_number_of_detectors() # for now, just the number of germaniums 
            ndst_line = str(ndst) 
            # For now, all upper limits set at 1.0e10 to turn off UPL in most cases.  This will be enabled in a later version.
            upl_line = ""
            for i in range(ndst):
                upl_line = upl_line + str(1.0e10) + " "
            # YNRM constants:
            ynrm_line = ""
            # Get the YNRM constants for this experiment.  I have tested OP,CORR
            # and OP,MINI using Rutherford cross sections where *independent*
            # normalizations are used in the EXPT section, and they are ignored
            # by gosia, as they should be; the CORR and MINI results are
            # unaffected by the YNRM values.
            ynrm_list = one_experiment.return_ge_normalizations()
            for i in range(ndst):
                ynrm_line = ynrm_line + str(ynrm_list[i]) + " "

            yiel_lines.extend([ndst_line,upl_line,ynrm_line])  # NDST, UPL, YNRM 

        # Select NTAP based on type_of_input
        if type_of_input == "mini" or type_of_input == "map" or type_of_input == "diag":
            ntap_line = "4   !NTAP"
        elif type_of_input == "corr":
            ntap_line = "3   !NTAP"
        else:
            ntap_line = "0   !NTAP"
        yiel_lines.append(ntap_line)

        if type_of_input == "mini" or type_of_input == "diag":
            print "Selecting nuclear data applicable to this calculation..."
            # Get nuclear data appropriate for this calculation from the user's
            # file on disk.  (This is updated at every call, in case the user
            # changed something.)  The expt_mgr "get" method re-reads the file. 
            # Data set weights are passed in from the gosia shell object.
            branching_weight      = the_gosia_shell.get_branching_weight()
            lifetime_weight       = the_gosia_shell.get_lifetime_weight()
            mixing_ratio_weight   = the_gosia_shell.get_mixing_ratio_weight()
            matrix_element_weight = the_gosia_shell.get_matrix_element_weight()
            nuclear_data_lines = the_experiment_manager.get_nuclear_data_lines(branching_weight,lifetime_weight,mixing_ratio_weight,matrix_element_weight)
            yiel_lines.extend(nuclear_data_lines)
        else:
            temp_lines = ["0,0" for n in range(4)]
            yiel_lines.extend(temp_lines)

        # Generate the OP,RAW block if at least one experiment uses clusters.
        if not raw_internal_experiment_numbers == []:
            # There is at least one experiment that uses clusters.
            op_raw_lines = ["OP,RAW"]

            for one_internal_experiment_number in raw_internal_experiment_numbers:
                # Mark this experiment number as raw.
                this_gosia_experiment_number = one_internal_experiment_number + 1
                op_raw_lines.append(str(this_gosia_experiment_number))  # Add the experiment number IEXP to the OP,RAW input.
                one_experiment = self.allexperiments[one_internal_experiment_number]
                # Create a list to remember the detector information temporarily.
                this_experiment_detector_list = []
                number_of_clusters_in_this_experiment = 0
                total_number_of_crystals_in_this_experiment = 0
                current_logical_detector_number = 0
                for internal_detector_number in range(one_experiment.get_number_of_detectors()):

                    if one_experiment.get_detector_information(internal_detector_number,"is_crystal"):
                        total_number_of_crystals_in_this_experiment += 1
                        current_logical_detector_number += 1
                        # Add a line of efficiency parameters for this logical detector.
                        op_raw_lines.append(str(default_raw_efficiency_parameters).strip('[]').replace(',',' '))  # strip out the braces and the commas
                        this_experiment_detector_list.append(["is_crystal",internal_detector_number])
                    else:
                        # This is a cluster.  Get the list of logical detector numbers for this crystal.
                        number_of_crystals_in_this_cluster = one_experiment.get_detector_information(internal_detector_number,"number_of_crystals")
                        first_logical_detector_number = total_number_of_crystals_in_this_experiment + 1
                        for logical_detector_number in range(current_logical_detector_number,\
                          current_logical_detector_number + number_of_crystals_in_this_cluster):
                            # Add an efficiency line for this logical detector.
                            op_raw_lines.append(str(default_raw_efficiency_parameters).strip('[]').replace(',',' '))  # strip out the braces and the commas
                        this_experiment_detector_list.append(["is_cluster",number_of_crystals_in_this_cluster])
                        total_number_of_crystals_in_this_experiment += number_of_crystals_in_this_cluster 
                        number_of_clusters_in_this_experiment += 1

                # Complete the op,raw input for this experiment.  
                gosia_logical_detector_number = 1  # start the count at 1 again for this experiment
                op_raw_lines.append(str(number_of_clusters_in_this_experiment))  # Total number of clusters in this experiment.
                for one_entry in this_experiment_detector_list:
                    if one_entry[0] == "is_cluster":
                        # Add a line for the number of crystals in this cluster:
                        number_of_crystals = one_entry[1]
                        number_of_clusters_line = str(number_of_crystals)
                        op_raw_lines.append(number_of_clusters_line)  # Total number of clusters in this experiment.
                        # Add a line listing the logical detector numbers in this cluster:
                        logical_detector_numbers_in_this_cluster = range(gosia_logical_detector_number,\
                          gosia_logical_detector_number + number_of_crystals)
                        logical_detectors_string = str(logical_detector_numbers_in_this_cluster).strip('[]').replace(',',' ')
                        op_raw_lines.append(logical_detectors_string)
                        gosia_logical_detector_number += number_of_crystals 
                    else:
                        # This is a single crystal.  Don't add to the op,raw input; only increment the logical_detector_number.
                        gosia_logical_detector_number += 1

            # Append a terminating line "0" for op,raw block.
            op_raw_lines.append("0")

            yiel_lines.extend(op_raw_lines)


        # This is the end of OP,YIEL.

        return yiel_lines


    def generate_intg(self):
        """Generates a list of strings for the gosia input section OP,INTG.

        This is done here, so that all experiments can be polled with one call,
        and so that records that depend on knowledge of other experiments can
        be generated simply.

        """

        # Lists for the lines generated for the gosia input.
        mesh_lines = []
        stopping_and_subdivision_lines = []

        number_of_experiments = self.getnumberofexperiments()
        for experiment_number in range(number_of_experiments):
            theta_min = self.allexperiments[experiment_number].get_parameter("theta_lab_min")
            theta_max = self.allexperiments[experiment_number].get_parameter("theta_lab_max")
            E_exit = self.allexperiments[experiment_number].get_parameter("E_exit")
            E_beam = self.allexperiments[experiment_number].get_parameter("E_beam")
            I_ax   = self.allexperiments[experiment_number].get_parameter("I_ax")
            phi_1   = self.allexperiments[experiment_number].get_parameter("phi_1")
            phi_2   = self.allexperiments[experiment_number].get_parameter("phi_2")
            number_of_energy_meshpoints = self.allexperiments[experiment_number].get_parameter("number_of_energy_meshpoints")
            number_of_theta_meshpoints = self.allexperiments[experiment_number].get_parameter("number_of_theta_meshpoints")
            annular =  self.allexperiments[experiment_number].get_parameter("annular")

            # Generate the energy meshpoints
            energy_meshpoints = list(numpy.linspace(E_exit,E_beam,number_of_energy_meshpoints))
            energy_meshpoints_line = str(energy_meshpoints).strip('[]')


            # For non-axial symmetry, we need to add one phi range for each
            # theta meshpoint.  Currently, we are treating only partitions of
            # data with boundaries of constant theta and phi.
            azimuthal_boundary_lines = []
            if annular:
                # Get theta meshpoints generated by the experiment object for a smooth
                # sampling of the Rutherford cross section.
                #theta_meshpoints = self.allexperiments[experiment_number].angular_meshpoints()  # This has been deprecated in version 1.5.7
                theta_meshpoints = self.generate_angular_meshpoints(theta_min,theta_max,number_of_theta_meshpoints)
                theta_meshpoints_line = str(theta_meshpoints).strip('[]')

                # The first line for this experiment is NE, +/-NT, E_exit, E_beam, theta_min, theta_max
                experiment_header_line_list = [number_of_energy_meshpoints,number_of_theta_meshpoints,E_exit,E_beam,theta_min,theta_max]
                experiment_header_line = str(experiment_header_line_list).strip('[]')
                # Append the expt header line and two meshpoint lines to the input list
                mesh_lines.extend([experiment_header_line,energy_meshpoints_line,theta_meshpoints_line])
                if I_ax == 1:  # This is always an integer, so this is a safe test.
                    for i in range(number_of_theta_meshpoints):
                        azimuthal_boundary_lines.append("1 ")
                        boundary_string = str(phi_1) + "  " + str(phi_2)
                        azimuthal_boundary_lines.append(boundary_string)

                    # Add these to the mesh_lines, so that they will appear
                    # directly below the rest of the input for this experiment.
                    mesh_lines.extend(azimuthal_boundary_lines)
            else:
                # Arbitrary shaped detector.
                # Now add the lines for this experiment of arbitrary detector shape.
                NFI_lines = []
                theta_lab_min = self.allexperiments[experiment_number].get_parameter("theta_lab_min")
                theta_lab_max = self.allexperiments[experiment_number].get_parameter("theta_lab_max")
                theta_meshpoints = self.allexperiments[experiment_number].get_parameter("theta_meshpoints")
                number_of_theta_meshpoints = len(theta_meshpoints)
                theta_meshpoints_line = str(theta_meshpoints).strip('[]')

                # The first line for this experiment is NE, +/-NT, E_exit, E_beam, theta_min, theta_max
                experiment_header_line_list = [number_of_energy_meshpoints,number_of_theta_meshpoints,E_exit,E_beam,theta_min,theta_max]
                experiment_header_line = str(experiment_header_line_list).strip('[]')
                # Append the expt header line and two meshpoint lines to the input list
                mesh_lines.extend([experiment_header_line,energy_meshpoints_line,theta_meshpoints_line])
                NFI_list = self.allexperiments[experiment_number].get_parameter("NFI_list")
                for i in range(len(NFI_list)):
                    this_theta = NFI_list[i][0]
                    phi_list = NFI_list[i][1:]
                    NFI_string = str(len(phi_list)/2)
                    NFI_lines.append(NFI_string)
                    NFI_lines.append(str(phi_list).strip("[]"))

                mesh_lines.extend(NFI_lines)            

            # Now get the stopping power data for each experiment.  Since this
            # is automated, no need to abbreviate using 0 for experiments with
            # repeated stopping powers.  Instead, just repeat the stopping power
            # data for every experiment.
            stopping_power_lines = self.allexperiments[experiment_number].get_stopping_power_lines()
            stopping_and_subdivision_lines.extend(stopping_power_lines)

            # Now generate the subdivision line.
            subdivision_line = str(self.allexperiments[experiment_number].get_energy_subdivisions()) + " " + \
              str(self.allexperiments[experiment_number].get_theta_subdivisions())
            stopping_and_subdivision_lines.append(subdivision_line)

        # Now put together the lines for all sections of OP,INTG and return to the caller
        intg_lines = ["OP,INTI"]
        intg_lines.extend(mesh_lines)
        intg_lines.extend(stopping_and_subdivision_lines)
        return intg_lines


    def get_numbers_of_detectors(self):
        """Returns a list of the number of Ge detectors in each experiment.

        """
        # Make a list of numbers of Ge detectors for each experiment to be read.
        numbers_of_detectors = []
        for one_experiment in self.allexperiments:
            number_of_detectors_in_this_experiment = one_experiment.get_number_of_detectors()
            numbers_of_detectors.append(number_of_detectors_in_this_experiment)

        return numbers_of_detectors

    def export_txt_file_yields(self):
        """Exports the experimental yield data for one detector to a Rachel formatted txt file.

        """
        self.print_experiment_catalog()
        try:
            experiment_number = int(raw_input("Experiment number or return to quit: ")) 
            internal_experiment_number = experiment_number - 1
            self.allexperiments[internal_experiment_number].print_detector_catalog()
            detector_number = int(raw_input("Detector number to export experimental yields or return to quit: ")) 
            internal_detector_number = detector_number - 1
        except:
            print "Invalid experiment number.  Quitting."
            return -1

        try:
            experimental_yields_for_this_detector = self.allexperiments[internal_experiment_number].get_experimental_yields(internal_detector_number)
        except:
            print "Invalid detector number.  Quitting."
            return -1

        number_of_yields_in_memory = len(experimental_yields_for_this_detector)
        print "This detector has ",number_of_yields_in_memory, "yields."
        # Get the requested file name and write the yields to the file.
        file_name = prompt_for_file_name(prompt_string = "Enter file name to save yields: ")

        text_columns = 20
        float_columns = 20
        spin_columns  = 5
        lines_to_write = []

        # Make a dictionary to sort the yields by band number and spin.
        yield_sorting_dict = {}

        # Get the number of bands.
        band_number_for_unknown_levels = investigated_nucleus.number_of_bands(include_inactive_levels = True) + 1

        # Add the yield entries to the sorting dict.
        for one_yield in experimental_yields_for_this_detector:
            initial_band_name, initial_spin, final_band_name, final_spin, experimental_yield, experimental_error = one_yield
            initial_band_number = investigated_nucleus.get_band_number_for_display(initial_band_name)
            final_band_number   = investigated_nucleus.get_band_number_for_display(final_band_name)
            # Need to handle yields properly if they are for bands that are not
            # currently in the level scheme.  These would return a band number
            # of -1.  Now the data for unknown bands all get lumped at the end of the output.
            if not -1 in [initial_band_number, final_band_number]:
                sorting_key = (initial_band_number, initial_spin, final_band_number, final_spin)
            else:
                sorting_key = (band_number_for_unknown_levels, initial_spin, band_number_for_unknown_levels, final_spin)
                band_number_for_unknown_levels += 1

                # Key yields for unknown bands by a large band number.
            line_to_write = initial_band_name.ljust(text_columns) + " " + str(initial_spin).ljust(spin_columns) + " " + final_band_name.ljust(text_columns) + " " + str(final_spin).ljust(spin_columns) + " " + str(experimental_yield).ljust(float_columns) + " " + str(experimental_error).ljust(float_columns)
            yield_sorting_dict[sorting_key] = line_to_write

        # Check that all yields are in the dictionary.
        number_of_yields_in_dictionary = len(yield_sorting_dict)
        if not number_of_yields_in_dictionary == number_of_yields_in_memory:
            print "Error writing yields to file.  Please report this bug."
            return -1

        # Sort the keys to order the yields nicely for the user.
        sorting_keys = yield_sorting_dict.keys()
        sorting_keys.sort()
        for one_key in sorting_keys:
            lines_to_write.append(yield_sorting_dict[one_key])

        write_lines_to_file(file_name,lines_to_write)
        print "Wrote ",number_of_yields_in_dictionary," experimental yields for experiment",experiment_number,", detector",detector_number," to file ",file_name,"."
        print "Finished."


    def set_one_detector_to_auto_load(self,internal_experiment_number=None, internal_detector_number=None, yield_file_type=None, yield_file_name=None):
        """Sets the specified Ge detector in one experiment to auto-load yield data.

        """
        if None in [internal_experiment_number, internal_detector_number, yield_file_type, yield_file_name]:
            print "Failed to set detector auto-load."
            return -1

        return_code = self.allexperiments[internal_experiment_number].Ge_detectors[internal_detector_number].\
          set_to_auto_load(yield_data_file_type = yield_file_type, yield_data_file_name = yield_file_name)

        return return_code


    def read_txt_file_yields(self,txt_yield_file_name=None,internal_experiment_number=None,internal_detector_number=None):
        """Reads experimental yields according to the rachel.py format.

        If the yield file name passed is not None, then the prompts are skipped
        and the output is less verbose.  If the file name is passed, then the
        experiment and detector number must also be passed (internal numbering,
        0 to n).

        initial_band_name initial_spin final_band_name final_spin yield error
        Band names must not contain whitespace.

        e.g.
        gsb 20 gsb 18 .123 .012  # optional comment
        gam 10 gsb 8  .345 .034
        #gam 8 gam 6  .567 .056
        etc.

        Lines can be "commented out" as in the third example above.  These will
        be skipped.

        See also the read_ags_file_yields for the conditions under which yields
        are skipped.

        """

        if not txt_yield_file_name == None:
            # Run less verbose, and take the experiment number and detector number passed.
            silent = True
            if internal_experiment_number == None or internal_detector_number == None:
                print "No experiment number or detector number specified for file ", txt_yield_file_name 
                print "Expt. # ",internal_experiment_number + 1, ", Ge detector # ", internal_detector_number + 1
                return -1
        else:
            silent = False

        # Ask the user for the experiment and detector number (gosia indexing--starting with 1 for both).
        # Need to make listing methods to display experiments and detectors by proper indices.
        if not silent:
            self.print_experiment_catalog()
            gosia_experiment_number = prompt_number("Gosia experiment number or \"q\" to quit: ","i")
            if gosia_experiment_number == "quit":
                return 0
            # Convert to the internal (base 0) numbering.
            internal_experiment_number = gosia_experiment_number - 1
            # Give a list of detector choices.
            self.allexperiments[internal_experiment_number].print_detector_catalog()
            gosia_detector_number = prompt_number("Ge detector number for this experiment or \"q\" to quit: ","i")
            if gosia_detector_number == "quit":
                return 0
            # Convert to the internal (base 0) numbering.
            internal_detector_number = gosia_detector_number - 1
        else:
            gosia_experiment_number = internal_experiment_number + 1
            gosia_detector_number   = internal_detector_number   + 1

        if not silent:
            # Prompt for the text file name and read it.
            txt_yield_file_name = prompt_for_file_name(prompt_string = "TXT file to read: ")

            # Ask the user whether this should be set as the auto-load data
            # file for this detector.  If so, set this detector to auto-load
            # from this file name.
            set_auto_load = yes_no_prompt("Set this detector to auto-load from this file [Y/n]? ",True)
            if set_auto_load:
                self.set_one_detector_to_auto_load(internal_experiment_number=internal_experiment_number, \
                  internal_detector_number=internal_detector_number, yield_file_type = "txt", \
                  yield_file_name=txt_yield_file_name)
            else:
                print "Keeping current auto-load settings."

        with open(txt_yield_file_name,'r') as experimental_yield_file:
            txt_yield_file_lines = experimental_yield_file.readlines()

        # A temporary list to store yields before sending to the experiment object.
        this_detector_yields = []
        for this_line in txt_yield_file_lines:
            # Strip off any comments following at least one "#" symbol and
            # split the earlier part into fields.
            this_line_fields = this_line.split("#")[0].split()

            # Check that there are exactly 6 fields remaining after comments
            # have been removed.
            if len(this_line_fields) == 6:
                initial_band_name = this_line_fields[0]
                final_band_name   = this_line_fields[2]
                initial_spin      = round(float(this_line_fields[1]),1)
                final_spin        = round(float(this_line_fields[3]),1)
                experimental_yield = float(this_line_fields[4])
                experimental_error = float(this_line_fields[5])
                if experimental_yield > 0.:
                    # Append this yield, even if the levels are not in memory.
                    # This allows the user to read back in these levels later
                    # and have the yield data immediately.
                    this_yield_point = [initial_band_name, initial_spin, final_band_name, \
                      final_spin, experimental_yield, experimental_error]
                    # Append this yield point to the list for this detector
                    this_detector_yields.append(this_yield_point)
                    if not silent:
                        print "Stored yield for transition ",initial_band_name, initial_spin,"-->",\
                          final_band_name, final_spin,":", experimental_yield," +/- ",experimental_error
                else:
                    # Yield was 0 or negative
                    if not silent:
                        print "Skipped yield for transition ",initial_band_name, initial_spin,"-->",\
                          final_band_name, final_spin,
                        print "  because yield is not positive (Y = ",experimental_yield,")."
            else:
                # There were not exactly 6 fields aside from comments.
                if not silent:
                    print "Skipping line ",this_line[:20],"... because there were not 6 data fields."


        # Count the actual number of gammas read.  (Some may have been skipped,
        # if levels in the ags file were not found in memory, or if some had
        # non-positive yields.)
        actual_transitions_recorded = len(this_detector_yields)

        # Give the EXPERIMENTAL yields to the experiment object to store.
        self.allexperiments[internal_experiment_number].set_one_detector_experimental_yields(internal_detector_number,this_detector_yields)

        print actual_transitions_recorded," experimental yields read for experiment ",gosia_experiment_number,", detector ",gosia_detector_number,"."
        
        return 0

    def read_ags_file_yields(self,ags_file_name=None,internal_experiment_number=None,internal_detector_number=None):
        """Reads the yields from a Radware ags file and stores them in an internal format.

        If the yield file name passed is not None, then the prompts are skipped
        and the output is less verbose.  If the file name is passed, then the
        experiment and detector number must also be passed (internal numbering,
        0 to n).

        Ask the user which experiment and detector, then put the yields into the appropriate experiment objects.

        In order for this to work with certainty, the band names and spins in the ags file must be the same as those read into the nucleus object.  

        The procedure will be something like this:
        Create the final level scheme in Radware.
        Begin the rachel setup by reading the level scheme from it.
        Bands can be safely merged in Rachel (at the start of the setup).
        Bands and levels can be deleted in Rachel.
        Make sure that no changes are made in the Radware file after the initial read, and fit/set the intensities of all gammas.
        (Gammas can be added/deleted, but the level numbers in the ags file must not change.)
        Create all experiments and attach detectors.
        Read in one ags file for each detector in each experiment.

        Added a check that Radware's yield is >0.  If not, then the yield is discarded.

        Nov. 11 2010:  Yields will be applied to a transition by spin and band
        name or pseudonym, where the pseudonym is the original band name if
        bands were merged in the GUI.  This will make the reading of yields
        robust even after modifying the Radware level scheme.

        """


        if not ags_file_name == None:
            # Run less verbose, and take the experiment number and detector number passed.
            silent = True
            if internal_experiment_number == None or internal_detector_number == None:
                print "No experiment number or detector number specified for file ", ags_file_name 
                print "Expt. # ",internal_experiment_number + 1, ", Ge detector # ", internal_detector_number + 1
                return -1
        else:
            silent = False

        # Ask the user for the experiment and detector number (gosia indexing--starting with 1 for both).
        # Need to make listing methods to display experiments and detectors by proper indices.
        if not silent:
            self.print_experiment_catalog()
            gosia_experiment_number = prompt_number("Gosia experiment number or \"q\" to quit: ","i")
            if gosia_experiment_number == "quit":
                return 0
            # Convert to the internal (base 0) numbering.
            internal_experiment_number = gosia_experiment_number - 1
            # Give a list of detector choices.
            self.allexperiments[internal_experiment_number].print_detector_catalog()
            gosia_detector_number = prompt_number("Ge detector number for this experiment: ","i")
            if gosia_detector_number == "quit":
                return 0
            # Convert to the internal (base 0) numbering.
            internal_detector_number = gosia_detector_number - 1
        else:
            gosia_experiment_number = internal_experiment_number + 1
            gosia_detector_number   = internal_detector_number   + 1

        if not silent:
            # Prompt for the ags file and read it.
            ags_file_name = prompt_for_file_name("AGS file to read: ")

            # Ask the user whether this should be set as the auto-load data
            # file for this detector.  If so, set this detector to auto-load
            # from this file name.
            set_auto_load = yes_no_prompt("Set this detector to auto-load from this file [Y/n]? ",True)
            if set_auto_load:
                self.set_one_detector_to_auto_load(internal_experiment_number=internal_experiment_number, \
                  internal_detector_number=internal_detector_number, yield_file_type = "ags", \
                  yield_file_name=ags_file_name)
            else:
                print "Keeping current auto-load settings."

        with open(ags_file_name,'r') as experimental_yield_file:
            ags_file_lines = experimental_yield_file.readlines()

        # Check the number of gammas in the file
        linenumber = 1 + findinlist(ags_file_lines,["Z","Nlevels","Ngammas","Nbands"])
        number_of_levels_in_ags_file = int(ags_file_lines[linenumber].split()[1])
        number_of_gammas_in_ags_file = int(ags_file_lines[linenumber].split()[2])
        number_of_bands_in_ags_file = int(ags_file_lines[linenumber].split()[3])
        if not silent:
            print number_of_gammas_in_ags_file," gamma yields to be read." 

        # Nov 11 2010: 
        # Read the Radware band number of each level in the ags file to match it to the 
        # band names.  A dictionary to look up the current band number for each level in 
        # the AGS file and one to look up the spin.
        ags_file_band_number_dict = {}
        ags_file_spin_dict = {}
        this_line_number = findinlist(ags_file_lines,["Level","Energy","err","Jpi","K","Band#"]) + 2
        for i in range(number_of_levels_in_ags_file):
            this_line_fields = ags_file_lines[this_line_number].split()
            temporary_ags_level_number = int(this_line_fields[0])
            temporary_ags_band_number  = int(this_line_fields[5])
            ags_file_band_number_dict[temporary_ags_level_number] = temporary_ags_band_number
            this_line_number = this_line_number + 2
            # Record the spin.  To parse the spin, first we need to test whether it's integer or half integer.
            # Note that in Python rounded floats can be tested for equivalence to another rounded float.
            # Note that in Radford's ags file library, he sometimes puts the
            # parity symbol on the left, sometimes on the right, hence .strip
            # instead of .rstrip
            spintext = this_line_fields[3].strip('+-')  # Strip pluses and minuses from the spin text
            if "/" in spintext:  # half-integer spin
                fractionformspin = spintext.partition('/')
                this_level_spin = round(float(fractionformspin[0]) / float(fractionformspin[2]),1)
            else:
                this_level_spin = round(float(spintext),1)
            ags_file_spin_dict[temporary_ags_level_number] = this_level_spin


        # Nov 11 2010: 
        # Read the band name information so that yields can be matched to
        # levels in memory by band name or pseudonym and spin.
        band_info_line = findinlist(ags_file_lines,["Band","Name","X0","NX","LabelDX","LabelDY","EnLabelDX","EnLabelDY"])
        band_starting_line = band_info_line + 1
        # Make a temporary dictionary of Radware's band names and numbers to match yields to the levels in memory.
        temporary_ags_band_dict = {}
        for line_number in range(band_starting_line, band_starting_line + number_of_bands_in_ags_file):
            this_line = ags_file_lines[line_number]
            temporary_band_number = int(this_line[0:5])
            temporary_band_name   = this_line[6:14]      # 8 character string band name
            temporary_ags_band_dict[temporary_band_number] = string.join(temporary_band_name.split(),"")  # Assign Radware band name to Radware band number (spaces removed).

        gamma_info_line = findinlist(ags_file_lines,["Gamma","Energy","Mult"]) 
        
        # A temporary list to store yields before sending to the experiment object.
        this_detector_yields = []
        for gamma_number in range(number_of_gammas_in_ags_file):
            gamma_info_line = gamma_info_line + 3  # Skip to the next entry in the gamma data
            this_line_fields = ags_file_lines[gamma_info_line].split()
            gamma_energy = round(float(this_line_fields[1]),1)
            initial_ags_level = int(this_line_fields[5])
            final_ags_level   = int(this_line_fields[6])

            # Some ags files do not have yields.  Fields 7 and 8 are missing
            # for these entries.
            try:
                experimental_yield = float(this_line_fields[7])
                experimental_error = float(this_line_fields[8])
                intensity_data = True
            except:
                if not silent:
                    print "Skipping gamma #",gamma_number + 1," because there is no intensity data"
                intensity_data = False
            if intensity_data:
                # The gamma flag is non-zero in the AGS file if the gamma-ray is tentative.
                # Read the gamma flag, which is on the third line of the gamma-ray entry.
                gamma_flag = int(ags_file_lines[gamma_info_line + 2].split()[5])
                initial_ags_band_number = ags_file_band_number_dict[initial_ags_level]
                final_ags_band_number   = ags_file_band_number_dict[final_ags_level]
                initial_ags_band_name   = temporary_ags_band_dict[ags_file_band_number_dict[initial_ags_level]]
                final_ags_band_name     = temporary_ags_band_dict[ags_file_band_number_dict[final_ags_level]]
                initial_ags_spin        = ags_file_spin_dict[initial_ags_level]
                final_ags_spin          = ags_file_spin_dict[final_ags_level]
                # If Radware's fit yield is not greater than 0, then we won't read it.
                # Nov. 11 2010: Yields of tentative gammas will also be ignored.
                if experimental_yield > 0. and gamma_flag == 0:
                    # Append this yield, even if the levels are not in memory.
                    # This allows the user to read back in these levels later
                    # and have the yield data immediately.
                    this_detector_yields.append([initial_ags_band_name, initial_ags_spin, \
                      final_ags_band_name, final_ags_spin, experimental_yield, experimental_error])
                    if not silent:
                        print "Stored yield for transition ",initial_ags_band_name, initial_ags_spin,"-->",\
                          final_ags_band_name, final_ags_spin," (",gamma_energy," keV):",\
                          experimental_yield," +/- ",experimental_error
                else:
                    # Yield was 0 or negative
                    if not silent:
                        print "Skipped yield for transition ",initial_ags_band_name, initial_ags_spin,"-->",\
                          final_ags_band_name, final_ags_spin," (",gamma_energy," keV):",
                        if gamma_flag == 0:
                            print "  because yield is not positive (Y = ",experimental_yield,")."
                        else:
                            print "  because gamma-ray is tentative."


        # Count the actual number of gammas read.  (Some may have been skipped,
        # if levels in the ags file were not found in memory, or if some had
        # non-positive yields.)
        actual_transitions_recorded = len(this_detector_yields)

        # Give the EXPERIMENTAL yields to the experiment object to store.
        self.allexperiments[internal_experiment_number].set_one_detector_experimental_yields(internal_detector_number,this_detector_yields)

        print actual_transitions_recorded," experimental yields read for experiment ",gosia_experiment_number,", detector ",gosia_detector_number,"."

        return 0

    def read_experimental_yields(self):
        """Reads the yields from gosia file 3 and stores them in an internal format.

        See what experiments and detectors are in memory by asking the
        experiment objects, then read the yield file (tape 3) accordingly.  

        """


        gosia_file_number = 3
        yield_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[3]["extension"]
        
        with open(yield_file_name,'r') as experimental_yield_file:
            yield_file_lines = experimental_yield_file.readlines()

        # Get the number of experiments to read.
        number_of_experiments = self.getnumberofexperiments()
        # Get a list of the number of detectors for each experiment.
        numbers_of_detectors = self.get_numbers_of_detectors()


        line_number = 0
        for experiment_number in range(number_of_experiments):
            for detector_number in range(numbers_of_detectors[experiment_number]):
                # A temporary list to store the yields for one data set
                this_detector_yields = []

                # Read the header for this data set (detector), and get the number of
                # yields for that data set.  Read all the lines, and set the line
                # number to the next header.  Repeat.
                header_line = yield_file_lines[line_number]
                header_line_fields = header_line.split()
                yields_in_this_detector = int(header_line_fields[5])
                for n in range(yields_in_this_detector):
                    line_number = line_number + 1
                    this_line_fields = yield_file_lines[line_number].split()
                    initial_gosia_level = int(this_line_fields[0])
                    final_gosia_level = int(this_line_fields[1])
                    initial_level_key = investigated_nucleus.get_band_and_spin_from_gosia_level_number(initial_gosia_level)
                    final_level_key   = investigated_nucleus.get_band_and_spin_from_gosia_level_number(final_gosia_level)
                    initial_band_name, initial_spin = initial_level_key
                    final_band_name, final_spin     = final_level_key
                    experimental_yield = float(this_line_fields[2])
                    experimental_error = float(this_line_fields[3])
                    this_yield_point = [initial_band_name, initial_spin, final_band_name, final_spin, experimental_yield, experimental_error]
                    # Append this yield point to the list for this detector
                    this_detector_yields.append(this_yield_point)
                # Step forward one line to the next header
                line_number = line_number + 1

                # Pass these EXPERIMENTAL yields for one experiment and one detector to the appropriate logical detector.
                
                self.allexperiments[experiment_number].set_one_detector_experimental_yields(detector_number,this_detector_yields)

        print "Experimental yield data read."
        return 0

    def test_yields(self,experiment_number,detector_number):
        return self.allexperiments[experiment_number].get_calculated_yields(detector_number)

    
    def plot_tf(self,initial_band,final_band,initial_spin=None,final_spin=None,ge_polar_angle=None,ge_azimuthal_angle=None):
        """Plots the results of the accuracy test "tf"

        """

        x_label = "theta_particle"
        y_label = "point yield, arb. scale"

        # Find the initial and final level keys
        initial_band_name = investigated_nucleus.get_primary_band_name_from_band_number(initial_band)
        final_band_name   = investigated_nucleus.get_primary_band_name_from_band_number(final_band)
        initial_level_key = (initial_band_name,initial_spin) 
        final_level_key   = (final_band_name,final_spin) 

        # Get scattering angles for each experiment.
        particle_angles = the_experiment_manager.get_all_mean_particle_angles()
        
        # Create the array to temporarily store calculated yield points for plotting.
        calculated_yield_vs_particle_angle = []

        calculated_data_to_plot = False
        lines_to_write = []

        plot_data_file_name = ".temp_plot_data"

        # Step through the stored calculated yield data to generate plot data
        for internal_experiment_number in range(self.getnumberofexperiments()):
            title_experiment_number = "Calc. Expt. "+str(internal_experiment_number+1)
            # Get the internal detector number that matches the polar and azimuthal angles
            # within one degree for this experiment.
            internal_ge_types,ge_theta_list,ge_phi_list = self.allexperiments[internal_experiment_number].get_all_detector_numbers_and_angles(False)
            for n in range(len(internal_ge_types)):
                this_ge_theta = ge_theta_list[n] 
                this_ge_phi   = ge_phi_list[n] 
                theta_matches = abs(ge_polar_angle - this_ge_theta)   <= 1.0   # theta matches within one degree
                phi_matches   = abs(ge_azimuthal_angle - this_ge_phi) <= 1.0   # phi matches within one degree
                if theta_matches and phi_matches:
                    detector_number_for_this_experiment = n
                    break  # out of this for loop

            this_particle_angle = particle_angles[internal_experiment_number]
            try:
                this_calculated_yield_set = self.allexperiments[internal_experiment_number].get_calculated_yields(detector_number_for_this_experiment)
                # Normalizing presents a problem for viewing the normalization transistion!
                #this_calculated_yield_set = self.allexperiments[internal_experiment_number].get_calculated_yields_with_requested_normalization(detector_number_for_this_experiment)
            except:
                print "The \"tf\" test failed.  Please report this bug."
                print "Quitting."
                return -1

            # Step through the calculated yield set to find the one we want
            for one_yield_entry in this_calculated_yield_set:
                this_initial_band_name, this_initial_spin, this_final_band_name, this_final_spin, this_yield = one_yield_entry
                this_initial_level_key = (this_initial_band_name, this_initial_spin)
                this_final_level_key   = (this_final_band_name, this_final_spin)
                if this_initial_level_key == initial_level_key and this_final_level_key == final_level_key:
                    calculated_data_to_plot = True
                    # This is the yield point we want.  Append it to the list
                    calculated_yield_vs_particle_angle.append([this_particle_angle,this_yield])
                    # Can break out of the loop now, since the initial/final levels are unique
                    break  # out of innermost for loop

        # Check that the correct calculated point yields were found.
        if (len(calculated_yield_vs_particle_angle) == 0):
            print "The \"tf\" test failed.  Please report this bug."
            print "Quitting."
            return -1

        # Add to the first plot data file
        lines_to_write = ["# initial I,band = "+str(initial_spin)+", "+str(initial_band)+"\n",\
                         "# final   I,band = "+str(final_spin)+", "+str(final_band)+"\n",\
                         "# Ge polar angle = "+str(ge_polar_angle)+"\n",\
                         "# Ge azimuthal angle = "+str(ge_azimuthal_angle)+"\n"]

        # Sort the calculated yield points, since they will be joined by lines.
        calculated_yield_vs_particle_angle.sort()

        # Generate the lines to send to gnuplot through the plot data file, and
        # save them to the file.
        for one_point in calculated_yield_vs_particle_angle:
            this_angle, this_yield = one_point
            this_text_line = str(this_angle) + "     " + str(this_yield) + "\n"
            lines_to_write.append(this_text_line)
        lines_to_write.append("\n\n")  # two blank lines to separate sets
        with open(plot_data_file_name,"w") as plot_data_file: 
            plot_data_file.writelines(lines_to_write)
        print "Data for this plot were written to the file \"" + plot_data_file_name + "\"."

        # Call a routine to launch gnuplot
        calculated_legend = ["calculated"]
        chi_squared_string = ""
        experimental_legend=None
        better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend,chi_squared_string)

        return 0

    def plot_yield_data_vs_scattering_angle(self,initial_band_name,final_band_name,initial_spin=None,final_spin=None,ge_polar_angle=None,ge_azimuthal_angle=None):
        """A separate plotting method for yield vs. particle angle data.

        This method is now more robust for skipped experiments (no requested
        detector in one or more experiments.

        """

        # Set x axis label
        x_label = "theta_particle"

        # Ask which transition.
        if initial_spin == None or final_spin == None:
            initial_spin = prompt_number("Initial spin: ","r")
            if initial_spin == "quit":
                return 0
            final_spin =   prompt_number("Final spin: ","r")
            if final_spin == "quit":
                return 0

        # Get the initial and final level keys.
        initial_level_key = (initial_band_name,initial_spin) 
        final_level_key   = (final_band_name,final_spin) 
        initial_level_object = investigated_nucleus.levels[initial_level_key]
        final_level_object = investigated_nucleus.levels[final_level_key]

        if ge_polar_angle == None or ge_azimuthal_angle == None:
            self.display_Ge_detectors_for_all_experiments()
            print "Detectors are selected by theta,phi angle, in case "
            print "  identical detectors were not given to all experiments"
            print "  in the same order.  (See table.)"
            print "Detector will be selected with +/- 1 degree tolerance."
            ge_polar_angle = prompt_number("Ge detector polar angle: ","f")
            if ge_polar_angle == "quit":
                return 0
            ge_azimuthal_angle = prompt_number("Ge detector azimuthal angle: ","f")
            if ge_azimuthal_angle == "quit":
                return 0

                    
        # Ask if the user wants to plot absolute yields or normalized yields.
        if yes_no_prompt("Plot absolute yields (calculated only) [y/N]? "):
            plot_absolute = True
            # Turn off plotting of experimental yields for now.  Need to do a little more
            # coding to take out the automatic normalization in the loops below.
            plot_experimental_yields = False
            y_label = "yield [mb(mg/cm^2)/sr]"
            print "Note: yields are absolute--not normalized!"
        else:
            plot_absolute = False
            plot_experimental_yields = True
            y_label = "yield"

        # Put all data in one file for gnuplot.  Otherwise, gnuplot colors get
        # confused.
        plot_data_file_name = "temp_rachel_plot_data.dat"

        # Header comments for the plot data file.
        lines_to_write = ["# initial I,band_name = "+str(initial_spin)+", "+str(initial_band_name)+"\n",\
                          "# final   I,band_name = "+str(final_spin)+", "+str(final_band_name)+"\n",\
                          "# Ge polar angle = "+str(ge_polar_angle)+"\n",\
                          "# Ge azimuthal angle = "+str(ge_azimuthal_angle)+"\n"]

        # Set initial chi-squared to zero for the entire plot (all sets considered in one chi-squared value).
        chi_squared_for_plot = 0.0
        chi_squared_points = 0      # for calculating reduced chi_squared
        chi_squared_string = ""     # Will remain as an empty string unless there are data to calculate chi-squared.

        # Create the dictionaries to store calculated and experimental yield
        # points for plotting.  The nested data dictionaries will have the form

        # calculated: {scattering_angle:[gosia_experiment_number,yield],next_scattering_angle:[gosia_experiment_number,yield],...}
        # experimental: {scattering_angle:[gosia_experiment_number,measured_yield,error],...}

        # An experiment with no data will be entered, but with an empty yield
        # vs. spin dictionary, and the legend entries will use the user's
        # experiment number, so that they match the user's setup.
        calculated_yield_vs_particle_angle   = {}
        experimental_yield_vs_particle_angle = {}

        # The calculated and experimental legends will be passed as a list of
        # strings to the plotting method.  Plotting methods are troublesome
        # because of set types (with/without errors) and skipping of sets.

        calculated_legend = ["Calc."]
        experimental_legend = ["Expt."]

        # Step through the stored calculated yield data to generate plot data
        for internal_experiment_number in range(self.getnumberofexperiments()):
            if plot_experimental_yields:
                # Get the normalization on the calculated yields that gives the best fit to experimental data.
                experimental_normalization_constant = self.get_overall_normalization_for_experimental_yields(internal_experiment_number)[1] 
                if experimental_normalization_constant == None:
                    print "No data in memory for experiment " + str(internal_experiment_number + 1) + "."
                    raw_input ("Press enter to continue.")

            # Get the internal detector number that matches the polar and azimuthal angles
            # within one degree for this experiment.
            gosia_experiment_number = internal_experiment_number + 1
            internal_ge_types,ge_theta_list,ge_phi_list = self.allexperiments[internal_experiment_number].get_all_detector_numbers_and_angles(False)
            ge_detector_found = False
            for n in range(len(internal_ge_types)):
                this_ge_theta = ge_theta_list[n] 
                this_ge_phi   = ge_phi_list[n] 
                theta_matches = abs(ge_polar_angle - this_ge_theta)   <= 1.0   # theta matches within one degree
                phi_matches   = abs(ge_azimuthal_angle - this_ge_phi) <= 1.0   # phi matches within one degree
                if theta_matches and phi_matches:
                    internal_detector_number_for_this_experiment = n
                    ge_detector_found = True
                    break  # out of this for loop

            if ge_detector_found:
                # Found the Ge detector for the user's requested theta_Ge, phi_Ge in this experiment.
                # Get the mean scattering angle for this experiment.
                this_particle_angle = self.allexperiments[internal_experiment_number].mean_scattering_angle()

                try:
                    # Get the calculated yields with the user's requested
                    # normalization, or without normalization if absolute yields were requested.
                    this_experiment = self.allexperiments[internal_experiment_number]
                    detector_object = this_experiment.Ge_detectors[internal_detector_number_for_this_experiment]
                    this_calculated_yield_set   = detector_object.return_calculated_yields()
                except:
                    print "No calculated yields for experiment ",internal_experiment_number + 1, " detector ",internal_detector_number_for_this_experiment + 1, ".  You may want to run the gosia calculations again, if this experiment should contain the requested detector."
                    break
                if plot_experimental_yields:
                    # Store experimental yields for this detector.
                    this_experiment = self.allexperiments[internal_experiment_number]
                    detector_object = this_experiment.Ge_detectors[internal_detector_number_for_this_experiment]
                    this_experimental_yield_set   = detector_object.return_experimental_yields()

                # Step through the calculated yield set to find the one we want
                for one_yield_entry in this_calculated_yield_set:
                    this_initial_band_name, this_initial_spin, this_final_band_name, this_final_spin, this_yield = one_yield_entry
                    this_initial_level_key = (this_initial_band_name, this_initial_spin)
                    this_final_level_key   = (this_final_band_name, this_final_spin)
                    this_initial_level_object = investigated_nucleus.levels[this_initial_level_key]
                    this_final_level_object   = investigated_nucleus.levels[this_final_level_key]
                    # This needs to match the level *objects*, since there are now an arbitrary number of pseudonyms.
                    if this_initial_level_object == initial_level_object and this_final_level_object == final_level_object:
                        # This is the yield point we want.  Append it to the list
                        # If the experimental data are to be plotted, renormalize the calculated yield to the experimental.
                        if plot_experimental_yields:
                            # Get the normalization on the calculated yields that gives the best fit to experimental data.
                            this_yield = this_yield * experimental_normalization_constant 

                        # If this particle angle is already in the dict, jog
                        # the point a little to make the plot nicer and to give
                        # a unique dict key.

                        while this_particle_angle in calculated_yield_vs_particle_angle.keys():
                            this_particle_angle += 0.1 # degrees jog
                        calculated_yield_vs_particle_angle[this_particle_angle] = [gosia_experiment_number,this_yield]
                        # Can break out of the loop now, since the initial/final levels are unique
                        break  # out of innermost for loop

                if plot_experimental_yields and not plot_absolute:
                    # Step through the experimental yield set to find the one we want
                    for one_yield_entry in this_experimental_yield_set:
                        this_initial_band_name, this_initial_spin, this_final_band_name, this_final_spin, this_experimental_normalized_yield, this_normalized_error = one_yield_entry
                        this_initial_level_key = (this_initial_band_name, this_initial_spin)
                        this_final_level_key   = (this_final_band_name, this_final_spin)
                        this_initial_level_object = investigated_nucleus.levels[this_initial_level_key]
                        this_final_level_object   = investigated_nucleus.levels[this_final_level_key]
                        # This needs to match the level *objects*, since there are now an arbitrary number of pseudonyms.
                        if this_initial_level_object == initial_level_object and this_final_level_object == final_level_object:
                            # This is the yield point we want.  Append it to the list
                            # If this particle angle is already in the dict, jog
                            # the point a little to make the plot nicer and to give
                            # a unique dict key.

                            while this_particle_angle in experimental_yield_vs_particle_angle.keys():
                                this_particle_angle += 0.1 # degrees jog
                            experimental_yield_vs_particle_angle[this_particle_angle] = [gosia_experiment_number,this_experimental_normalized_yield,this_normalized_error]
                            # Step through the calculated yield set to find the one we want to compare to, to get the chi-squared contribution.
                            corresponding_calculated_point = calculated_yield_vs_particle_angle[this_particle_angle]
                            calculated_particle_angle,calculated_yield = corresponding_calculated_point
                            # This is the correct calculated point for the chi-squared contribution for this point.
                            chi_squared_contribution = ((this_experimental_normalized_yield - this_yield) / this_normalized_error)**2
                            chi_squared_for_plot = chi_squared_for_plot + chi_squared_contribution
                            chi_squared_points = chi_squared_points + 1
                            #print "Expt. ",internal_experiment_number + 1," particle angle ",this_particle_angle," chi-squared contribution = ", chi_squared_contribution
                            # Can break out of the loop now, since the initial/final levels are unique
                            break  # out of innermost for loop

        if len(experimental_yield_vs_particle_angle) == 0 and not plot_absolute:
            print "No matching experimental data found."
        elif (len(calculated_yield_vs_particle_angle) == 0):
                print "No calculated yields to compare to.  Calculate the \"Integrated yields\" first."
                print "Quitting."
                return -1

        # Sort the calculated yield points, since they will be joined by lines.
        sorted_keys_for_calculated_yields = calculated_yield_vs_particle_angle.keys()
        sorted_keys_for_calculated_yields.sort()
        # Sort the experimental yield points, since they will be joined by lines.
        sorted_keys_for_experimental_yields = experimental_yield_vs_particle_angle.keys()
        sorted_keys_for_experimental_yields.sort()

        # Write out the calculated set.
        lines_to_write.append("# Calculated yield vs. scattering angle.\n")
        for this_angle in sorted_keys_for_calculated_yields:
            this_experiment_number, this_calculated_yield = calculated_yield_vs_particle_angle[this_angle]
            this_text_line = str(this_angle) + "     " + str(this_calculated_yield) + "\n"
            lines_to_write.append(this_text_line)
        lines_to_write.append("\n\n")  # two blank lines to separate sets

        # Now make the experimental yield part of the plot data file
        if plot_experimental_yields and not plot_absolute:
            lines_to_write.append("# Experimental yield vs. scattering angle.\n")
            # Now get the total reduced chi-squared.  (The number of degrees of
            # freedom is taken as simply the number of experimental data points
            # on the plot and does not include the number of fit parameters.
            try:
                reduced_chi_squared_for_plot = chi_squared_for_plot / float(chi_squared_points)
                # Generate a string to report the chi-squared and reduced chi-squared for the plot
                chi_squared_string = "\"For " + str(chi_squared_points) + " points, chi-squared = " + str(round(chi_squared_for_plot,1)) + "      red. chi-squared  = " + str(round(reduced_chi_squared_for_plot,1)) + "\""
            except:
                try:
                    chi_squared_string = "\"chi-squared = " + str(round(chi_squared_for_plot,1)) 
                except:
                    chi_squared_string = ""

            # Add the lines for the experimental data.
            for this_angle in sorted_keys_for_experimental_yields:
                this_experiment_number, this_yield, this_error = experimental_yield_vs_particle_angle[this_angle]
                this_text_line = str(this_angle) + "     " + str(this_yield) + "     " + str(this_error) + "\n"
                lines_to_write.append(this_text_line)
            # Write a final two line feeds for gnuplot
            lines_to_write.append("\n\n")

        with open(plot_data_file_name,"w") as plot_data_file: 
            plot_data_file.writelines(lines_to_write)
        print "Data for this plot were written to the file \"" + plot_data_file_name + "\"."


        # Print the data and chi-squared to the terminal.
        for one_line in lines_to_write:
            one_line = one_line.strip("\n")
            print one_line
        print chi_squared_string

        # Call a routine to launch gnuplot
        if plot_absolute:
            block_print_with_line_breaks("Plotting calculated yields.  The yields may not represent actual counts due to normalizations required by Gosia.")
            experimental_legend = None
            better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend)
        elif plot_experimental_yields:
            block_print_with_line_breaks("Plotting experimental and calculated yields.  The yields may not represent actual counts due to normalizations required by Gosia.")
            #print plot_data_file_name, "\n",experimental_plot_data_file_name
            better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend,chi_squared_string)
            #gnu_plot_launch(plot_data_file_name,chi_squared_string,x_label,y_label,experimental_plot_data_file_name)

        return 0

    def plot_yield_data_vs_spin(self,initial_band_name,final_band_name,initial_spin=None,final_spin=None,ge_polar_angle=None,ge_azimuthal_angle=None):
        """Separate plotting method for yield vs. spin in a selected detector.

        """

        # Set x axis label
        x_label = "spin"

        # Ask which transitions.
        delta_I = prompt_number("delta_I: ","r")
        if delta_I  == "quit":
            return 0
        print "delta_I taken as ",delta_I
        print ""

        # Ask which Ge detector.  Only one is allowed per plot.  All
        # experiments with a Ge detector at this theta, phi position will
        # contribute.
        self.display_Ge_detectors_for_all_experiments()
        print "Detector will be selected with +/- 1 degree tolerance. (See table.)"
        ge_polar_angle = prompt_number("Ge detector polar angle: ","f")
        if ge_polar_angle  == "quit":
            return 0
        ge_azimuthal_angle = prompt_number("Ge detector azimuthal angle: ","f")
        if ge_azimuthal_angle  == "quit":
            return 0
                    
        # Ask if the user wants to plot absolute yields or normalized yields.
        if yes_no_prompt("Plot absolute yields (calculated only) [y/N]? "):
            plot_absolute = True
            # Turn off plotting of experimental yields for now.  Need to do a little more
            # coding to take out the automatic normalization in the loops below.
            plot_experimental_yields = False
            y_label = "yield [mb(mg/cm^2)/sr]"
            print "Note: yields are absolute--not normalized!"
        else:
            plot_absolute = False
            plot_experimental_yields = True
            y_label = "yield"

        # Put all data in one file for gnuplot.  Otherwise, gnuplot colors get
        # confused.
        plot_data_file_name = "temp_rachel_plot_data.dat"

        # Header comments for the plot data file.
        lines_to_write = ["# initial   band_name = "+str(initial_band_name)+"\n",\
                          "# final     band_name = "+str(final_band_name)+"\n",\
                          "# delta_I        = "+str(delta_I)+"\n",\
                          "# Ge polar angle = "+str(ge_polar_angle)+"\n",\
                          "# Ge azimuthal angle = "+str(ge_azimuthal_angle)+"\n"]

        # Create the dictionaries to store calculated and experimental yield
        # points for plotting.  The nested data dictionaries will have the form

        # An experiment with no data will be entered, but with an empty yield
        # vs. spin dictionary, and the legend entries will use the user's
        # experiment number, so that they match the user's setup.
        calculated_yield_vs_spin   = {}
        experimental_yield_vs_spin = {}
        # Create the nested dictionaries:
        for internal_experiment_number in range(the_experiment_manager.getnumberofexperiments()):
            gosia_experiment_number = internal_experiment_number + 1
            calculated_yield_vs_spin[gosia_experiment_number] = {}    # The nested spin:yield dictionary for this experiment is added.
            experimental_yield_vs_spin[gosia_experiment_number] = {}  # The nested spin:yield dictionary for this experiment is added.

        # The calculated and experimental legends will be passed as a list of
        # strings to the plotting method.  Maybe the plotting method should be
        # put in here, to avoid the complication of trying to re-use code.
        # Plotting methods are troublesome because of set types (with/without
        # errors) and skipping of sets.
        calculated_legend = []
        experimental_legend = []


        # Now go through the experiments and pick out data for this detector and the requested bands, Delta-I.
        for internal_experiment_number in range(the_experiment_manager.getnumberofexperiments()):
            if plot_experimental_yields:
                # Get the normalization on the calculated yields that gives the best fit to experimental data.
                experimental_normalization_constant = self.get_overall_normalization_for_experimental_yields(internal_experiment_number)[1] 
            gosia_experiment_number = internal_experiment_number + 1
            # See if this experiment has the requested Ge detector.
            internal_detector_number_for_this_experiment = self.allexperiments[internal_experiment_number].get_first_detector_number_at_position(ge_polar_angle,ge_azimuthal_angle)
            # If this detector is found in this experiment, look for the
          # requested yield data and add it to the plot dictionaries.
            # Otherwise, the loop will iterate to the next experiment.

            if not internal_detector_number_for_this_experiment == -1:
                # This detector is in the experiment.
                # Try to get calculated yields.
                try:
                    # Get the calculated yields with the user's requested
                    # normalization, or without normalization if absolute yields were requested.
                    this_experiment = self.allexperiments[internal_experiment_number]
                    detector_object = this_experiment.Ge_detectors[internal_detector_number_for_this_experiment]
                    this_calculated_yield_set   = detector_object.return_calculated_yields()
                except:
                    print "No calculated yields for experiment ",internal_experiment_number + 1, " detector ",internal_detector_number_for_this_experiment + 1, ".  You should run the gosia calculations again."
                    this_calculated_yield_set = []
                if plot_experimental_yields:
                    try:
                        this_experiment = self.allexperiments[internal_experiment_number]
                        detector_object = this_experiment.Ge_detectors[internal_detector_number_for_this_experiment]
                        this_experimental_yield_set   = detector_object.return_experimental_yields()
                    except:
                        this_experimental_yield_set = []

                # Step through the calculated yield set to find the ones we want
                # For now, we exit with an error message if there are no calculated yields to plot:
                if not (this_calculated_yield_set == -1) and not (len(this_calculated_yield_set) == 0):
                    for one_yield_entry in this_calculated_yield_set:
                        # Because of pseudonyms, we need to match level objects, not keys.
                        this_initial_band_name, this_initial_spin, this_final_band_name, this_final_spin, this_yield = one_yield_entry
                        this_initial_level_key = (this_initial_band_name,this_initial_spin)
                        this_final_level_key   = (this_final_band_name,this_final_spin)
                        desired_initial_level_key = (initial_band_name,this_initial_spin)
                        desired_final_level_key = (final_band_name,this_initial_spin + delta_I)
                        a_level_does_not_exist = False
                        try:
                            this_initial_level_object = investigated_nucleus.levels[this_initial_level_key]
                            this_final_level_object   = investigated_nucleus.levels[this_final_level_key]
                            desired_initial_level_object = investigated_nucleus.levels[desired_initial_level_key]
                            desired_final_level_object   = investigated_nucleus.levels[desired_final_level_key]
                        except:
                            a_level_does_not_exist = True
                        this_delta_I = round(this_final_spin - this_initial_spin ,1)
                        # See if this data point matches the ones we are looking for.  There are an arbitrary number of pseudonyms, so we need to match them all by comparing object pointers.
                        if not a_level_does_not_exist and this_initial_level_object == desired_initial_level_object and this_final_level_object == desired_final_level_object:
                            # This is one yield point we want.
                            #print "raw calc", this_initial_spin,this_yield
                            if plot_experimental_yields:
                                # Get the normalization on the calculated yields that gives the best fit to experimental data.
                                this_yield = this_yield * experimental_normalization_constant 
                                #print "renorm calc", this_initial_spin,this_yield
                            calculated_yield_vs_spin[gosia_experiment_number][this_initial_spin] = this_yield

                    if plot_experimental_yields and not plot_absolute:
                        # Step through the experimental yield set to find the one we want
                        try:
                            for one_yield_entry in this_experimental_yield_set:
                                this_initial_band_name, this_initial_spin, this_final_band_name, this_final_spin, this_normalized_yield, this_normalized_error = one_yield_entry
                                this_initial_level_key = (this_initial_band_name,this_initial_spin)
                                this_final_level_key   = (this_final_band_name,this_final_spin)
                                desired_initial_level_key = (initial_band_name,this_initial_spin)
                                desired_final_level_key = (final_band_name,this_initial_spin + delta_I)
                                a_level_does_not_exist = False
                                try:
                                    this_initial_level_object = investigated_nucleus.levels[this_initial_level_key]
                                    this_final_level_object   = investigated_nucleus.levels[this_final_level_key]
                                    desired_initial_level_object = investigated_nucleus.levels[desired_initial_level_key]
                                    desired_final_level_object   = investigated_nucleus.levels[desired_final_level_key]
                                except:
                                    a_level_does_not_exist = True
                                this_delta_I = round(this_final_spin - this_initial_spin,1)
                                if not a_level_does_not_exist and this_initial_level_object == desired_initial_level_object and this_final_level_object == desired_final_level_object:
                                    # This is the yield point we want.  Append it to the list.
                                    # Experimental data are always plotted normalized as the user requested.
                                    experimental_yield_vs_spin[gosia_experiment_number][this_initial_spin] = [this_normalized_yield,this_normalized_error]
                                    #print "expt", this_initial_spin,this_normalized_yield
                        except:
                            block_print_with_line_breaks("Error in plotting experimental yields.  Please report this, if you think it is a bug.")
                            return -1

        # Now we have all of the calculated and possibly experimental yield
        # data in the *_yield_vs_spin dictionaries.  Cycle through and generate
        # the lines for gnuplot.

        # Add the data sets to the file
        chi_squared_points = 0
        chi_squared_for_plot = 0.0
        for internal_experiment_number in range(the_experiment_manager.getnumberofexperiments()):
            temporary_lines_to_write = []
            gosia_experiment_number = internal_experiment_number + 1
            # See if we have calculated data for this experiment.
            this_set_calculated_yield_vs_spin = calculated_yield_vs_spin[gosia_experiment_number]
            title_experiment_number = "Calc. Expt. "+str(gosia_experiment_number)
            # Put the legend info in comments in the data file as well
            title_comment = "#"+title_experiment_number+"\n"
            lines_to_write.append(title_comment)
            calculated_legend.append(title_experiment_number)
            if not len(this_set_calculated_yield_vs_spin) == 0:
                # There are calculated yields.  Append to a temporary list to sort the calculated data.
                these_keys = this_set_calculated_yield_vs_spin.keys()
                these_keys.sort()
                for one_spin in these_keys:
                    this_yield = this_set_calculated_yield_vs_spin[one_spin]
                    this_text_line = str(one_spin) + "     " + str(this_yield) + "\n"
                    temporary_lines_to_write.append(this_text_line)
                # Sort the lines by spin.  This sorts strings, and first
                # characters are the positive float spins, so the sort() method
                # effectively sorts by spin.
                # This method does not work, because it results in ...10,12,14...2,20,22...
                #temporary_lines_to_write.sort()
                lines_to_write.extend(temporary_lines_to_write)
            else:
                # No calculated yields for this set.  Put in a spurious point at spin=-1.
                this_text_line = "-1.  ?  \n"   # Proper way to skip sets in gnuplot
                lines_to_write.append(this_text_line)
            lines_to_write.append("\n\n")  # two blank lines to separate sets

            # Now add the experimental data.
            # This is being modified to skip empty sets to avoid errors in gnuplot.  August 7, 2010.
            if plot_experimental_yields and not plot_absolute:
                title_experiment_number = "Meas. Expt. "+str(gosia_experiment_number)
                # Put the legend info in comments in the data file as well
                title_comment = "#"+title_experiment_number+"\n"
                lines_to_write.append(title_comment)
                experimental_legend.append(title_experiment_number)
                # See if there are any yields in this set.
                this_set_experimental_yield_vs_spin = experimental_yield_vs_spin[gosia_experiment_number]
                if not len(this_set_experimental_yield_vs_spin) == 0:
                    for this_spin in this_set_experimental_yield_vs_spin.keys():
                        this_yield, this_error = this_set_experimental_yield_vs_spin[this_spin]
                        this_text_line = str(this_spin) + "     " + str(this_yield) + "     " + str(this_error) + "\n"
                        lines_to_write.append(this_text_line)
                        # Step through the calculated yield set to find the one we want to compare to, to get the chi-squared contribution.
                        # These spins are rounded numbers, so they can be compared exactly.
                        try:
                            calculated_yield_for_chi_squared = this_set_calculated_yield_vs_spin[this_spin]
                            chi_squared_contribution = ((this_yield - calculated_yield_for_chi_squared) / this_error)**2
                            #print "Expt. # ",gosia_experiment_number," spin ",this_spin,"calc: ",calculated_yield_for_chi_squared, " expt: ",this_yield," err: ",this_error," chi-squared contribution = ", chi_squared_contribution
                            chi_squared_for_plot = chi_squared_for_plot + chi_squared_contribution
                            chi_squared_points = chi_squared_points + 1
                        except:
                            # Can't get calculated yields for this point.
                            pass
                    lines_to_write.append("\n\n")  # two blank lines to separate sets
                    # Write all plot data to one file, otherwise gnuplot colors become confused.  (bug in gnuplot?)
                else:
                    # Need to figure out how to handle colors when skipping sets, so that calc. and expt. get same color.
                    # Put the legend info in comments in the data file as well
                    this_text_line = "-1. ?  ?  \n"   # Proper way to skip sets in gnuplot
                    lines_to_write.append(this_text_line)
                lines_to_write.append("\n\n")  # two blank lines to separate sets

        with open(plot_data_file_name,"w") as plot_data_file: 
            plot_data_file.writelines(lines_to_write)
        print "Data for this plot were written to the file \"" + plot_data_file_name + "\"."

        # Now get the total reduced chi-squared.  (The number of
        # degrees of freedom is taken as simply the number of
        # experimental data points on the plot and does not include the
        # number of fit parameters.  In cases where there are no
        # experimental data points for this plot data set, the reduced
        # chi-squared would result in a divide-by-zero exception.  In
        # that case, we won't calculate the reduced chi-squared.
        if plot_absolute:
            chi_squared_string = ""
        else:
            try:
                reduced_chi_squared_for_plot = chi_squared_for_plot / float(chi_squared_points)
                # Generate a string to report the chi-squared and reduced chi-squared for the plot
                chi_squared_string = "\"For " + str(chi_squared_points) + " points, chi-squared = " + str(round(chi_squared_for_plot,1)) + "      red. chi-squared  = " + str(round(reduced_chi_squared_for_plot,1)) + "\""
            except:
                try:
                    chi_squared_string = "\"chi-squared = " + str(round(chi_squared_for_plot,1)) 
                except:
                    chi_squared_string = ""
            
        # Print the plot data and chi-squared to the terminal.
        for one_line in lines_to_write:
            one_line = one_line.strip("\n")
            print one_line
        print chi_squared_string

        # Call a routine to launch gnuplot
        if plot_absolute:
            experimental_legend=None
            better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend)
        elif plot_experimental_yields:
            block_print_with_line_breaks("Plotting experimental and calculated yields.  The yields may not represent actual counts due to normalizations required by Gosia.")
            #print plot_data_file_name, "\n",experimental_plot_data_file_name
            better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend,chi_squared_string)
            #gnu_plot_launch(plot_data_file_name,chi_squared_string,x_label,y_label,experimental_plot_data_file_name)
        else:
            block_print_with_line_breaks("Plotting calculated yields.  The yields may not represent actual counts due to normalizations required by Gosia.")
            experimental_legend=None
            better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend)

        return 0

    def plot_yield_data_vs_polar_Ge_angle(self,initial_band_name,final_band_name,initial_spin=None,final_spin=None,ge_polar_angle=None,ge_azimuthal_angle=None):
        """Separate plot method for yield vs. Ge polar angle.

        This is finished.

        """

        # Set the x axis label for the plot.
        x_label = "theta_Ge"

        # Ask which transition.
        if initial_spin == None or final_spin == None:
            initial_spin = prompt_number("Initial spin: ","r")
            if initial_spin == "quit":
                return 0
            final_spin =   prompt_number("Final spin: ","r")
            if final_spin == "quit":
                return 0

        # Get the initial and final level keys.
        initial_level_key = (initial_band_name,initial_spin) 
        final_level_key   = (final_band_name,final_spin) 
        initial_level_object = investigated_nucleus.levels[initial_level_key]
        final_level_object = investigated_nucleus.levels[final_level_key]

        self.display_Ge_detectors_for_all_experiments()
        block_print_with_line_breaks("Detectors are selected by phi angle, in case identical detectors were not given to all experiments in the same order.  (See table.)",70)
        azimuthal_angle_tolerance = prompt_number("Tolerance for selecting azimuthal angle: ","f")
        if azimuthal_angle_tolerance  == "quit":
            return 0
        print "Ge detectors will be selected by azimuthal angle with +/-",azimuthal_angle_tolerance," degree tolerance."
        ge_azimuthal_angle = prompt_number("Ge detector azimuthal angle: ","f")
        if ge_azimuthal_angle  == "quit":
            return 0

        # Ask if the user wants to plot absolute yields or normalized yields.
        if yes_no_prompt("Plot absolute yields (calculated only) [y/N]? "):
            plot_absolute = True
            # Turn off plotting of experimental yields for now.  Need to do a little more
            # coding to take out the automatic normalization in the loops below.
            plot_experimental_yields = False
            y_label = "yield [mb(mg/cm^2)/sr]"
            print "Note: yields are absolute--not normalized!"
        else:
            plot_absolute = False
            plot_experimental_yields = True
            y_label = "yield"

        # Put all data in one file for gnuplot.  Otherwise, gnuplot colors get
        # confused.
        plot_data_file_name = "temp_rachel_plot_data.dat"

        # Header comments for the plot data file.
        lines_to_write = ["# initial   band_name = "+str(initial_band_name)+"\n",\
                          "# final     band_name = "+str(final_band_name)+"\n",\
                          "# initial   spin = "+str(initial_spin)+"\n",\
                          "# final     spin = "+str(final_spin)+"\n",\
                          "# Ge azimuthal angle = "+str(ge_azimuthal_angle)+"\n"]

        # Create the dictionaries to store calculated and experimental yield
        # points for plotting.  The nested data dictionaries will have the form

        # calculated: {polar_Ge_angle:yield, next_polar_Ge_angle:yield,...}
        # experimental: {polar_Ge_angle:[measured_yield,error],...}

        # An experiment with no data will be entered, but with an empty yield
        # vs. angle dictionary, and the legend entries will use the user's
        # experiment number, so that they match the user's setup.
        calculated_yield_vs_phi_Ge   = {}
        experimental_yield_vs_phi_Ge = {}
        # Create the nested dictionaries:
        for internal_experiment_number in range(the_experiment_manager.getnumberofexperiments()):
            gosia_experiment_number = internal_experiment_number + 1
            calculated_yield_vs_phi_Ge[gosia_experiment_number] = {}    # The nested phi_Ge:yield dictionary for this experiment is added.
            experimental_yield_vs_phi_Ge[gosia_experiment_number] = {}  # The nested phi_Ge:yield dictionary for this experiment is added.

        # Zero the legend strings
        calculated_legend = []
        experimental_legend = []

        chi_squared_sum = 0.
        chi_squared_points = 0

        # Step through all experiments and add the yield vs. polar Ge angle for
        # the requested transition.
        number_of_experiments = self.getnumberofexperiments()
        for internal_experiment_number in range(number_of_experiments):
            if plot_experimental_yields:
                # Get the normalization on the calculated yields that gives the best fit to experimental data.
                experimental_normalization_constant = self.get_overall_normalization_for_experimental_yields(internal_experiment_number)[1] # Not utilizing the list of experiments with common normalization yet.
            gosia_experiment_number = internal_experiment_number + 1
            this_experiment = self.allexperiments[internal_experiment_number]
            # list for this experiment:
            for detector_number in range(this_experiment.get_number_of_detectors()):
                # Get the theta, phi coordinates of the detector and the calculated and experimental yields (normalized).
                theta = this_experiment.get_detector_information(detector_number,"theta")
                phi   = this_experiment.get_detector_information(detector_number,"phi")
                experimental_yield_found = False  # Used to decide if there should be a chi-squared contribution
                calculated_yield_found   = False  # Both must be true to add to chi-squared
                # Only continue if this detector is at the azimuth we want.
                if abs(ge_azimuthal_angle - phi) < azimuthal_angle_tolerance:
                    # Get the set of yields and look for the desired transition.
                    try:
                        # Get the calculated yields with the user's requested
                        # normalization, or without normalization if absolute yields were requested.
                        this_experiment = self.allexperiments[internal_experiment_number]
                        detector_object = this_experiment.Ge_detectors[detector_number]
                        this_calculated_yield_set   = detector_object.return_calculated_yields()
                    except:
                        print "No calculated yields for experiment ",internal_experiment_number + 1, " detector ", detector_number + 1, ".  You may want to run the gosia calculations again, if this experiment should contain the requested detector."
                        break
                    if plot_experimental_yields:
                        # Store experimental yields for this detector.
                        this_experiment = self.allexperiments[internal_experiment_number]
                        detector_object = this_experiment.Ge_detectors[detector_number]
                        this_experimental_yield_set   = detector_object.return_experimental_yields()
                    for yield_number in range(len(this_calculated_yield_set)):
                        this_yield_entry = this_calculated_yield_set[yield_number]
                        this_initial_band_name, this_initial_spin, this_final_band_name, this_final_spin, calculated_yield = this_yield_entry
                        this_initial_level_key = (this_initial_band_name, this_initial_spin)
                        this_final_level_key   = (this_final_band_name, this_final_spin)
                        this_initial_level_object = investigated_nucleus.levels[this_initial_level_key]
                        this_final_level_object   = investigated_nucleus.levels[this_final_level_key]
                        # This needs to match the level *objects*, since there are now an arbitrary number of pseudonyms.
                        if this_initial_level_object == initial_level_object and this_final_level_object == final_level_object:
                            # Save the calculated yield data and exit the innermost for loop.
                            if plot_experimental_yields:
                                # Get the normalization on the calculated yields that gives the best fit to experimental data.
                                calculated_yield = calculated_yield * experimental_normalization_constant 

                            # If this angle is already in the dict, jog
                            # the point a little to make the plot nicer and to give
                            # a unique dict key.
                            while theta in calculated_yield_vs_phi_Ge[gosia_experiment_number].keys():
                                theta += 0.1 # degrees jog
                            calculated_yield_vs_phi_Ge[gosia_experiment_number][theta] = calculated_yield
                            calculated_yield_found   = True
                            break

                    if not plot_absolute:
                        # Get also the experimental yield.
                        for yield_number in range(len(this_experimental_yield_set)):
                            this_experimental_yield_entry = this_experimental_yield_set[yield_number]
                            this_initial_band_name, this_initial_spin, this_final_band_name, this_final_spin, renormalized_experimental_yield, renormalized_yield_error = this_experimental_yield_entry
                            this_initial_level_key = (this_initial_band_name, this_initial_spin)
                            this_final_level_key   = (this_final_band_name, this_final_spin)
                            this_initial_level_object = investigated_nucleus.levels[this_initial_level_key]
                            this_final_level_object   = investigated_nucleus.levels[this_final_level_key]
                            # This needs to match the level *objects*, since there are now an arbitrary number of pseudonyms.
                            if this_initial_level_object == initial_level_object and this_final_level_object == final_level_object:
                                # Save the calculated yield data and exit the innermost for loop
                                # If this angle is already in the dict, jog
                                # the point a little to make the plot nicer and to give
                                # a unique dict key.
                                while theta in experimental_yield_vs_phi_Ge[gosia_experiment_number].keys():
                                    theta += 0.1 # degrees jog
                                experimental_yield_vs_phi_Ge[gosia_experiment_number][theta] = [renormalized_experimental_yield,renormalized_yield_error]
                                experimental_yield_found = True
                                break
                    # If both calculated and experimental yields were found, add to chi-squared:
                    if experimental_yield_found and calculated_yield_found:  # will be false for plot_absolute = True
                        chi_squared_contribution = (renormalized_experimental_yield - calculated_yield)**2 / (renormalized_yield_error)**2
                        chi_squared_sum         += chi_squared_contribution
                        chi_squared_points      += 1

        # Step through the stored calculated and experimental yield data to generate plot data.
        for internal_experiment_number in range(number_of_experiments):
            gosia_experiment_number = internal_experiment_number + 1
            this_experiment_calculated_yields = calculated_yield_vs_phi_Ge[gosia_experiment_number]
            calculated_legend_entry = "Calc. Expt. "+str(gosia_experiment_number)
            calculated_legend.append(calculated_legend_entry)
            # Add the calculated data lines
            if not len(this_experiment_calculated_yields) == 0:
                # There are calculated yields.
                this_experiment_calculated_yields_theta_keys = this_experiment_calculated_yields.keys()
                this_experiment_calculated_yields_theta_keys.sort()
                for one_theta in this_experiment_calculated_yields_theta_keys:
                    this_yield = this_experiment_calculated_yields[one_theta]
                    this_text_line = str(one_theta) + "     " + str(this_yield) + "\n"
                    lines_to_write.append(this_text_line)
            else:
                # No calculated yields for this set.  Put in a spurious point at spin=-1.
                this_text_line = "-1.  ?  \n"   # Proper way to skip sets in gnuplot
                lines_to_write.append(this_text_line)
            lines_to_write.append("\n\n")  # two blank lines to separate sets

            if not plot_absolute:
                # Add the experimental data
                this_experiment_experimental_yields = experimental_yield_vs_phi_Ge[gosia_experiment_number]
                experimental_legend_entry = "Meas. Expt. "+str(gosia_experiment_number)
                experimental_legend.append(experimental_legend_entry)
                # Add the experimental data lines
                if not len(this_experiment_experimental_yields) == 0:
                    # There are experimental yields.
                    this_experiment_experimental_yields_theta_keys = this_experiment_experimental_yields.keys()
                    this_experiment_experimental_yields_theta_keys.sort()
                    for one_theta in this_experiment_experimental_yields_theta_keys:
                        this_yield_entry = this_experiment_experimental_yields[one_theta]
                        this_normalized_yield, this_normalized_error = this_yield_entry
                        this_text_line = str(one_theta) + "     " + str(this_normalized_yield) + "    " + str(this_normalized_error) + "\n"
                        lines_to_write.append(this_text_line)
                else:
                    # No experimental yields for this set.  Put in a spurious point at spin=-1.
                    this_text_line = "-1.  ?   ?  \n"   # Proper way to skip sets in gnuplot
                    lines_to_write.append(this_text_line)

                lines_to_write.append("\n\n")  # two blank lines to separate sets

        
        with open(plot_data_file_name,"w") as plot_data_file: 
            plot_data_file.writelines(lines_to_write)
        print "Data for this plot were written to the file \"" + plot_data_file_name + "\"."

        if not plot_absolute:
            # Now get the total reduced chi-squared.  (The number of
            # degrees of freedom is taken as simply the number of
            # experimental data points on the plot and does not include the
            # number of fit parameters.  In cases where there are no
            # experimental data points for this plot data set, the reduced
            # chi-squared would result in a divide-by-zero exception.  In
            # that case, we won't calculate the reduced chi-squared.
            if plot_absolute:
                chi_squared_string = ""
            else:
                try:
                    reduced_chi_squared_for_plot = chi_squared_sum / chi_squared_points 
                    # Generate a string to report the chi-squared and reduced chi-squared for the plot
                    chi_squared_string = "\"For " + str(chi_squared_points) + " points, chi-squared = " + str(round(chi_squared_sum,1)) + "      red. chi-squared  = " + str(round(reduced_chi_squared_for_plot,1)) + "\""
                except:
                    chi_squared_string = "Could not calculate chi-squared. Please report this bug."
                    
        # Write the plot data to the terminal.
        for one_line in lines_to_write:
            one_line = one_line.strip("\n")
            print one_line
        try:
            print chi_squared_string
        except:
            pass

        # Call a routine to launch gnuplot
        if plot_absolute:
            experimental_legend=None
            better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend)
        elif plot_experimental_yields:
            block_print_with_line_breaks("Plotting experimental and calculated yields.  The yields may not represent actual counts due to normalizations required by Gosia.")
            better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend,chi_squared_string)


        return 0

    def plot_yield_data_vs_azimuthal_Ge_angle(self,initial_band_name,final_band_name,initial_spin=None,final_spin=None,ge_azimuthal_angle=None,ge_polar_angle=None):
        """Separate plot method for yield vs. Ge azimuthal angle.

        """

        # Set the x axis label for the plot.
        x_label = "phi_Ge"

        # Ask which transition.
        if initial_spin == None or final_spin == None:
            initial_spin = prompt_number("Initial spin: ","r")
            if initial_spin == "quit":
                return 0
            final_spin =   prompt_number("Final spin: ","r")
            if final_spin == "quit":
                return 0

        # Get the initial and final level keys.
        initial_level_key = (initial_band_name,initial_spin) 
        final_level_key   = (final_band_name,final_spin) 
        initial_level_object = investigated_nucleus.levels[initial_level_key]
        final_level_object = investigated_nucleus.levels[final_level_key]

        self.display_Ge_detectors_for_all_experiments()
        block_print_with_line_breaks("Detectors are selected by polar (theta) angle, in case identical detectors were not given to all experiments in the same order.  (See table.)",70)
        polar_angle_tolerance = prompt_number("Tolerance for selecting polar angle: ","f")
        if polar_angle_tolerance  == "quit":
            return 0
        print "Ge detectors will be selected by polar angle with +/-",polar_angle_tolerance," degree tolerance."
        ge_polar_angle = prompt_number("Ge detector polar angle: ","f")
        if ge_polar_angle  == "quit":
            return 0

        # Ask if the user wants to plot absolute yields or normalized yields.
        if yes_no_prompt("Plot absolute yields (calculated only) [y/N]? "):
            plot_absolute = True
            # Turn off plotting of experimental yields for now.  Need to do a little more
            # coding to take out the automatic normalization in the loops below.
            plot_experimental_yields = False
            y_label = "yield [mb(mg/cm^2)/sr]"
            print "Note: yields are absolute--not normalized!"
        else:
            plot_absolute = False
            plot_experimental_yields = True
            y_label = "yield"

        # Put all data in one file for gnuplot.  Otherwise, gnuplot colors get
        # confused.
        plot_data_file_name = "temp_rachel_plot_data.dat"

        # Header comments for the plot data file.
        lines_to_write = ["# initial   band_name = "+str(initial_band_name)+"\n",\
                          "# final     band_name = "+str(final_band_name)+"\n",\
                          "# initial   spin = "+str(initial_spin)+"\n",\
                          "# final     spin = "+str(final_spin)+"\n",\
                          "# Ge polar angle = "+str(ge_polar_angle)+"\n"]

        # Create the dictionaries to store calculated and experimental yield
        # points for plotting.  The nested data dictionaries will have the form

        # calculated: {azimuthal_Ge_angle:yield, next_azimuthal_Ge_angle:yield,...}
        # experimental: {azimuthal_Ge_angle:[measured_yield,error],...}

        # An experiment with no data will be entered, but with an empty yield
        # vs. angle dictionary, and the legend entries will use the user's
        # experiment number, so that they match the user's setup.
        calculated_yield_vs_phi_Ge   = {}
        experimental_yield_vs_phi_Ge = {}
        # Create the nested dictionaries:
        for internal_experiment_number in range(the_experiment_manager.getnumberofexperiments()):
            gosia_experiment_number = internal_experiment_number + 1
            calculated_yield_vs_phi_Ge[gosia_experiment_number]   = {}    # The nested phi_Ge:yield dictionary for this experiment is added.
            experimental_yield_vs_phi_Ge[gosia_experiment_number] = {}  # The nested phi_Ge:yield dictionary for this experiment is added.

        # Zero the legend strings
        calculated_legend = []
        experimental_legend = []

        chi_squared_sum = 0.
        chi_squared_points = 0

        # Step through all experiments and add the yield vs. azimuthal Ge angle for
        # the requested transition.
        number_of_experiments = self.getnumberofexperiments()
        for internal_experiment_number in range(number_of_experiments):
            gosia_experiment_number = internal_experiment_number + 1
            this_experiment = self.allexperiments[internal_experiment_number]
            if plot_experimental_yields:
                # Get the normalization on the calculated yields that gives the best fit to experimental data.
                experimental_normalization_constant = self.get_overall_normalization_for_experimental_yields(internal_experiment_number)[1] # Not utilizing the list of experiments with common normalization yet.
            # list for this experiment:
            for detector_number in range(this_experiment.get_number_of_detectors()):
                # Get the theta, phi coordinates of the detector and the calculated and experimental yields (normalized).
                theta = this_experiment.get_detector_information(detector_number,"theta")
                phi   = this_experiment.get_detector_information(detector_number,"phi")
                experimental_yield_found = False  # Used to decide if there should be a chi-squared contribution
                calculated_yield_found   = False  # Both must be true to add to chi-squared
                # Only continue if this detector is at the azimuth we want.
                if abs(ge_polar_angle - theta) < polar_angle_tolerance:
                    # Get the set of yields and look for the desired transition.
                    try:
                        # Get the calculated yields with the user's requested
                        # normalization, or without normalization if absolute yields were requested.
                        this_experiment = self.allexperiments[internal_experiment_number]
                        detector_object = this_experiment.Ge_detectors[detector_number]
                        this_calculated_yield_set   = detector_object.return_calculated_yields()
                    except:
                        print "No calculated yields for experiment ",internal_experiment_number + 1, " detector ", detector_number + 1, ".  You may want to run the gosia calculations again, if this experiment should contain the requested detector."
                        break
                    if plot_experimental_yields:
                        # Store experimental yields for this detector.
                        this_experiment = self.allexperiments[internal_experiment_number]
                        detector_object = this_experiment.Ge_detectors[detector_number]
                        this_experimental_yield_set   = detector_object.return_experimental_yields()
                    for yield_number in range(len(this_calculated_yield_set)):
                        this_yield_entry = this_calculated_yield_set[yield_number]
                        this_initial_band_name, this_initial_spin, this_final_band_name, this_final_spin, calculated_yield = this_yield_entry
                        this_initial_level_key = (this_initial_band_name, this_initial_spin)
                        this_final_level_key   = (this_final_band_name, this_final_spin)
                        this_initial_level_object = investigated_nucleus.levels[this_initial_level_key]
                        this_final_level_object   = investigated_nucleus.levels[this_final_level_key]
                        # This needs to match the level *objects*, since there are now an arbitrary number of pseudonyms.
                        if this_initial_level_object == initial_level_object and this_final_level_object == final_level_object:
                            # Save the calculated yield data and exit the innermost for loop
                            # If this angle is already in the dict, jog
                            # the point a little to make the plot nicer and to give
                            # a unique dict key.
                            while phi in calculated_yield_vs_phi_Ge[gosia_experiment_number].keys():
                                phi += 0.1 # degrees jog
                            # Add this point.
                            if plot_experimental_yields:
                                # Get the normalization on the calculated yields that gives the best fit to experimental data.
                                calculated_yield = calculated_yield * experimental_normalization_constant 
                            calculated_yield_vs_phi_Ge[gosia_experiment_number][phi] = calculated_yield
                            calculated_yield_found   = True
                            break

                    if not plot_absolute:
                        # Get also the experimental yield.
                        for yield_number in range(len(this_experimental_yield_set)):
                    # If both calculated and experimental yields were found, add to chi-squared:
                            this_experimental_yield_entry = this_experimental_yield_set[yield_number]
                            this_initial_band_name, this_initial_spin, this_final_band_name, this_final_spin, renormalized_experimental_yield, renormalized_yield_error = this_experimental_yield_entry
                            this_initial_level_key = (this_initial_band_name, this_initial_spin)
                            this_final_level_key   = (this_final_band_name, this_final_spin)
                            this_initial_level_object = investigated_nucleus.levels[this_initial_level_key]
                            this_final_level_object   = investigated_nucleus.levels[this_final_level_key]
                            # This needs to match the level *objects*, since there are now an arbitrary number of pseudonyms.
                            if this_initial_level_object == initial_level_object and this_final_level_object == final_level_object:
                                # Save the calculated yield data and exit the innermost for loop
                                while phi in experimental_yield_vs_phi_Ge[gosia_experiment_number].keys():
                                    phi += 0.1 # degrees jog
                                experimental_yield_vs_phi_Ge[gosia_experiment_number][phi] = [renormalized_experimental_yield,renormalized_yield_error]
                                experimental_yield_found = True
                                break
                    if experimental_yield_found and calculated_yield_found:  # will be false for plot_absolute = True
                        chi_squared_contribution = (renormalized_experimental_yield - calculated_yield)**2 / (renormalized_yield_error)**2
                        chi_squared_sum         += chi_squared_contribution
                        chi_squared_points      += 1

        # Step through the stored calculated and experimental yield data to generate plot data.
        for internal_experiment_number in range(number_of_experiments):
            gosia_experiment_number = internal_experiment_number + 1
            this_experiment_calculated_yields = calculated_yield_vs_phi_Ge[gosia_experiment_number]
            calculated_legend_entry = "Calc. Expt. "+str(gosia_experiment_number)
            calculated_legend.append(calculated_legend_entry)
            # Add the calculated data lines
            if not len(this_experiment_calculated_yields) == 0:
                # There are calculated yields.
                this_experiment_calculated_yields_theta_keys = this_experiment_calculated_yields.keys()
                this_experiment_calculated_yields_theta_keys.sort()
                for one_theta in this_experiment_calculated_yields_theta_keys:
                    this_yield = this_experiment_calculated_yields[one_theta]
                    this_text_line = str(one_theta) + "     " + str(this_yield) + "\n"
                    lines_to_write.append(this_text_line)
            else:
                # No calculated yields for this set.  Put in a spurious point at spin=-1.
                this_text_line = "-1.  ?  \n"   # Proper way to skip sets in gnuplot
                lines_to_write.append(this_text_line)
            lines_to_write.append("\n\n")  # two blank lines to separate sets

            if not plot_absolute:
                # Add the experimental data
                this_experiment_experimental_yields = experimental_yield_vs_phi_Ge[gosia_experiment_number]
                experimental_legend_entry = "Meas. Expt. "+str(gosia_experiment_number)
                experimental_legend.append(experimental_legend_entry)
                # Add the experimental data lines
                if not len(this_experiment_experimental_yields) == 0:
                    # There are experimental yields.
                    this_experiment_experimental_yields_theta_keys = this_experiment_experimental_yields.keys()
                    this_experiment_experimental_yields_theta_keys.sort()
                    for one_theta in this_experiment_experimental_yields_theta_keys:
                        this_yield_entry = this_experiment_experimental_yields[one_theta]
                        this_normalized_yield, this_normalized_error = this_yield_entry
                        this_text_line = str(one_theta) + "     " + str(this_normalized_yield) + "    " + str(this_normalized_error) + "\n"
                        lines_to_write.append(this_text_line)
                else:
                    # No experimental yields for this set.  Put in a spurious point at spin=-1.
                    this_text_line = "-1.  ?   ?  \n"   # Proper way to skip sets in gnuplot
                    lines_to_write.append(this_text_line)

                lines_to_write.append("\n\n")  # two blank lines to separate sets

        
        with open(plot_data_file_name,"w") as plot_data_file: 
            plot_data_file.writelines(lines_to_write)
        print "Data for this plot were written to the file \"" + plot_data_file_name + "\"."

        if not plot_absolute:
            # Now get the total reduced chi-squared.  (The number of
            # degrees of freedom is taken as simply the number of
            # experimental data points on the plot and does not include the
            # number of fit parameters.  In cases where there are no
            # experimental data points for this plot data set, the reduced
            # chi-squared would result in a divide-by-zero exception.  In
            # that case, we won't calculate the reduced chi-squared.
            if plot_absolute:
                chi_squared_string = ""
            else:
                try:
                    reduced_chi_squared_for_plot = chi_squared_sum / chi_squared_points 
                    # Generate a string to report the chi-squared and reduced chi-squared for the plot
                    chi_squared_string = "\"For " + str(chi_squared_points) + " points, chi-squared = " + str(round(chi_squared_sum,1)) + "      red. chi-squared  = " + str(round(reduced_chi_squared_for_plot,1)) + "\""
                except:
                    chi_squared_string = "Could not calculate chi-squared. Please report this bug."
                    
        # Write the plot data to the terminal.
        for one_line in lines_to_write:
            one_line = one_line.strip("\n")
            print one_line
        try:
            print chi_squared_string
        except:
            pass

        # Call a routine to launch gnuplot
        if plot_absolute:
            experimental_legend=None
            better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend)
        elif plot_experimental_yields:
            block_print_with_line_breaks("Plotting experimental and calculated yields.  The yields may not represent actual counts due to normalizations required by Gosia.")
            better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend,chi_squared_string)


        return 0



    def plot_yield_data(self,initial_band,final_band,initial_spin=None,final_spin=None,ge_polar_angle=None,ge_azimuthal_angle=None,tf=False):
        """Plots calculated and experimental yields using external plot package.

        tf = True means to plot only one line with one legend string--used in
        the "tf" accuracy test.

        """

        if tf:
            # Call the plotting routine made for the special "tf" tests.
            error_code = self.plot_tf(initial_band,final_band,initial_spin,final_spin,ge_polar_angle,ge_azimuthal_angle)
            return error_code

        else:
            # Get the plot type and the Ge detector angle information to select
            # plot data.  Also get the plot type (vs. particle angle, vs. Ge
            # angle, etc.)
            initial_band_name = investigated_nucleus.get_primary_band_name_from_band_number(initial_band)
            final_band_name   = investigated_nucleus.get_primary_band_name_from_band_number(final_band)
            print "Requested transition(s) are from band ",initial_band_name," to ",final_band_name,"."

            block_print_with_line_breaks("----------------------------------------------------------------------\nIf there are not experimental or calculated yields in memory for all detectors, you may get an inaccurate plot.  Make sure that you have calculated yields in memory (\"Integrated yields\") and the corresponding experimental yields in memory if you are plotting \"normalized\" yields.\n----------------------------------------------------------------------\n",70)

            which_type = raw_input("Plot vs. scattering [a]ngle, [s]pin, [p]olar Ge angle, a[z]imuthal Ge angle or [q]uit [a/s/p/z/q]? ")[0].lower()

            if which_type == "q":
                print "Quitting."
                return 0


        if which_type == "a":
            error_code = self.plot_yield_data_vs_scattering_angle(initial_band_name = initial_band_name,final_band_name = final_band_name)
            return error_code

        elif which_type == "s":
            error_code = self.plot_yield_data_vs_spin(initial_band_name = initial_band_name,final_band_name = final_band_name)
            return error_code

        elif which_type == "p": 
            error_code = self.plot_yield_data_vs_polar_Ge_angle(initial_band_name = initial_band_name,final_band_name = final_band_name)
            return error_code

        elif which_type == "z": 
            error_code = self.plot_yield_data_vs_azimuthal_Ge_angle(initial_band_name = initial_band_name,final_band_name = final_band_name)
            return error_code


    def read_fitted_geli_efficiencies_from_gosia(self,should_apply=False):
        """Reads suggested Ge efficiencies from Gosia's OP,MINI output.

        If should_apply is True, then they will be applied to the YNRM
        coefficients.
        
        """
        # Get the number of experiments.
        number_of_experiments = self.getnumberofexperiments()

        # Get the gosia output file name from the gosia shell.
        gosia_output_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[22]["extension"]

        # Read the gosia output file from disk.  
        with open(gosia_output_file_name,'r') as gosia_output_file:
            gosia_output_lines = gosia_output_file.readlines()
        # Save a copy of the last lines of the output, which might contain an error message.
        last_lines_of_output = gosia_output_lines[-5:]

        # This uses very simple error trapping if gosia threw an error.  Try to
        # obtain normalization constants for all experiments.  If there is an
        # exception, then just print the next-to-last line of the gosia output,
        # which usually contains the error message.
        try:
            # Find the recommended GeLi efficiencies in the op,mini output
            search_strings = ["RECOMMENDED","RELATIVE","GE(LI)","EFFICIENCIES"]
            first_line = findinlist(gosia_output_lines,search_strings) + 3  # 3 lines below the section header in the gosia output
            for experiment_number in range(number_of_experiments):
                experiment_number_string = str(experiment_number + 1)   # as a string in gosia's numbering system (beginning with 1)
                line_fields = gosia_output_lines[first_line + experiment_number].split() 
                new_factors_on_normalizations = []  # a new list to store them temporarily
                for efficiency_string in line_fields[1:]:
                    new_factors_on_normalizations.append(float(efficiency_string))
                # Output the constants to std output.
                gosia_experiment_number = experiment_number + 1
                print "New efficiency factors for expt.",gosia_experiment_number,": ",new_factors_on_normalizations
                # Store them in the experiment object if the user requested storage.
                if should_apply:
                    self.allexperiments[experiment_number].apply_factors_to_normalizations(new_factors_on_normalizations,True) # True flag means to invert these factors first.  Is this correct to invert the efficiencies (divide YNRM by efficiencies)?

        except:
            # Gosia probably threw an error.  Print out the error line in the gosia output
            check_for_gosia_error(gosia_output_lines)
            return "Error in reading Gosia's suggested Ge(Li) efficiencies--could not continue."




    def calculate_ynrm_constants(self,silent=False):
        """Determines the YNRM normalization constants for all experiments in memory.

        Note that the form of these constants is not clear from the manual.
        Only axial scattering symmetry is treated here, and in this case, they
        are given by sin(theta_lab_mean)*d, where d is the differential
        Rutherford cross section in the lab frame at the mean energy and
        scattering angle.

        In addition, for inverse kinematics, the IKIN flag must be checked to
        get normalizations for the desired solution.

        See the YNRM section of the manual pages on OP,YIEL.  This ignores
        differences in efficiency for now.  

        These constants are passed to the experiment objects.

        """

        gosia_experiment_number = 1  # Used only to label the output for the user.

        # Update the Q-value, in case NCM (the index of the level for which kinematics are calculated in Gosia) was changed.
        dummy, dummy, Q_value = the_gosia_shell.return_kinematics_state_data()   # Sign of Q is ignored.
        Q_value = Q_value / 1000.  # All kinematics functions require energies in MeV.

        print "Calculating normalization constants for Q = " + str(round(Q_value,4)) + " MeV."

        # Loop to get the normalizations for all experiments.
        for one_experiment in self.allexperiments:
            # For this experiment, get the information necessary to calculate the mean scattering angle and the differential cross section.
            E_mean_lab = one_experiment.get_parameter("E_mean")
            theta_lab_projectile_mean = one_experiment.mean_scattering_angle()
            Z_1 = one_experiment.get_parameter("Z_1")
            A_1 = one_experiment.get_parameter("A_1")
            Z_n = one_experiment.get_parameter("Z_n")
            A_n = one_experiment.get_parameter("A_n")
            excited_target = one_experiment.get_parameter("excited_target")
            I_kin = one_experiment.get_parameter("I_kin")
            # Determine whether this is the forward or backward c.o.m. scattering solution.  This will be ignored in normal kinematics cases.
            if I_kin == 1:
                forward_com_solution = True
            else:
                forward_com_solution = False

            # Determine which are the beam and target particles.
            if excited_target:
                Z_proj = Z_n
                A_proj = A_n
                Z_targ = Z_1
                A_targ = A_1
            else:
                Z_proj = Z_1
                A_proj = A_1
                Z_targ = Z_n
                A_targ = A_n

            # Calculate the differential Rutherford cross section line for this experiment in the lab frame at the mean scattering angle and energy.
            # Old elastic approximation: differential_rutherford_cross_section = differential_rutherford(Z_proj,A_proj,Z_targ,A_targ,E_mean_lab,theta_lab_projectile_mean,forward_com_solution)

            # Inelastic scattering cross section:
            differential_rutherford_cross_section = inelastic_differential_scattering_cross_section(Z_proj,A_proj,Z_targ,A_targ,theta_lab_projectile_mean,forward_com_solution,E_mean_lab,Q_value)

            # Calculate the YNRM value for this experiment.  Differences in efficiencies of the Ge detectors are not treated here.
            sine_factor = math.sin(math.radians(theta_lab_projectile_mean))
            new_normalization_constant = sine_factor * differential_rutherford_cross_section

            # Set this value of YNRM for all detectors in this experiment.
            one_experiment.set_detector_normalization("all",new_normalization_constant)
            if not silent:
                #print "Differential Rutherford cross section for expt.",gosia_experiment_number," = ",differential_rutherford_cross_section," mb/sr,\n",\
                #  "  sin(theta_lab_mean) = ",sine_factor, "  and normalization constant = ",new_normalization_constant
                print "Experiment " + str(gosia_experiment_number) + " normalization constant = " + format(new_normalization_constant,"g")

            # Increment the gosia experiment number.
            gosia_experiment_number = gosia_experiment_number + 1


    def parse_gosia_integrated_yields(self,tf=False,evaluate=False,cor_file_extension=None):
        """Parses the gosia output to get the integrated yields and stores them in experiment objects.

        This will only read integrated yields if the last gosia operation was OP,INTG!

        If evaluate is True, then only information about which states are
        excited and which states have finite lifetimes will be returned, but no
        yields will be stored.

        """

        # Set the lower limit on calculated yields:
        # July 2011: Using the lower 10**(-18) limit for evaluation of coupled
        # (excited) states also.
        if tf or evaluate:
            calculated_lower_limit = 1.0e-18
        else:
            calculated_lower_limit = CALCULATED_YIELD_LOWER_LIMIT

        # Get the number of experiments.
        number_of_experiments = self.getnumberofexperiments()

        # Get a list of the number of detectors so that we can understand the order of
        # experiments and detectors in the gosia output file.
        numbers_of_detectors = self.get_numbers_of_detectors()
        #print "at beginning, numbers_of_detectors ",numbers_of_detectors 

        # Make a list of sets of states excited in each experiment and each
        # detector.  States will be added if they are excited in a given
        # detector.
        sets_of_excited_states = []
        for i in range(number_of_experiments):
            sets_of_excited_states.append([])
            for j in range(numbers_of_detectors[i]):
                sets_of_excited_states[i].append(set())  # Using set math to avoid multiple entries.

        if not cor_file_extension == None:
            # Will write a dummy corr file e.g. for a deorientation coeff calculation.
            cor_file_lines = []

        # Get the gosia output file name from the gosia shell.
        gosia_output_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[22]["extension"]

        # Read the gosia output file from disk.  
        with open(gosia_output_file_name,'r') as gosia_output_file:
            gosia_output_lines = gosia_output_file.readlines()
        # Save a copy of the last lines of the output, which might contain an error message.
        last_lines_of_output = gosia_output_lines[-5:]

        # Check for gosia errors
        gosia_error_check_code = check_for_gosia_error(gosia_output_lines)

        # This uses very simple error trapping if gosia threw an error.  Try to
        # parse the yields.  If there is an exception, then just print the
        # next-to-last line of the gosia output, which usually contains the
        # error message.
        # July 13 2011: reactivated this try/except block.
        try:
            # Loop to get all integrated yields for all experiments and all detectors
            for experiment_number in range(number_of_experiments):
                for detector_number in range(numbers_of_detectors[experiment_number]):
                    experiment_number_string = str(experiment_number + 1)   # as a string in gosia's numbering system (beginning with 1)
                    detector_number_string = str(detector_number + 1)   # as a string in gosia's numbering system (beginning with 1)
                    # Find the header line for this experiment.
                    search_strings = ["EXPERIMENT",experiment_number_string,"DETECTOR",detector_number_string]
                    experiment_line = findinlist(gosia_output_lines,search_strings)
                    # Set the line number to the beginning of the integrated yields for this detector.
                    detector_data_start_line = experiment_line + 5
                    # Pull out calculated yields from each detector and give to experiment object to save.
                    detector_yields = []  # This is for one single detector and will be reused.
                    # Start reading where detector data start.
                    line_number = detector_data_start_line
                    # Add a header for a dummy corrected yields file if requested.
                    if not cor_file_extension == None:
                        # Add  a header for one corrected yield for each detector.
                        cor_file_lines.append("1 1 1 1 1 1 1 \n")
                        added_one_dummy_yield = False
                    while True:
                        line_fields = gosia_output_lines[line_number].split() 
                        if len(line_fields) < 6:  
                            # no more data in this detector block
                            break  # break out of the while loop for this detector
                        initial_gosia_level_number = int(line_fields[0])  
                        final_gosia_level_number   = int(line_fields[1])  

                        gosia_output_initial_spin = round(float(line_fields[2]),1)  # initial spin rounded to nearest half integer
                        gosia_output_final_spin   = round(float(line_fields[3]),1)  # final spin rounded to nearest half integer

                        # Look up the initial and final primary band names for these states.
                        initial_band_name, initial_spin = investigated_nucleus.get_band_and_spin_from_gosia_level_number(initial_gosia_level_number)
                        final_band_name,   final_spin   = investigated_nucleus.get_band_and_spin_from_gosia_level_number(final_gosia_level_number)

                        # Issue an error if the gosia levels don't match the expected spins.
                        if not initial_spin == gosia_output_initial_spin or not final_spin == gosia_output_final_spin:
                            print "The gosia yield output is not understood for the ", initial_band_name, initial_spin,\
                              " to ", final_band_name, final_spin, "transition."
                            print "Please report this bug."

                        try:
                            calculated_yield = float(line_fields[4])
                        except:
                            # Sometimes in point calculations, yields are printed with an insufficient format by gosia, 
                            # e.g. instead of 0.10000E-103, it is printed as 0.10000-103.  Correct this number by inserting
                            # the E before the - sign
                            replace_for_plus = line_fields[4].replace("+","E+")
                            replace_for_minus = line_fields[4].replace("-","E-")
                            if replace_for_minus == line_fields[4]:
                                calculated_yield = replace_for_plus
                            else:
                                calculated_yield = replace_for_minus

                        # Gosia's output of "normalized yield" is not used
                        # anymore.  The experiment manager normalizes the
                        # calculated yields as requested by the user.


                        if calculated_yield > calculated_lower_limit :    # Keep only measurable yields
                            detector_yields.append([initial_band_name, initial_spin, final_band_name, final_spin, calculated_yield]) 
                            # This addition to the sets of excited states has been
                            # moved here.  In some cases, uncoupled states are
                            # *listed* in the output, but they have a calculated
                            # yield identically 0.  (On some machines, there is the
                            # possibility of a very small yield.  To protect
                            # against this, states will not be added as excited if
                            # they have a yield less than the
                            # calculated_lower_limit.)

                            # If evaluate is True, then only gather a list of
                            # states which can be excited from the ground state to
                            # a calculable population and those which have a finite
                            # lifetime.
                            if evaluate:
                                # Now the nucleus object needs references to tuples of (band_name, spin) rather than the old level numbers.
                                level_key_populated = (initial_band_name, initial_spin)
                                sets_of_excited_states[experiment_number][detector_number].add(level_key_populated)  # add using set math (no duplicates).

                            if not cor_file_extension == None and not added_one_dummy_yield:
                                # Add these to the lines of a dummy cor file.
                                this_cor_line = str(initial_gosia_level_number) + " " +\
                                                str(final_gosia_level_number) + " 1.0 1.0 \n"
                                cor_file_lines.append(this_cor_line)
                                added_one_dummy_yield = True

                        # Increment the line number
                        line_number = line_number + 1

                    # Delete the earlier lines, so that e.g. expt 1, det 2 won't be confused with
                    # expt 2, det 1 in the findinlist routine.  I should make a switch that forces 
                    # the specified order of strings in findinlist.
                    # Need to delete up to the line containing the header
                    # EXPERIMENT N DETECTOR M to make sure E 1, D 2 is not
                    # found instead of E 2, D 1, for example.
                    del gosia_output_lines[:experiment_line + 1]  

                    # Store the yields for this experiment
                    # Added this if statement.  We don't want to store the yields if
                    # this is only a point-calculation evaluation run to find excited
                    # states.
                    if not evaluate:
                        self.allexperiments[experiment_number].set_one_detector_calculated_yields(detector_number,detector_yields)  

            if evaluate:
                # Store the sets of excited states to 
                self.excited_states = sets_of_excited_states

                # If evaluate was set to true, then the lifetime data should follow
                # the point populations.  (evaluate=True should only be used with
                # OP,POIN.)

                # If the internal level number is not in the dictionary, then
                # it does not have a finite lifetime calculated by gosia.

                investigated_nucleus.zero_calculated_lifetimes()
                search_strings = ["LEVEL","LIFETIME(PSEC)","EXP","ERROR"]
                lifetime_line = findinlist(gosia_output_lines,search_strings) + 2
                final_line = len(gosia_output_lines) - 1
                while lifetime_line < final_line:
                    line_fields = gosia_output_lines[lifetime_line].split()
                    if len(line_fields) < 2:  # If this is the end of the lifetime ouput...
                        break  # out of the loop to parse lifetimes.
                    gosia_level_number = int(line_fields[0])
                    level_key = investigated_nucleus.get_band_and_spin_from_gosia_level_number(gosia_level_number)
                    lifetime_in_ps = float(line_fields[1])
                    # If there is a finite lifetime only...
                    if lifetime_in_ps > 0.:  
                        # The lifetime calculated by Gosia will be returned as
                        # negative if it is too long to be calculated.
                        investigated_nucleus.levels[level_key].set_calculated_lifetime(lifetime_in_ps)
                    lifetime_line += 1

            if not cor_file_extension == None:
                # Write a dummy corr file e.g. for a deorientation coeff calculation.
                cor_file_name = "gosia." + cor_file_extension
                with open(cor_file_name,"w") as dummy_file:
                    dummy_file.writelines(cor_file_lines)

        except:
            block_print_with_line_breaks("Error parsing yields from Gosia output--processing could not continue.\nThere may be a mixture of old and new calculated yields in memory.  You can use \"Undo\" to revert to the previous successful operation.",70)
            return -1


    def parse_deorientation_coefficients(self,lifetimes = True, deorientation = True):
        """Parses the gosia output to get the vacuum deorientation parameters and lifetimes and prints them

        This will only get the correct values if the last gosia operation was
        to calculate them.  By default the GUI doesn't calculate them.

        Now it can parse for either or both of lifetime, G#.

        """


        # Get the gosia output file name from the gosia shell.
        gosia_output_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[22]["extension"]

        # Read the gosia output file from disk.  
        with open(gosia_output_file_name,'r') as gosia_output_file:
            gosia_output_lines = gosia_output_file.readlines()
        # Save a copy of the last lines of the output, which might contain an error message.
        last_lines_of_output = gosia_output_lines[-5:]

        # Check for gosia errors
        #gosia_error_check_code = check_for_gosia_error(gosia_output_lines)

        # First, get the level keys in Gosia order.
        current_level_keys = investigated_nucleus.get_level_keys_in_gosia_order(include_inactive_bands = True)

        if lifetimes:
            # Since the deorientation Gk's depend strongly on the decay lifetimes
            # and the feeding through the Bateman equations, the lifetimes are of
            # interest as well.  We will get them first.

            # Zero the calculated lifetimes:
            investigated_nucleus.zero_calculated_lifetimes()

            try:
                print "Level             Lifetime (ps)          half-life (ps)"
                #      1234567890123456__123456789012345678901__12345678901234
                print "-------------------------------------------------------"
                search_strings = ["LEVEL","LIFETIME(PSEC)","EXP","ERROR"]
                lifetime_lines = find_all_in_list(gosia_output_lines,search_strings)
                if not len(lifetime_lines) == 1:
                    print "The vacuum deorientation data were not understood in the gosia.out file."
                    print "Please report this bug."
                    return -1
                line_number = lifetime_lines[0] + 2
                while True:
                    this_line = gosia_output_lines[line_number]
                    line_fields = this_line.split()
                    if not len(line_fields) == 2:
                        break # Finished reading all lifetimes
                    this_gosia_level_number = int(line_fields[0])
                    this_internal_level_number = this_gosia_level_number - 1
                    this_lifetime = float(line_fields[1])
                    # If the lifetime cannot be calculated because there are no decays
                    # defined by matrix elements, then it will appear as negative in
                    # the Gosia output.

                    if this_lifetime > 0.0:
                        # A valid lifetime was calculated.  Store this in the nucleus.levels data.
                        # Get the level key from the Gosia level number.
                        this_level_key = current_level_keys[this_internal_level_number]
                        # Save the lifetime in ps to this level.
                        investigated_nucleus.levels[this_level_key].set_calculated_lifetime(this_lifetime)
                        this_half_life = math.log(2.) * this_lifetime
                        band_name, spin = investigated_nucleus.get_band_and_spin_from_gosia_level_number(this_gosia_level_number)
                        print band_name.ljust(10) + "  " +  str(spin).ljust(4) + "  " + str(this_lifetime).ljust(21) + "  " + str(this_half_life).ljust(14)

                    line_number += 1
                print "\nLifetimes calculated and stored in level data.\n"

            except:
                block_print_with_line_breaks("Error parsing lifetimes from Gosia output--processing could not continue.",70)
                return -1

        if deorientation:

            # Zero the calculated G2--G6, and then read & save the new ones.
            investigated_nucleus.zero_deorientation_Gs()

            G_coefficients = {}  # For temporary storage and printing.

            number_of_experiments = self.getnumberofexperiments()
            search_strings = ["LEVEL","G2","G4","G6"]
            vacuum_lines = find_all_in_list(gosia_output_lines,search_strings)
            if not len(vacuum_lines) == number_of_experiments:
                print "The vacuum deorientation data were not found in the gosia.out file."
                print "Please report this bug."
                return -1

            print "\nVacuum deorientation coefficients calculated at mean scattering angles and stored.\n"
            # This uses very simple error trapping if gosia threw an error.  Try to
            # parse the yields.  If there is an exception, then just print the
            # next-to-last line of the gosia output, which usually contains the
            # error message.
            try:
                # Loop to get all integrated yields for all experiments.
                for internal_experiment_number in range(number_of_experiments):
                    #experiment_description = self.allexperiments[internal_experiment_number].short_description()
                    experiment_description = self.allexperiments[internal_experiment_number].long_description()
                    print "Experiment ",internal_experiment_number + 1
                    print experiment_description
                    print ""
                    print "Level             G2          G4          G6           "
                    print "-------------------------------------------------------"
                    line_number = vacuum_lines[internal_experiment_number] + 2  # Skip to the first level entry
                    while True:
                        this_line = gosia_output_lines[line_number]
                        this_line_fields = this_line.split()
                        if not len(this_line_fields) == 4:
                            # There are no more levels in the output for this experiment
                            break  # out of the while loop
                        # Get the gosia level index and the G2, G4, G6 coefficients
                        gosia_level_number = int(this_line_fields[0])
                        internal_level_number = gosia_level_number - 1
                        G2 = float(this_line_fields[1])
                        G4 = float(this_line_fields[2])
                        G6 = float(this_line_fields[3])
                        # Get the level key from the internal_level_number:
                        this_level_key = current_level_keys[internal_level_number]
                        this_level_lifetime = investigated_nucleus.levels[this_level_key].get_calculated_lifetime()
                        if not this_level_lifetime == None:
                            # Store these in the nucleus.levels data:
                            investigated_nucleus.levels[this_level_key].set_deorientation_Gs(G2,G4,G6)

                            # Change to the band name and spin, and print
                            band_name, spin = investigated_nucleus.get_band_and_spin_from_gosia_level_number(gosia_level_number)
                            print band_name.ljust(10) + "  " +  str(spin).ljust(4) + "  " + str(G2).ljust(10) + "  " + str(G4).ljust(10) + "  " + str(G6).ljust(10)
                        line_number += 1
                    print ""

            except:
                block_print_with_line_breaks("Error parsing vacuum deorientation coefficients from Gosia output--processing could not continue.",70)
                return -1

        return 0


    def properly_weighted_chi_squared_report(self):
        """Calculates the chi-squared for all experiments using the last integration.

        This is the chi-squared properly-weighted using the fractional errors
        on the experimental yields.

        """

        # The number of experiments for the chisq calculation and the report of
        # the worst discrepancies.

        number_of_experiments = self.getnumberofexperiments()

        # Keep track of the transitions with the worst chi-squared values to
        # print a report of that too.

        chisq_report_list = []
        for i in range(number_of_experiments):
            chisq_report_list.append([])

        # Lists of the numbers of data points in each experiment and the chisq
        # value of each.

        data_points_for_experiment = []
        chi_squared_for_experiment = []

        lines_to_display = ["Chi-squared and yield report for integrated yields",\
                            "  See the bottom for the yields ordered from highest chi-squared contribution",\
                            "  to lowest.                                                                 ",\
                            "Chi-squared from the last integration:",\
                            "  This value may be more accurate than that reported in the Gosia *fit* output.",\
                            "  because it represents a full integration, whereas the Gosia fit uses a",\
                            "  point calculation.",\
                            "However, the value below includes only yield data.  Optional spectroscopic",\
                            "  data are not included in the value below (planned improvement).",\
                            "",\
                            "Experiment  norm. to calc.  chi-squared  data points  reduced chi-squared",\
                            "-------------------------------------------------------------------------"]
                            #1234567890__12345678901234__12345678901__12345678901__1234567890123456789

        # Step through all experiments and add the yield data for all detectors.
        # Save the weighted-mean normalization constants for the report.
        expt_to_calc_normalizations = []
        for internal_experiment_number in range(number_of_experiments):

            data_points_for_experiment.append(0)
            chi_squared_for_experiment.append(0.0)
            this_experiment = self.allexperiments[internal_experiment_number]
            this_experiment_number_of_detectors = this_experiment.get_number_of_detectors()
            # Get the weighted mean normalization of the experimental data.
            try:
                experimental_normalization_constant = self.get_overall_normalization_for_experimental_yields(internal_experiment_number)[1] 
                skip_experiment = False
            except:
                print "Not enough experimental data to generate a chi-squared report for experiment " + str(internal_experiment_number + 1) + "."
                skip_experiment = True
                chi_squared_for_experiment.append(None)
                data_points_for_experiment.append(None)
                expt_to_calc_normalizations.append(None)
            if not skip_experiment:
                expt_to_calc_normalizations.append(experimental_normalization_constant)
                # Detector list for this experiment:
                for internal_detector_number in range(this_experiment_number_of_detectors):
                    detector_object = this_experiment.Ge_detectors[internal_detector_number]
                    this_calculated_yield_set   = detector_object.return_calculated_yields()
                    this_experimental_yield_set   = detector_object.return_experimental_yields()

                    # Step through each calculated yield, and get the corresponding
                    # experimental yield, if it exists.  Calculate the chi-squared
                    # contribution from this point, and add it to the totals.  The
                    # weighted-mean normalization is applied to the experimental
                    # data.  

                    if not this_calculated_yield_set == None and not this_experimental_yield_set == None:
                        for one_calculated_entry in this_calculated_yield_set:
                            initial_band_name, initial_spin, final_band_name, final_spin, calculated_yield = one_calculated_entry

                            # Change to pointers, so that we don't miss a match
                            # (compare pointers to see if two levels are the
                            # same.
                            try:
                                skip_calc_entry = False
                                initial_level_pointer_string = str(investigated_nucleus.levels[(initial_band_name, initial_spin)])
                                final_level_pointer_string = str(investigated_nucleus.levels[(final_band_name, final_spin)])
                            except:
                                # If an exception was raised, one or both
                                # levels are not in memory.  Skip this calculated
                                # yield.
                                skip_calc_entry = True

                            if not skip_calc_entry:

                                # Compare with expt yields until a matching entry is found.
                                this_expt_yld_found = False
                                for one_experimental_entry in this_experimental_yield_set:
                                    this_initial_band_name, this_initial_spin, this_final_band_name, this_final_spin, absolute_experimental_yield, absolute_error = one_experimental_entry
                                    try:
                                        skip_expt_entry = False
                                        this_initial_level_pointer_string = str(investigated_nucleus.levels[(this_initial_band_name, this_initial_spin)])
                                        this_final_level_pointer_string   = str(investigated_nucleus.levels[(this_final_band_name, this_final_spin)])
                                    except:
                                        # If an exception was raised, one or both
                                        # levels are not in memory.  Skip this calculated
                                        # yield.
                                        skip_expt_entry = True

                                    if not skip_expt_entry and initial_level_pointer_string == this_initial_level_pointer_string and final_level_pointer_string == this_final_level_pointer_string:

                                        # This experimental yield entry matches the transition for the calculated entry.
                                        # Apply the normalization constant.
                                        experimental_yield = absolute_experimental_yield / experimental_normalization_constant 
                                        error              = absolute_error / experimental_normalization_constant 
                                        # Calculated the chi-squared contribution etc.
                                        chisquared_contribution = (experimental_yield - calculated_yield)**2 / error**2
                                        sigma_discrepancy       = (calculated_yield - experimental_yield) / error
                                        percent_discrepancy     = 100.0 * (calculated_yield - experimental_yield) / experimental_yield
                                        chi_squared_for_experiment[-1] += chisquared_contribution 
                                        data_points_for_experiment[-1] += 1

                                        # Record this chisq value with a
                                        # description of the transition, calc,
                                        # expt yield, etc. for a report.
                                        display_experiment_number = internal_experiment_number + 1
                                        display_detector_number   = internal_detector_number + 1
                                        transition_string = str(display_detector_number).ljust(10) + " " + initial_band_name.ljust(8) + " " + str(initial_spin).rjust(5) + " --> " + final_band_name.ljust(8) + " " + str(final_spin).rjust(5) + " " + format(experimental_yield,".3g").rjust(9) + " +/- " + format(error,".3g").ljust(9) + " " + format(calculated_yield,".3g").rjust(8) + "  " + format(percent_discrepancy,".1f").rjust(7) + "% " + format(sigma_discrepancy,".1f").rjust(9) + "    " + format(chisquared_contribution,".1f").rjust(9)
                                        # We record a two-item list of [chisq,report string], so that they can be formatted in order of decreasing chisq.
                                        chisq_report_list[internal_experiment_number].append([chisquared_contribution,transition_string])  

                                        this_expt_yld_found = True
                                        # Try to remove this entry, so we don't check it twice.
                                        # This may not be very robust for floats in the list.
                                        this_experimental_yield_set.remove(one_experimental_entry)
                                        break

        # Calculate total and generate a report.
        total_chi_squared = 0.0
        total_data_points = 0

        for internal_experiment_number in range(number_of_experiments):
            data_points = data_points_for_experiment[internal_experiment_number]
            chi_squared = chi_squared_for_experiment[internal_experiment_number]
            expt_to_calc_normalization = expt_to_calc_normalizations[internal_experiment_number]
            if not data_points == None and not chi_squared == None and not expt_to_calc_normalization == None:
                if not data_points == 0:
                    reduced_chi_squared = chi_squared / data_points  
                else:
                    reduced_chi_squared = 0.0
                total_data_points += data_points
                total_chi_squared += chi_squared
                gosia_experiment_number = internal_experiment_number + 1
                this_line = str(gosia_experiment_number).rjust(10) + 2 * " " + format(expt_to_calc_normalization,"g").rjust(14) + 2 * " " + \
                            format(chi_squared,".3f").rjust(11) + 2 * " " + \
                            str(data_points).rjust(11) + 2 * " " + format(reduced_chi_squared,".3f").rjust(11)
                lines_to_display.append(this_line)

        # Get reduced chi-squared for all data sets.
        if not total_data_points == 0:
            total_reduced_chi_squared = total_chi_squared / total_data_points
        else:
            total_reduced_chi_squared = 0.0
        total_line = "Total       " + 16 * " " + format(total_chi_squared,".3f").rjust(11) + 2 * " " \
                   + str(total_data_points).rjust(11) + 2 * " " + format(total_reduced_chi_squared,".3f").rjust(11)
        lines_to_display.append("-------------------------------------------------------------------------")
        lines_to_display.append(total_line)

        lines_to_display.extend(["","Adjustable data set weights have not been","included in this chi-squared calculation.","","The \"norm. to calc.\" field is the weighted","normalization factor on the calculated yields","giving the best fit to the experimental data.","","Chi-squared contributions from each experiment",""])

        chisq_header_string_1 = "                                                  Expt                   Calc  |             Discrepancy                  |"
        chisq_header_string_2 = "Detector #                   Transition           Yld                     Yld  |      %     # Std Dev      Chi squared    |"
        underline_header      = "---------------------------------------------------------------------------------------------------------------------------"

        # Add to the report the worst chisq offenders for each experiment.
        for internal_expt_number in range(len(chisq_report_list)):
            expt_counter_line = "Experiment " + str(internal_expt_number + 1).rjust(2)
            lines_to_display.extend(["","Experiment " + str(internal_expt_number + 1).rjust(2),chisq_header_string_1,chisq_header_string_2,underline_header, ""])
            one_expt_list = chisq_report_list[internal_expt_number]
            one_expt_list.sort()  # low to high chisq
            one_expt_list.reverse()
            for entry in one_expt_list:
                lines_to_display.append(entry[1])

        create_dialog_popup({"text_lines":lines_to_display,"title":"Chi-squared report"})

        investigated_nucleus.notes.append_log("procedure_log","Integrated yields: Reduced chi-squared = " + str(total_reduced_chi_squared) )
        return total_chi_squared,total_data_points,total_reduced_chi_squared

    def write_experimental_yld_file(self,to_force=False):
        """Writes experimental yields from memory to gosia's .yld file.

        This version (Mar. 6 2011) of the method will skip any experimental
        yields for which the initial state is not populated, or with no matrix
        element coupling to the final state.

        Yields are also skipped if the initial state is not higher in energy
        than the final state.

        """
        yld_file_lines = [] # a list of text strings to be put in the yld file.

        # Get the number of experiments to write data for.
        number_of_experiments = self.getnumberofexperiments()

        # Get a list of the number of detectors for each experiment.
        numbers_of_detectors = self.get_numbers_of_detectors()

        # This flag will be set False if any data sets are empty.
        yield_sets_are_complete = True

        # A dictionary for sorting one data set yields by initial and final
        # level number.  The format is {(initial_gosia_level_number,
        # final_gosia_level_number):yield_entry,...}, where yield_entry is the
        # formatted string for the gosia.yld file.

        # one_data_set_sorting_dict = {}  THIS IS IN THE WRONG PLACE AND CAUSES ERRORS!

        for experiment_number in range(number_of_experiments):
            gosia_experiment_number = experiment_number + 1
            for detector_number in range(numbers_of_detectors[experiment_number]):
                one_data_set_sorting_dict = {}  # Reset the sorting dictionary for each new data set (detector).  Bug-fix Mar. 4, 2012.
                one_set_yld_file_lines = [] # a temporary list of yields (text strings) to be put into the total list "yld_file_lines"
                # Step through all integrated yields, adding an error bar for each.
                # Get the yields for this detector.  
                one_data_set_yields = self.allexperiments[experiment_number].get_experimental_yields(detector_number)
                number_of_yields = len(one_data_set_yields)  # for this data set in this experiment
                for yield_number in range(number_of_yields):
                    initial_band_name   = one_data_set_yields[yield_number][0]
                    initial_spin        = one_data_set_yields[yield_number][1]
                    final_band_name     = one_data_set_yields[yield_number][2]
                    final_spin          = one_data_set_yields[yield_number][3]
                    intensity           = one_data_set_yields[yield_number][4]
                    intensity_error     = one_data_set_yields[yield_number][5]
                    gosia_initial_level = investigated_nucleus.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
                    gosia_final_level   = investigated_nucleus.lookup_gosia_level_by_band_spin(final_band_name,final_spin)
                    # Form level keys to lookup energies and check couplings.
                    initial_level_key   = (initial_band_name, initial_spin)
                    final_level_key     = (final_band_name, final_spin)
                    initial_energy      = investigated_nucleus.get_level_information(initial_level_key,"energy")  # Energy in keV
                    final_energy        = investigated_nucleus.get_level_information(final_level_key,"energy")  # Energy in keV
                    
                    # Is the initial state populated, and is there at least one
                    # matrix element coupling the initial and final states for
                    # this data point?  Is the transition from higher to lower
                    # energy?  If all of these conditions are True, then
                    # include the decay data.  Otherwise, skip the data.

                    level_energies_known = not (initial_energy == None or final_energy == None)
                    is_populated = self.is_populated(initial_level_key) 
                    are_coupled  = investigated_nucleus.are_coupled(initial_level_key, final_level_key)
                    # Is this a decay transition from higher to lower energy (and are both energies known)?
                    is_decay_transition = (initial_energy >= final_energy) and not None in [initial_energy, final_energy]
                    if level_energies_known and is_populated and are_coupled and is_decay_transition:
                        yield_entry = str(gosia_initial_level) + "  " + str(gosia_final_level) + "  " + str(intensity) \
                          + "  " + str(intensity_error) 
                        gosia_state_sorting_key = (gosia_initial_level,gosia_final_level)
                        one_data_set_sorting_dict[gosia_state_sorting_key] = yield_entry

                # This data_set_number will correspond to a single Ge detector until it is
                # made more general to handle clusters, etc.
                gosia_data_set_number = detector_number + 1  # Change internal numbering to gosia numbering.
                # Generate a header for this data set.  We will just use dummy values for now.
                ZP = 1
                AP = 1
                EP = 1
                number_of_yields_used = len(one_data_set_sorting_dict)
                if number_of_yields_used == 0:
                    # Set the flag to indicate that the user needs more yield data.
                    yield_sets_are_complete = False
                WT = 1.0     # make the weights 1 for all experiments
                data_set_header = str(gosia_experiment_number) + "  " + str(gosia_data_set_number) \
                  + "  " + str(ZP) + "  " + str(AP) + "  " + str(EP) + "  " + str(number_of_yields_used) \
                  + "  " + str(WT) 
                yld_file_lines.append(data_set_header)

                # Sort the yields for this data set by initial and final gosia level number.
                sorted_yield_keys = one_data_set_sorting_dict.keys()
                sorted_yield_keys.sort()
                for one_key in sorted_yield_keys:
                    one_set_yld_file_lines.append(one_data_set_sorting_dict[one_key])
                    
                # Now put the yields for this set into the list to write to the yld file.
                yld_file_lines.extend(one_set_yld_file_lines)

        # Add one blank line to the end of the file.
        yld_file_lines.append(" ")

        # Define the file name to be written.
        gosia_file_number = 3
        gosia_yld_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[3]["extension"]
        
        # Write the yields to the file
        write_lines_to_file(gosia_yld_file_name,yld_file_lines,to_force)

        if not yield_sets_are_complete:
            print "Warning--some detectors do not have experimental yield data!"

        return yld_file_lines



    def write_simulated_yld_file(self,force_write=False,all_parameters={}):
        """Writes simulated yields to gosia's .yld file.

        Calculated (integrated) yields must be in memory, because it uses them
        with estimated counts for each detector, based on a "standard" Ge crystal
        and efficiency curve.

        This prompts for information about the expected beam run to generate
        data with actual p-gamma counts and sqrt(N) errors.

        If all_parameters contains the correct parameters and their values,
        then the prompts are skipped, and the parameter dict is used instead.

        Required parameters:
            inspect_change_efficiency 
            days_of_beam 
            beam_intensity 
            minimum_counts 
            estimated_additional_error 
            user_energy_threshold 
            add_scatter                   

        Example of all_parameters dict:
            
              { \
                "days_of_beam":5.0, \
                "beam_intensity":1.0, \
                "minimum_counts":10, \
                "estimated_additional_error":0.05, \
                "user_energy_threshold":50.0, \
                "inspect_change_efficiency":False, \
                "add_scatter":False, \
              }

        """

        if not all_parameters == {}:
            # Try to get all parameters from this dict; return an error if one or more are wrong.
            try:
                days_of_beam                  = float(all_parameters["days_of_beam"]) 
                beam_intensity                = float(all_parameters["beam_intensity"]) 
                minimum_counts                = float(all_parameters["minimum_counts"]) 
                estimated_additional_error    = float(all_parameters["estimated_additional_error"]) 
                user_energy_threshold         = float(all_parameters["user_energy_threshold"]) 
                inspect_change_efficiency     = all_parameters["inspect_change_efficiency"]
                add_scatter                   = all_parameters["add_scatter"]
                if not type(inspect_change_efficiency) == bool:
                    print "Invalid parameter inspect_change_efficiency in write_simulated_yld_file."
                    return None
                if not type(add_scatter) == bool:
                    print "Invalid parameter add_scatter in write_simulated_yld_file."
                    return None
                interactive = False
            except:
                print "Invalid parameter dictionary in write_simulated_yld_file."
                return None
        else:
            interactive = True


        default_gamma_energy_threshold = 50.0 # keV


        if interactive:
            block_print_with_line_breaks("This function calculates **efficiency-corrected** p-gamma counts with errors based on the actual (uncorrected) counts.  The particle-detector efficiency is assumed to be 100%, not including the angular acceptance.  The final errors include the Poisson counting errors and any additional error added by the user.")

            inspect_change_efficiency = require_yes_no("Do you want to inspect or change the efficiency curves [y/n]? ")

        if inspect_change_efficiency:
            the_detector_manager.change_efficiency_parameters()

        if interactive:
            days_of_beam = prompt_number("Expected days of beam on target: ","f")
            if days_of_beam == "quit":
                print "Quitting."
                return -1

        if interactive:
            beam_intensity = prompt_number("Estimated beam current [pnA]: ","f")
            if beam_intensity == "quit":
                print "Quitting."
                return -1

        if interactive:
            minimum_counts = prompt_number("Measurement threshold in counts ( >= 1.): ","f")
            if minimum_counts == "quit":
                print "Quitting."
                return -1

        minimum_counts = max(1., minimum_counts)
        if interactive:
            print "Minimum counts taken as ",minimum_counts

        if interactive:
            estimated_additional_error = prompt_number("Specify an additional fractional random error (0. <= error < 1.)\ne.g. efficiency correction, background subtraction.  You may get strange fits if you make the error bars too small, because of delta-functions in the chi-squared surface.  \nAdditional fractional error: ","f")
            if estimated_additional_error == "quit":
                print "Quitting."
                return -1

        estimated_additional_error = min(max(estimated_additional_error, 0.),0.99)

        if interactive:
            print "Added fractional error taken as ", estimated_additional_error

        if interactive:
            block_print_with_line_breaks("Define the low-energy threshold of the detectors.  Gammas below this energy will be excluded from the simulated data.",60)
            user_energy_threshold = raw_input("Enter the low gamma energy threshold in keV [minimum 50.0]: ")
        try:
            gamma_energy_threshold = max(abs(float(user_energy_threshold)),default_gamma_energy_threshold)
        except:
            gamma_energy_threshold = default_gamma_energy_threshold
        if interactive:
            print "Gamma energy threshold = ",gamma_energy_threshold, " keV."

        if interactive:
            block_print_with_line_breaks("You can choose to add Gaussian random scatter to data to better simulate actual data scatter, and more realistic expected errors in the fit parameters.")

            add_scatter = require_yes_no("Add Gaussian random scatter to data [y/n]? ")

        if add_scatter:
            random.seed()  

        # Generate column headings with appropriate comments.
        if add_scatter:
            header_lines =  ["THIS SIMULATION INCLUDES RANDOM GAUSSIAN SCATTER.                                                                        "]
        else:
            header_lines =  ["This simulation does not include random gaussian scatter.  Counts represent the cross sections calculated by Gosia.      "]

        # September 9 2011: Better column headings.
        header_lines.extend(["       Transition             |  Gammas incident      |                     Fraction of |         Observed Counts        ",\
                             "                              |  on Ge detectors      | Gamma               Incident    |                                ",\
                             " Initial         Final        |                       | Energy **Detector   Gammas      |                                ",\
                             "    Band Spin     Band Spin   | Counts    *Error      | (keV)   Efficiency  Detected    | Rate(Hz)   Counts  ***Error    ",\
                             "-------------------------------------------------------------------------------------------------------------------------"])
                             #gsb     _10.5_gsb     _ 7.5_____1.234e+02__1.234e+01____1325.5__0.00384_____0.25142_______1.234e-03__1.234e+08__1.234e+06
                             #12345678_1234_12345678_1234_____123456789__123456789____123456__1234567_____1234567_______123456789__123456789__123456789

        yld_file_lines = [] # a list of text strings to be put in the yld file.
        all_table_lines = [] # a list of lines to output to the terminal.
        lines_to_write = []  # a list of lines to save the table to a text file.

        # Get the number of experiments to write data for.
        number_of_experiments = self.getnumberofexperiments()

        # Get a list of the number of detectors for each experiment.
        numbers_of_detectors = self.get_numbers_of_detectors()


        for experiment_number in range(number_of_experiments):
            gosia_experiment_number = experiment_number + 1
            target_thickness = self.allexperiments[experiment_number].get_parameter("target_thickness")
            A_target = self.allexperiments[experiment_number].A_target()
            for detector_number in range(numbers_of_detectors[experiment_number]):
                # Get a description of this experiment and Ge detector for output.
                experiment_line = "\nExperiment " + str(experiment_number + 1)
                #experiment_description = self.allexperiments[experiment_number].short_description()
                experiment_description = self.allexperiments[experiment_number].long_description()
                detector_line   = "Detector " + str(detector_number + 1)
                detector_description   = self.allexperiments[experiment_number].Ge_detectors[detector_number].short_description() # summed DOmega for clusters; single-crystal DOmega for individual crystals
                # Add this description to the output and text file lines.
                
                lines_to_write.append(experiment_line + "\n")
                all_table_lines.append(experiment_line)

                for line in experiment_description:
                    lines_to_write.append(line + "\n")
                    all_table_lines.append(line)

                lines_to_write.append(detector_line + "\n")
                all_table_lines.append(detector_line)

                lines_to_write.append(detector_description + "\n")
                all_table_lines.append(detector_description)

                total_detector_solid_angle = self.allexperiments[experiment_number].Ge_detectors[detector_number].return_solid_angle() # summed DOmega for clusters; single-crystal DOmega for individual crystals

                # Get the crystal or cluster identity.  This is important for the solid angle correction THAT GOSIA WANTS.
                # Handling crystals or clusters differently (June 16 2011).
                # Gosia wants the total relative-efficiency-corrected yield
                # divided by the solid angle of ONE CRYSTAL, even if the data
                # are for a cluster of more than one crystal.
                is_cluster = self.allexperiments[experiment_number].Ge_detectors[detector_number].get_detector_information("is_cluster")
                if is_cluster:
                    # Get the list of types.  (This uses arbitrarily crystal 0 in the cluster.  Different types in a cluster may be disallowed soon.)
                    cluster_types = self.allexperiments[experiment_number].Ge_detectors[detector_number].get_detector_information("types")
                    crystal_solid_angle = the_detector_manager.get_detector_solid_angle(cluster_types[0])
                else:
                    # This detector is a single Ge crystal or a simulated summed 4pi array.
                    crystal_type = self.allexperiments[experiment_number].Ge_detectors[detector_number].get_detector_information("type")
                    crystal_solid_angle = the_detector_manager.get_detector_solid_angle(crystal_type)

                # This data_set_number will correspond to a single Ge detector until it is
                # made more general to handle clusters, etc.
                gosia_data_set_number = detector_number + 1
                # Generate a header for this data set
                ZP = 1
                AP = 1
                EP = 1
                # Get the yields for this detector.  (These are integrated (calculated) yields in memory!)
                try:
                    one_data_set_yields = self.allexperiments[experiment_number].get_calculated_yields(detector_number)
                except:
                    print "No data.  You should re-calculate the simulated yields."
                    break
                # Step through all integrated yields, adding an error bar for each.
                temporary_yld_file_lines = []

                # Add a header for the this detector and experiment.
                for line in header_lines:
                    lines_to_write.append(line + "\n")
                    all_table_lines.append(line)

                # Create the table sorting dictionary for this detector.
                table_sorting_dict = {}

                for yield_number in range(len(one_data_set_yields)):
                    # August 15 2011: Updating for the new storage and return format of calculated yields in the detector objects.
                    # e.g. one_data_set_yields[yield_number] = ['gam', 4.0, 'gsb', 6.0, 0.019873999999999999]
                    #initial_level,final_level,intensity, normalized_intensity = one_data_set_yields[yield_number]
                    initial_band_name,initial_spin,final_band_name,final_spin,intensity = one_data_set_yields[yield_number]
                    gosia_initial_level = investigated_nucleus.lookup_gosia_level_by_band_spin(initial_band_name,initial_spin)
                    gosia_final_level   = investigated_nucleus.lookup_gosia_level_by_band_spin(final_band_name,final_spin)
                    # Form level keys to lookup energies.
                    initial_level_key   = (initial_band_name, initial_spin)
                    final_level_key     = (final_band_name, final_spin)
                    initial_energy      = investigated_nucleus.get_level_information(initial_level_key,"energy")  # Energy in keV
                    final_energy        = investigated_nucleus.get_level_information(final_level_key,"energy")  # Energy in keV
                    gamma_energy = initial_energy - final_energy

                    # The efficiency user's specified gamma energy threshold is checked:
                    if gamma_energy < gamma_energy_threshold:
                        gamma_energy_too_low = True
                    else:
                        gamma_energy_too_low = False

                    if not gamma_energy_too_low:
                        # Get an absolute efficiency by the standard
                        # definition.  If None is returned, then it could not
                        # be calculated or came out 0 or negative using the
                        # user's parameters at this energy.
                        absolute_efficiency = self.allexperiments[experiment_number].Ge_detectors[detector_number].return_absolute_efficiency(gamma_energy) 
                        if absolute_efficiency == None:
                            good_efficiency = False
                        else:
                            good_efficiency = True

                        # Now we can estimate the total counts expected from the
                        # absolute efficiency.

                        # Note that the crystal solid angle of ONE CRYSTAL is used
                        # in calculating the absolute counts to match Gosia's
                        # output and expected data, even if this is a cluster.
                        # (Gosia gives yield/DOmega, DOmega for a single crystal.)
                        if good_efficiency:
                            if is_cluster:
                                # Cluster detector
                                estimated_count = standard_p_gamma_events(beam_intensity,days_of_beam,A_target,intensity,absolute_efficiency) \
                                  * crystal_solid_angle / total_detector_solid_angle 
                            else:
                                # Single crystal or 4pi single crystal
                                estimated_count = standard_p_gamma_events(beam_intensity,days_of_beam,A_target,intensity,absolute_efficiency)
                            # Get the raw count rate in Hz:
                            time_in_seconds = 3600. * 24. * days_of_beam
                            raw_count_rate = (estimated_count / time_in_seconds) # Hertz
                            estimated_count_error = math.sqrt(estimated_count)
                            # Calculate the fraction of incident gammas
                            # detected.  This is what I used to call the
                            # "intrinsic efficiency."
                            fraction_detected = 4. * math.pi * absolute_efficiency / total_detector_solid_angle

                            efficiency_corrected_count = estimated_count / fraction_detected 
                            estimated_error = (estimated_count_error / estimated_count) * efficiency_corrected_count
                            estimated_error = efficiency_corrected_count * math.sqrt(estimated_additional_error**2 + (estimated_error/efficiency_corrected_count)**2)

                            if estimated_count > minimum_counts:
                                # Only keep the data point if there are at least minimum_counts counts.
                                if add_scatter:
                                    # Add Gaussian scatter to the simulated yield:
                                    scattered_efficiency_corrected_count = random.gauss(efficiency_corrected_count, estimated_error)
                                    # Update the estimated error to scale with the scattered yield.
                                    estimated_error = (scattered_efficiency_corrected_count / efficiency_corrected_count) * estimated_error
                                    efficiency_corrected_count = scattered_efficiency_corrected_count 

                                # In case different Ge detectors have different solid
                                # angles, the simulated measured yields need to be
                                # divided by the Ge solid angle to be understood by
                                # Gosia.  These should be read back in from the
                                # gosia.yld file to ensure that what Gosia gets is the
                                # same as what is in memory!  We can multiply by an
                                # arbitrary scaling factor.  These are multiplied by
                                # 4pi, so that counts don't round to 0.  (The overall
                                # normalization is not important to gosia.)

                                # Note that Gosia wants something proportional
                                # to counts per unit solid angle for a single
                                # crystal and counts per unit solid angle of a
                                # single crystal for a cluster.

                                #gosia_yield           = int(round(4. * math.pi * efficiency_corrected_count / crystal_solid_angle))
                                #gosia_estimated_error = int(round(4. * math.pi * estimated_error / crystal_solid_angle))
                                # September 2011.  Removing the rounding
                                # function.  The lower limit specified by the
                                # user will eliminate data for counts which are
                                # too weak to be measured.
                                gosia_yield           = efficiency_corrected_count / crystal_solid_angle
                                gosia_estimated_error = estimated_error / crystal_solid_angle

                                # Add the entry for the gosia yld file.
                                yield_entry = str(gosia_initial_level) + "  " + str(gosia_final_level) + "  " + str(gosia_yield) \
                                  + "  " + str(gosia_estimated_error) 
                                temporary_yld_file_lines.append(yield_entry)

                                # Add this entry to be printed in the table for the
                                # user.  This is done with a sorting dictionary, so
                                # that they can be displayed in order of increasing
                                # initial and final level number.

                                # The following constructs a new formatted table entry for the release version.
                                transition_string          = initial_band_name.rjust(8) + " " +  str(initial_spin).rjust(4) + " " \
                                  +  final_band_name.rjust(8) + " " +  str(final_spin).rjust(4) 
                                corrected_count_string     = format(efficiency_corrected_count,".3e").ljust(9) + "  " + format(estimated_error,".3e").ljust(9)
                                gamma_energy_string        = str(round(gamma_energy,1)).rjust(6) 
                                standard_efficiency_string = str(round(absolute_efficiency,5)).ljust(7)
                                fraction_detected_string   = str(round(fraction_detected,5)).ljust(7) 
                                raw_rate_string            = format(raw_count_rate,".3e").ljust(9) 
                                raw_count_string           = format(estimated_count,".3e").ljust(9) + "  " + format(estimated_count_error,".3e").ljust(9) 

                                formatted_table_entry =   transition_string          + 5 * " " \
                                                        + corrected_count_string     + 4 * " " \
                                                        + gamma_energy_string        + 2 * " " \
                                                        + standard_efficiency_string + 5 * " " \
                                                        + fraction_detected_string   + 7 * " " \
                                                        + raw_rate_string            + 2 * " " \
                                                        + raw_count_string

                                table_key = (gosia_initial_level,gosia_final_level)

                                #table_sorting_dict[table_key] = this_table_entry
                                table_sorting_dict[table_key] = formatted_table_entry

                # Print the table entries in sorted order.
                all_table_keys = table_sorting_dict.keys()
                all_table_keys.sort()
                for table_key in all_table_keys:
                    lines_to_write.append(table_sorting_dict[table_key] + "\n")
                    all_table_lines.append(table_sorting_dict[table_key])

                # Sort the yield file lines for the Gosia file.
                temporary_yld_file_lines.sort()

                # Get the number of yields in this data set to make the proper header.
                number_of_observable_yields = len(temporary_yld_file_lines)  # for this data set in this experiment

                # Get the requested weight for this detector's experimental data.
                WT = self.allexperiments[experiment_number].Ge_detectors[detector_number].return_data_weight()

                # Construct the data set header for the gosia yld file.
                data_set_header = str(gosia_experiment_number) + "  " + str(gosia_data_set_number) \
                  + "  " + str(ZP) + "  " + str(AP) + "  " + str(EP) + "  " + str(number_of_observable_yields) \
                  + "  " + str(WT) 
                yld_file_lines.append(data_set_header)
                yld_file_lines.extend(temporary_yld_file_lines)

        notes = block_print_with_line_breaks("\nNotes:\nGosia has calculated the cross section for events in which the detected ion hit the particle detector and the gamma ray was incident in the solid angle of the Ge detector.\nThe simulated \"Gammas incident on Ge detectors\" above are equivalent to \"Observed counts\" in the data stream with appropriate efficiency correction factors, which are found in the column \"Fraction of incident gammas detected.\"  That is, the incident gammas represent absolute efficiency-corrected data.\nAny arbitrary overall normalization for all of the gamma-ray yields sent to Gosia is acceptable.  If all of the Ge detectors have equal solid angles, no other corrections are needed.  However, for the general case of Ge detectors of differing solid angles, an additional factor of 1/Delta_Omega_Ge is required, since Gosia calculates the cross section per unit Ge solid angle [mb*(mg/cm^2)/sr], where the steradian unit refers to the solid angle of the Ge detector for a single crystal, or the solid angle of ONE MEMBER of a cluster.\nThe simulated \"corrected\" yields were sent to Gosia *.yld file with an additional factor of 1 / Delta_Omega_Ge.\n*The total error in the incident counts includes any \"additional error\" specified in the prompts above.\n**This is the usual measure of efficiency, defined as 1 for a 4pi blackbody.  The efficiency curves can be changed using the \"Tools\" button option \"ef.\"\n***The error in the raw \"Observed counts\" represents only the sqrt(N) counting error.",79,True)

        # Give the output to the text file.
        for line in notes:
            all_table_lines.append(line)
            lines_to_write.append(line + "\n")

        # Give the output to the terminal.
        for line in all_table_lines:
            print line
        block_print_with_line_breaks("\nThe table above has been saved to the file \"rachel_simulated_yield_table.txt\".\n  Yields will also be written to the gosia.yld file and re-read to check for errors.")

        with open("rachel_simulated_yield_table.txt","w") as table_file:
            table_file.writelines(lines_to_write)

        # Add one blank line to the end of the gosia yield file.
        yld_file_lines.append(" ")

        # Define the file name to be written.
        gosia_file_number = 3
        gosia_yld_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[3]["extension"]
        
        # Write the yields to the file
        write_lines_to_file(gosia_yld_file_name,yld_file_lines,force_write)

        return yld_file_lines
                
                
class logical_detector:
    """Each object of this class is a logical detector attached to an experiment.

    It contains the position information, the physical detector type and the
    calculated and measured yields for this detector in the experiment that
    contains it.  

    When a data file is read, a flag is set to indicate that it contains "real"
    data.  In this case, the entire set of lines read from the file is stored,
    as well as the file name.  This allows the GUI to re-process the
    experimental data to select what is sent to the yield file for gosia,
    whenever a change is made to the matrix or some other parameter(s) that
    affect the data selection.

    It is expected that a cluster will be an object of a class derived from
    this one with some inherited data and some additional data.

    """

    def __init__(self,parameter_dict):
        """The parameter_dict contains the following items:

        detector_type_number     the physical type of the detector
        theta                    the polar angle coordinate in the lab (deg)
        phi                      the azimuthal angle coordinate in the lab (deg)

        If there is an item "yield_data_file," then it will be stored and used
        to "auto-load" data.

        This init method may call a pop-up file browser to ask for the data
        file, or it might be done later.

        """

        # Store the creation parameter dict
        self.creation_parameter_dict = copy.deepcopy(parameter_dict)  # Added deepcopy on June 13 2011, because data are volatile.

        # To make upgrading easier, if we decide to name the detectors, we create a name field.  This will be left to a null string for now.
        self.logical_detector_name = ""

        # Extract the common data that all detector objects must have
        self.detector_type = self.creation_parameter_dict["detector_type_number"]
        self.theta         = self.creation_parameter_dict["theta"]
        self.phi           = self.creation_parameter_dict["phi"]
        self.identity      = "crystal"   # This can be returned so that calling methods can know that it is a crystal, not a cluster.

        # Save the yield data file name, or a flag None to indicate that data can't be auto-loaded.
        if "yield_data_file_name" in self.creation_parameter_dict.keys() and "yield_data_file_name" in self.creation_parameter_dict.keys():
            # Save the file name for auto-loading.
            self.yield_data_file_name = self.creation_parameter_dict["yield_data_file_name"]
            self.yield_data_file_type = self.creation_parameter_dict["yield_data_file_type"]
        else:
            self.yield_data_file_name = None  # This will serve as a flag that data cannot be auto-loaded.
            self.yield_data_file_type = None  # This will serve as a flag that data cannot be auto-loaded.
            

        # Create empty dictionaries for all calculated and measured yield data.
        # This new dictionary format will allow quick lookup of individual
        # yields, as well as sorting by the transition tuple keys.

        # Yields will fill the dictionary in this format.  
        # {("gsb",2.0,"gsb",0.0):{"calculated yield":###,"measured yield":###,"error":###},...}
        #  tuple describing transition : {dictionary of calculated and/or measured yield}

        # Deleting yield data (calculated or measured) will require deleting
        # either the "calculated yield" key or both the "measured yield" and
        # "error" keys from the nested dictionary for that transition.  If both
        # the calculated and measured yields are deleted, then the transition
        # key should be removed from the outer dictionary.

        # We can keep all yields, whether they apply to the levels in memory
        # or not.  This means that we can keep all data and use only what
        # applies to the current levels and matrix.  Deleting bands does not
        # require deleting the yield data--only excluding those data from fits
        # and plots.

        self.yield_data = {}

        # The data weight for this detector in the experiment to which it is
        # attached:
        if "data_weight" in self.creation_parameter_dict.keys():
            self.data_weight = self.creation_parameter_dict["data_weight"]
        else:
            self.data_weight = 1.0

        # The normalization constant for this detector's data.
        # attached:
        if "normalization_constant" in self.creation_parameter_dict.keys():
            self.normalization_constant = self.creation_parameter_dict["normalization_constant"]
        else:
            self.normalization_constant = 1.0

    def short_description(self):
        """Returns a short line of text describing the experiment.

        """

        if self.get_detector_information("is_crystal"):
            crystal = "Single crystal at "
        else:
            crystal = "Cluster at "
        theta = "theta, phi = " + format(self.get_detector_information("theta"),".1f") + ", " + format(self.get_detector_information("phi"),".1f") + " deg. "
        solid_angle = "Solid angle = " + format(self.get_detector_information("solid_angle"),".2f") + " sr."

        description = crystal + theta + solid_angle 

        return description

    def set_to_auto_load(self, yield_data_file_type=None, yield_data_file_name = None):
        """Sets this detector to auto-load from the specified file and file type.

        """

        if not None in [yield_data_file_type, yield_data_file_name]:
            self.yield_data_file_type = yield_data_file_type
            self.yield_data_file_name = yield_data_file_name
            return 0
        else:
            # Auto-load file type or name was not defined.
            return -1

    def can_auto_load_data(self):
        """Returns True if the object knows what file contains data to load.

        Otherwise, returns False.

        """

        if self.yield_data_file_name == None:
            return False
        else:
            return True


    def return_type_number(self):
        """Returns the internal type number (base 0)

        """

        return self.detector_type

    def return_absolute_efficiency(self,energy_keV):
        """Returns the absolute efficiency for this logical detector.

        Clusters will have a different method by the same name.

        This is used for simulations only.

        """

        # Get the absolute efficiency for this gamma energy and crystal type from the detector manager.
        absolute_efficiency = the_detector_manager.alldetectors[self.detector_type].absolute_efficiency(energy_keV)
        return absolute_efficiency

    def return_mean_theta(self):
        return self.theta

    def return_mean_phi(self):
        return self.phi

    def return_solid_angle(self):
        return the_detector_manager.get_detector_solid_angle(self.detector_type)

    def identify_crystal_or_cluster(self):
        """Returns "crystal", so that calling functions know what this detector is.

        The cluster class will return "cluster" to distinguish from individual
        crystals.

        """

        return self.identity


    def get_detector_information(self,what):
        """Returns the quantity specified by 'what'.

        what can be a string:
            "theta"                 - polar angle position in degrees 
            "phi"                   - azimuthal angle position in degrees 
            "type"                  - the physical detector type
            "identity"              - "crystal"  (really the string in self.identity)
            "is_cluster"            - False
            "is_crystal"            - True
            "solid_angle"           - the solid angle in sr
            "can_auto_load"         - returns True if the file name for yield data is known.
            "yield_data_file_name"  - Returns the yield data file name if it exists
            "yield_data_file_type"  - Currently returns either "ags" or "txt" (latter is Rachel format)
        
        Checks that the desired information is appropriate for a crystal and if so returns it.

        """

        if what == "theta":
            return self.theta

        elif what == "phi":
            return self.phi

        elif what == "identity":
            return self.identity

        elif what == "is_cluster":
            return False

        elif what == "type":
            return self.detector_type

        elif what == "is_crystal":
            return True 

        elif what == "solid_angle":
            solid_angle = self.return_solid_angle()
            return solid_angle

        elif what == "can_auto_load":
            return self.can_auto_load_data()

        elif what == "yield_data_file_name":
            try:
                self.yield_data_file_name 
            except:
                return None

            return self.yield_data_file_name 

        elif what == "yield_data_file_type":
            try:
                self.yield_data_file_type
            except:
                return None

            return self.yield_data_file_type

        else:
            return None  # Error condition--desired information is inappropriate for a crystal



    def set_normalization_constant(self,new_normalization_constant):
        """Sets the new (float) normalization constant for this detector.

        This is YNRM in gosia terms.

        """

        self.normalization_constant = new_normalization_constant
        return 0

    def return_normalization_constant(self):
        """Returns the normalization constant for this detector's data.

        This is not calculated here, but is passed in or defaults to 1, when
        the logical detector object is created.

        """

        return self.normalization_constant

    def return_data_weight(self):
        """Returns the data weight for this detector's data.

        This is passed in or defaults to 1, when the logical detector object is
        created.

        """

        return self.data_weight

    def set_experimental_yields(self,yield_list):
        """Zeroes the experimental yields and replaces them with the ones in the list passed.

        The format is [[initial_band_name, initial_spin, final_band_name, final_spin, measured_yield, error],["],...]

        """

        # Zero the experimental yields:
        self.zero_experimental_yields()

        # Loop over the yields in the list passed in, copying them to the
        # internal dictionary format.  
        
        # We can keep all yields, whether they apply to the levels in memory
        # or not.  This means that we can keep all data and use only what
        # applies to the current levels and matrix.  Deleting bands does not
        # require deleting the yield data--only excluding those data from fits
        # and plots.

        for one_yield_entry in yield_list:

            # We make a deepcopy of this yield entry in the list passed in.
            # This ensures that pointers are not made to the volatile list
            # passed in.
            initial_band_name, initial_spin, final_band_name, final_spin, measured_yield, error = copy.deepcopy(one_yield_entry)

            # The transition key is formed as a tuple for the yield_data dictionary.
            transition_key = (initial_band_name, initial_spin, final_band_name, final_spin)

            # Get the yield dictionary nested in the yield_data dictionary.
            # This nested dictionary has the form
            # {"calculated yield":###,"measured yield":###,"error":###}
            # with possibly all three keys missing from the dictionary.
            # If the key does not exist, it will be added.
            if not transition_key in self.yield_data.keys():
                # Add the transition key.
                self.yield_data[transition_key] = {}  # the nested dictionary is created.

            # Add the experimental yield to the nested dictionary.
            self.yield_data[transition_key]["measured yield"] = measured_yield
            self.yield_data[transition_key]["error"]          = error

        return 0

    def return_experimental_yields(self):
        """Returns a list of all experimental yields.

        This is actually a list of lists:
        [[initial_band_name, initial_spin, final_band_name, final_spin, measured_yield, error],["],...]

        Only transitions with a measured yield point are returned, so that
        there is less work in evaluating each entry by the calling method.

        If there are no experimental yields in memory, an empty list is returned.

        """

        experimental_yields = []

        # Cycle through all transitions in memory.  Each one with a measured
        # experimental yield is added to this newly-formatted list of lists.
        # (See format above.)
        for transition_key in self.yield_data.keys():
            # See if this transition has a measured yield (and error).
            if "measured yield" in self.yield_data[transition_key].keys():
                # Get the measured yield and its error.
                measured_yield = self.yield_data[transition_key]["measured yield"]
                error          = self.yield_data[transition_key]["error"]
                # Get the transition identity in terms of band names and spins,
                # and assemble this yield entry for the returned list.
                initial_band_name, initial_spin, final_band_name, final_spin = transition_key
                this_yield_entry = [initial_band_name, initial_spin, final_band_name, final_spin, measured_yield, error]
                # Add this yield entry to the list.
                experimental_yields.append(this_yield_entry)

        return experimental_yields

    def zero_experimental_yields(self):
        """Removes all experimental yields and errors.

        """

        for transition_key in self.yield_data.keys():
            # Get the nested dictionary that represents the yield data for this transition.
            yield_entry = self.yield_data[transition_key]
            # If the transition has a calculated yield, delete it.  (Deleting a
            # non-existent key raises an exception.)
            if "measured yield" in yield_entry.keys():
                del self.yield_data[transition_key]["measured yield"]
                # Measured yields should always have errors.  If this throws an exception, then it is a bug.
                del self.yield_data[transition_key]["error"]

        return 0

    def zero_calculated_yields(self):
        """Removes all calculated yields.

        """

        for transition_key in self.yield_data.keys():
            # Get the nested dictionary that represents the yield data for this transition.
            yield_entry = self.yield_data[transition_key]
            # If the transition has a calculated yield, delete it.  (Deleting a
            # non-existent key raises an exception.)
            if "calculated yield" in yield_entry.keys():
                del self.yield_data[transition_key]["calculated yield"]

        return 0
                


    def set_calculated_yields(self,yield_list):
        """Zeroes the calculated yields and then replaces them with new calculated yields.

        The format is [[initial_band_name, initial_spin, final_band_number, final_spin, calculated_yield],["],...]

        NOTE: The self-normalized yield has fallen out of use, and is now deprecated.  

        """


        # Zero the calculated yields:
        self.zero_calculated_yields()

        # Loop over the yields in the list passed in, copying them to the
        # internal dictionary format.  
        
        # We can keep all yields, whether they apply to the levels in memory
        # or not.  This means that we can keep all data and use only what
        # applies to the current levels and matrix.  Deleting bands does not
        # require deleting the yield data--only excluding those data from fits
        # and plots.

        for one_yield_entry in yield_list:

            # We make a deepcopy of this yield entry in the list passed in.
            # This ensures that pointers are not made to the volatile list
            # passed in.
            initial_band_name, initial_spin, final_band_name, final_spin, calculated_yield = copy.deepcopy(one_yield_entry)

            # The transition key is formed as a tuple for the yield_data dictionary.
            transition_key = (initial_band_name, initial_spin, final_band_name, final_spin)

            # Get the yield dictionary nested in the yield_data dictionary.
            # This nested dictionary has the form
            # {"calculated yield":###,"measured yield":###,"error":###}
            # with possibly all three keys missing from the dictionary.
            # If the key does not exist, it will be added.
            if not transition_key in self.yield_data.keys():
                # Add the transition key.
                self.yield_data[transition_key] = {}  # the nested dictionary is created.

            # Add the experimental yield to the nested dictionary.
            self.yield_data[transition_key]["calculated yield"] = calculated_yield

        return 0

    def return_calculated_yields(self):
        """Returns a list of all experimental yields.

        This is actually a list of lists:
        [[initial_band_name, initial_spin, final_band_number, final_spin, measured_yield, error],["],...]

        Only transitions with a measured yield point are returned, so that
        there is less work in evaluating each entry by the calling method.

        If there are no experimental yields in memory, an empty list is returned.

        """

        calculated_yields = []

        # Cycle through all transitions in memory.  Each one with a calculated
        # yield is added to this newly-formatted list of lists.  (See format
        # above.)

        for transition_key in self.yield_data.keys():
            # See if this transition has a calculated yield.
            if "calculated yield" in self.yield_data[transition_key].keys():
                # Get the calculated yield from the nested dictionary.
                calculated_yield = self.yield_data[transition_key]["calculated yield"]
                # Get the transition identity in terms of band names and spins,
                # and assemble this yield entry for the returned list.
                initial_band_name, initial_spin, final_band_name, final_spin = transition_key
                this_yield_entry = [initial_band_name, initial_spin, final_band_name, final_spin, calculated_yield]
                # Add this yield entry to the list.
                calculated_yields.append(this_yield_entry)

        return calculated_yields

class cluster_detector(logical_detector):
    """Each object of this class is a cluster detector attached to an experiment.

    This class now inherits from the class logical_detector.  Refer to that
    class definition for more information.

    Be careful when using accessor methods to check whether you are looking at
    a cluster or a single-crystal detector.  Some inherited methods may not
    apply, and identity checks have not been added yet to the inherited
    methods.

    This corresponds to creating a "raw" cluster in Gosia, except that the GUI
    will still require all data to be efficiency-corrected, so the efficiency
    parameters returned will correspond to a constant efficiency for every
    detector in the cluster.

    It contains the position information, the physical detector type and the
    calculated and measured yields for each detector in the cluster.

    """

    def __init__(self,parameter_dict):
        """The parameter_dict contains the following items:

        detector_type_numbers    a list of the physical type of the detector (one for each detector)
        thetas                   a list of the polar angle coordinates in the lab (deg) (one for each detector)
        phis                     a list of the azimuthal angle coordinates in the lab (deg) (one for each detector)

        If there is an item "yield_data_file," then it will be stored and used
        to "auto-load" data.

        """

        # Store the creation parameter dict
        self.creation_parameter_dict = copy.deepcopy(parameter_dict)  # Added deepcopy on June 13 2011, because data are volatile.

        # To make upgrading easier, if we decide to name the detectors, we create a name field.  This will be left to a null string for now.
        self.logical_detector_name = ""

        # Copy the crystal types, theta and phi values from the creation
        # dictionary.  This uses deepcopy because of the nested list in
        # dictionary structure.
        self.detector_type_numbers = copy.deepcopy(self.creation_parameter_dict["detector_type_numbers"])
        self.thetas                = copy.deepcopy(self.creation_parameter_dict["thetas"])
        self.phis                  = copy.deepcopy(self.creation_parameter_dict["phis"])
        self.identity      = "cluster"   # This can be returned so that calling methods can know that it is a cluster, not a crystal.

        # Save the yield data file name, or a flag None to indicate that data can't be auto-loaded.
        if "yield_data_file_name" in self.creation_parameter_dict.keys() and "yield_data_file_name" in self.creation_parameter_dict.keys():
            # Save the file name for auto-loading.
            self.yield_data_file_name = self.creation_parameter_dict["yield_data_file_name"]
            self.yield_data_file_type = self.creation_parameter_dict["yield_data_file_type"]
        else:
            self.yield_data_file_name = None  # This will serve as a flag that data cannot be auto-loaded.
            self.yield_data_file_type = None  # This will serve as a flag that data cannot be auto-loaded.
            

        # Create empty dictionaries for all calculated and measured yield data.
        # This new dictionary format will allow quick lookup of individual
        # yields, as well as sorting by the transition tuple keys.

        # Yields will fill the dictionary in this format.  
        # {("gsb",2.0,"gsb",0.0):{"calculated yield":###,"measured yield":###,"error":###},...}
        #  tuple describing transition : {dictionary of calculated and/or measured yield}

        # Deleting yield data (calculated or measured) will require deleting
        # either the "calculated yield" key or both the "measured yield" and
        # "error" keys from the nested dictionary for that transition.  If both
        # the calculated and measured yields are deleted, then the transition
        # key should be removed from the outer dictionary.

        # We can keep all yields, whether they apply to the levels in memory
        # or not.  This means that we can keep all data and use only what
        # applies to the current levels and matrix.  Deleting bands does not
        # require deleting the yield data--only excluding those data from fits
        # and plots.

        self.yield_data = {}

        # The data weight for this detector in the experiment to which it is
        # attached:
        if "data_weight" in self.creation_parameter_dict.keys():
            self.data_weight = self.creation_parameter_dict["data_weight"]
        else:
            self.data_weight = 1.0

        # The normalization constant for this detector's data.
        # attached:
        if "normalization_constant" in self.creation_parameter_dict.keys():
            self.normalization_constant = self.creation_parameter_dict["normalization_constant"]
        else:
            self.normalization_constant = 1.0

        # The following is particular to a cluster.  The crystal class
        # obviously has only 1 crystal.  Right now, the calling method is
        # responsible for setting the correct numbers of theta and phi values
        # and types.
        self.number_of_crystals    = len(self.detector_type_numbers)

    def return_absolute_efficiency(self,energy_keV):
        """Returns the absolute efficiency for this cluster detector.

        This is used for simulations only.

        This will use the sum of absolute efficiencies for each crystal in the
        cluster.  The appropriate efficiency is used for each crystal type.

        """

        # Step through each crystal in the cluster, getting its type and absolute efficiency.
        absolute_efficiency = 0.0
        for one_type in self.detector_type_numbers:
            # Get the absolute efficiency for this gamma energy and crystal type from the detector manager.
            absolute_efficiency += the_detector_manager.alldetectors[one_type].absolute_efficiency(energy_keV)

        return absolute_efficiency

    def return_number_of_crystals(self):
        """Returns the number of crystals in the cluster

        """

        return self.number_of_crystals

    def return_type_numbers(self):
        """Returns the internal type numbers (base 0)

        This returns a list of n type numbers, where n is the number of
        detectors in this cluster.

        """

        return self.detector_type_numbers

    def return_thetas(self):
        """Returns the polar angles of all detectors in the cluster.

        This returns a list of n polar angle coordinates, where n is the number
        of detectors in this cluster.

        """

        return self.thetas

    def return_phis(self):
        """Returns the azimuthal angles of all detectors in the cluster.

        This returns a list of n type numbers, where n is the number of
        detectors in this cluster.

        """

        return self.phis

    def return_names(self):
        """Returns a list of names of the detector types in the crystal.

        These are returned in the order of the crystals in the cluster.

        """

        list_of_names = []
        for one_internal_type_number in self.detector_type_numbers:
            list_of_names.append(the_detector_manager.get_type_name(one_internal_type_number))

        return list_of_names

    def return_mean_theta(self):
        """Returns the average of the thetas, not the true integrated mean.

        """
        try:
            # Test whether the mean theta angle has been calculated.
            self.mean_theta
            return self.mean_theta
        except:
            # The mean theta angle has not been calculated yet.


            i = 0
            summed_theta = 0.
            for one_theta in self.thetas:
                summed_theta += one_theta
                i += 1
            # Store the mean theta angle so it only has to be calculated once.
            self.mean_theta = summed_theta / float(i)
            return self.mean_theta

    def return_mean_phi(self):
        """Returns the average of the phis, not the true integrated mean.

        Since this is only used in plotting, the mean angle can be calculated
        +/- 360 degrees.  The returned mean is calculated by adding 360 degrees
        as necessary to each member's phi angle, so that the mean is as near to
        the members' phis as possible.  This makes plots look more sensible for
        clusters that cross 360 degrees.

        """
        try:
            # Test whether the mean phi angle has been calculated.
            self.mean_phi
            return self.mean_phi
        except:
            # The mean phi angle has not been calculated yet.

            # If the cluster phi angle (azimuthal) crosses 360 degrees, then we
            # need to add 360 degrees to the positions of all detectors whose
            # phi is nearer to 0 degrees.  This can be done in every case, if
            # we then subtract 360 degrees from the mean repeatedly until the
            # mean is between 0 and 360 degrees.

            # First, see if this is necessary by finding if there are any pair
            # of detectors that are separated by more than 180 degrees in phi.

            # Get a list of all detector indices for phi values that are more
            # than 180 smaller than any other phi.
            phis_to_shift = []
            for i in range(len(self.phis) - 1):
                for j in range(1, len(self.phis)):
                    # If there is a gap of more than 180 degrees between any
                    # two detectors, make a note to shift the smaller angle up
                    # by 360 degrees by storing its index in "phis_to_shift."
                    if (self.phis[i] - self.phis[j]) > 180.0:
                        phis_to_shift.append(j)
                    elif (self.phis[j] - self.phis[i]) > 180.0:
                        phis_to_shift.append(i)

            temporary_phis = []
            for i in range(len(self.phis)):
                if i in phis_to_shift:
                    temporary_phis.append(self.phis[i] + 360.)
                else:
                    temporary_phis.append(self.phis[i])

            i = 0
            summed_phi = 0.
            for one_phi in temporary_phis:
                summed_phi += one_phi
                i += 1

            # Store the mean phi angle so it only has to be calculated once.
            self.mean_phi = summed_phi / float(i)

            # Subtract off 360 degrees until the mean phi angle is less than
            # 360.
            while self.mean_phi > 360.:
                self.mean_phi = self.mean_phi - 360.

            return self.mean_phi

    def return_solid_angles(self):
        """Returns a LIST OF SOLID ANGLES, one for each detector in the cluster.

        """

        list_of_solid_angles = []
        for this_type_number in self.detector_type_numbers:
            list_of_solid_angles.append(the_detector_manager.get_detector_solid_angle(this_type_number))
        return list_of_solid_angles

    def return_solid_angle(self):
        """Returns the TOTAL solid angle of all crystals in the cluster.

        """

        # If the total solid angle has already been calculated and stored, just
        # return the stored value.
        try:
            self.total_solid_angle
            return self.total_solid_angle
        except:
            # The total solid angle has not been stored.  Calculate, store and return it.
            list_of_solid_angles = self.return_solid_angles()
            self.total_solid_angle = 0.
            for one_solid_angle in list_of_solid_angles:
                self.total_solid_angle += one_solid_angle
            return self.total_solid_angle


    def get_detector_information(self,what):
        """Returns the quantity specified by 'what'.

        what can be a string:
            "theta"                 - average polar angle in degrees (just arithmetic average of all mean theta positions)
            "phi"                   - average azimuthal angle in degrees (just arithmetic average of all mean phi positions)
            "number_of_crystals"    - number of individual logical detectors in this cluster
            "thetas"                - the complete list of theta values for the individual crystals in the cluster
            "phis"                  - the complete list of phi values for the individual crystals in the cluster
            "types"                 - the complete list of *physical* Ge type numbers 
            "identity"              - "cluster"  (really the string in self.identity)
            "is_cluster"            - True
            "is_crystal"            - False
            "solid_angle"           - the solid angle in sr
            "can_auto_load"         - Returns True if the experimental yield data file was stored for auto-loading.
            "yield_data_file_name"  - Returns the yield data file name if it exists
            "yield_data_file_type"  - Currently returns either "ags" or "txt" (latter is Rachel format)
        
        Checks that the desired information is appropriate for a cluster and if so returns it.

        """

        if what == "theta":
            return self.return_mean_theta()

        elif what == "phi":
            return self.return_mean_phi()

        elif what == "number_of_crystals":
            return self.number_of_crystals

        elif what == "thetas":
            return self.thetas

        elif what == "phis":
            return self.phis

        elif what == "types":
            return self.detector_type_numbers 

        elif what == "identity":
            return self.identity

        elif what == "is_cluster":
            return True

        elif what == "is_crystal":
            return False

        elif what == "solid_angle":
            solid_angle = self.return_solid_angle()
            return solid_angle

        elif what == "can_auto_load":
            return self.can_auto_load_data()

        elif what == "yield_data_file_name":
            try:
                self.yield_data_file_name 
            except:
                return None

            return self.yield_data_file_name 

        elif what == "yield_data_file_type":
            try:
                self.yield_data_file_type
            except:
                return None

            return self.yield_data_file_type

        else:
            return None  # Error condition--desired information is inappropriate for a cluster



class experiment:
    """Each object of this class contains information about one experiment.

    One object of class "experimentmanager" will manage all instances of
    experiment.
 
    This will include beam/target information, scattering angle, accuracy controls,
    normalization to other experiments, gamma detectors setup, particle detector setup
    (including pin diode, circular detector, etc.) and desires about integration meshpoints.
    Generally, it's probably better to let the code set up the meshpoints, etc. by a simple 
    algorithm and assuming splines.

    I think it should be created in a list of objects, so that the writeout function can easily
    poll them all and create the gosia input.

    """

    def __init__(self,parameter_dict,tf=False,Force=False):
        """Creates an experiment with all necessary parameters

        NOTE: tf IS DEPRECATED!

        The parameters are passed as a dict generally using the labels in the manual under
        EXPT OP,YIEL and OP,INTG:
        e.g. "Z_1":28,"A_1":60...
        Z_1 A_1 Z_n A_n theta_min theta_max M_c M_a IAX phi_1 phi_2 IKIN LN target_thickness
        theta_lab and E_p are calculated for EXPT automatically as the mean of min & max.
        Energy and scattering meshpoints are calculated automatically.  

        For now, the stopping powers will be generated by a call to elast (Oak Ridge).

        The final beam energy at target exit and the mean beam energy for EXPT
        are calculated using the stopping power data.

        Stopping power data are in a 2D list, where the first dimension is the projectile
        energy in MeV, and the second is the stopping power in MeV/(mg/cm^2).
        """
        if Force:
            self.parameter_dict = parameter_dict
            try:
                self.calculate_elast_stopping_powers()   # Calculate the stopping power meshpoints
            except:
                print "Error--  Possible causes:   elast not installed properly"
                print "                            elast executable not specified correctly in .rachel_setup"
                print "                            A,Z out of range for the elast tables"
                print "Calculations cannot continue."
                return -1
            self.experimentiscomplete = True
        elif not tf:
            self.experimentiscomplete = False
            self.parameter_dict = parameter_dict   # copy the passed parameters to save them
            try:
                self.calculate_elast_stopping_powers()   # Calculate the stopping power meshpoints
                # Give a popup tip about the stopping power.
            except:
                print "Error--  Possible causes:   elast not installed properly"
                print "                            elast executable not specified correctly in .rachel_setup"
                print "                            A,Z out of range for the elast tables"
                print "Calculations cannot continue."
                return -1


            # Calculate other derived parameters: mean energy and scattering angle
            self.parameter_dict["E_mean"] = (self.parameter_dict["E_beam"] + self.parameter_dict["E_exit"]) / 2.
            # This is for the detected particle in this version.
            # Is this an arbitrary-shape detector?
            if self.parameter_dict["annular"]:
                # Annulus or sector detector
                self.parameter_dict["theta_lab_mean"] = (self.parameter_dict["theta_lab_min"] + self.parameter_dict["theta_lab_max"]) / 2.
                # TESTING: Need to ask for these parameters in useful version.
                # This is taken out.  We must now go to the Gosia shell for magnetic substates.  self.parameter_dict["M_c"] = the_gosia_shell.get_number_of_magnetic_substates()
                # self.parameter_dict["M_a"] = 1
                self.Ge_detectors = []  # a list of detector types and angles to be attached later.
                self.parameter_dict["energy_subdivisions"] = DEFAULTENERGYSUBDIVISIONS 
                self.parameter_dict["theta_subdivisions"]  = DEFAULTTHETASUBDIVISIONS 
                self.parameter_dict["number_of_energy_meshpoints"] = DEFAULT_ENERGY_MESHPOINTS 
            else:
                # Arbitrarily shaped detector
                self.parameter_dict["I_ax"]          = 1
                self.parameter_dict["M_c"] = DEFAULT_MAGNETIC_SUBSTATES
                self.parameter_dict["M_a"] = 1
                self.Ge_detectors = []  # a list of detector types and angles to be attached later.
                self.parameter_dict["energy_subdivisions"] = DEFAULTENERGYSUBDIVISIONS 
                self.parameter_dict["theta_subdivisions"]  = DEFAULTTHETASUBDIVISIONS 
                self.parameter_dict["number_of_energy_meshpoints"] = DEFAULT_ENERGY_MESHPOINTS 
                self.parameter_dict["number_of_theta_meshpoints"] = DEFAULT_THETA_MESHPOINTS

            block_print_with_line_breaks("Stopping powers have been calculated automatically.  For accurate calculations, you should check these stopping powers using the button \"Stopping power\"!",60)
            # Give a popup about what to do next.
            next_step_popup = popup_tips("after_adding_experiment")
            stopping_power_popup = popup_tips("default_stopping_power")


        else:
            self.parameter_dict = parameter_dict
            try:
                self.calculate_elast_stopping_powers()   # Calculate the stopping power meshpoints
            except:
                print "Error--  Possible causes:   elast not installed properly"
                print "                            elast executable not specified correctly in .rachel_setup"
                print "                            A,Z out of range for the elast tables"
                print "Calculations cannot continue."
                return -1
            self.parameter_dict["E_mean"] = (self.parameter_dict["E_beam"] + self.parameter_dict["E_exit"]) / 2.
            self.parameter_dict["M_c"] = DEFAULT_MAGNETIC_SUBSTATES
            self.parameter_dict["M_a"] = 1
            self.parameter_dict["I_ax"] = 0
            self.parameter_dict["phi_1"] = 0
            self.parameter_dict["phi_2"] = 360
            self.experimentiscomplete = True

    def get_maximum_possible_Q_value(self):
        """Returns the physical limit to the Q-value for this experiment

        based on the exit energy from the target (beam energy - stopping loss)

        The maximum Q value is returned in keV

        """

        this_exit_energy_MeV = self.parameter_dict["E_exit"]
        projectile_mass = self.A_projectile()
        target_mass = float(self.A_target())
        maximum_possible_Q_value = maximum_excitation_energy(projectile_mass,target_mass,this_exit_energy_MeV)
        return maximum_possible_Q_value 


    def short_description(self):
        """Returns a short description of this experiment as a string.

        """

        
        if self.get_parameter("excited_target"):
            A_projectile = str(self.A_projectile())
            Z_projectile = str(self.Z_projectile())
            excited_beam_or_target = "Target excitation by Z,A = " + Z_projectile + "," + A_projectile
        else:
            A_target = str(self.A_target())
            Z_target = str(self.Z_target())
            excited_beam_or_target = "Beam excitation by Z,A = " + Z_target + "," + A_target

        energy = " at " + str(int(round(self.get_parameter("E_mean")))) + " MeV. "
        theta_mean = "Mean scattering angle = " + format(self.mean_scattering_angle(),".1f") + " deg."

        description = excited_beam_or_target + energy + theta_mean

        return description

    def long_description(self):
        """Returns a list of lines describing the experiment.

        """

        lines = []

        # Name & number of detectors.
        n_det = self.get_number_of_detectors()
        n_det_string = str(n_det) + " Ge detector"
        if not n_det == 1:
            n_det_string += "s"
            
        n_det_string += " (A cluster of crystals is counted as one detector.)"
        experiment_name_line = "Experiment \"" + self.get_name() + "\" with " + n_det_string
        lines.append(experiment_name_line)

        # Beam and target data
        thickness_string = str(self.parameter_dict["target_thickness"]) 

        investigated_string = "Z,A = " + str(investigated_nucleus.Z) + "," + str(investigated_nucleus.A)
        if self.get_parameter("excited_target"):
            A_projectile = str(self.A_projectile())
            Z_projectile = str(self.Z_projectile())
            kinematics_string = "The " + thickness_string + " mg/cm^2 " + investigated_string + " TARGET is excited by a Z,A = " + Z_projectile + "," + A_projectile + " BEAM"
        else:
            A_target = str(self.A_target())
            Z_target = str(self.Z_target())
            kinematics_string = "The " + investigated_string + " BEAM is excited by a " + thickness_string + " mg/cm^2 Z,A = " + Z_target + "," + A_target + " TARGET."

        E_beam = self.get_parameter("E_beam") 
        E_exit = self.get_parameter("E_exit") 
        E_loss = E_beam - E_exit
        energy_string = " at an initial beam energy of " + str(int(round(E_beam))) + " MeV.  The energy loss in the target is " + str(round(E_loss,1)) + " MeV."
        lines.append(kinematics_string)
        lines.append(energy_string)
        if self.is_inverse_kinematics():
            lines.append("Inverse kinematics.")
        else:
            lines.append("Normal kinematics.")

        theta_mean = "Mean scattering angle = " + format(self.mean_scattering_angle(),".1f") + " deg."

        # Particle detection angle limits.
        theta_min_string = str(round(self.get_parameter("theta_lab_min"),1))
        theta_max_string = str(round(self.get_parameter("theta_lab_max"),1))
        phi_min_string   = str(round(self.get_parameter("phi_1"),1))
        phi_max_string   = str(round(self.get_parameter("phi_2"),1))
        # Which particle is detected?
        detected_particle      = self.get_parameter("detected_particle")
        detected_particle_string = {"b":"Beam", "t":"Target"}[detected_particle]
        scattering_angle_limits = detected_particle_string + " particle detection from " + theta_min_string + " deg to " + \
                                  theta_max_string + " deg polar\n  and from " + phi_min_string + " deg to " + \
                                  phi_max_string + " deg azimuthal."

        lines.append(scattering_angle_limits)

        return lines

    def any_raw_detectors(self):
        """Returns True if any raw Ge clusters are in use; otherwise False.

        """

        for one_detector in self.Ge_detectors:
            if one_detector.get_detector_information("is_cluster"):
                return True

        # If no clusters were found, return False.
        return False



    def set_theta_subdivisions(self,subdivisions):
        """Sets the number of theta subdivisions.

        The next even number of subdivisions will be used if subdivisions is
        odd.

        """

        try:
            new_theta_subdivisions = min(int(subdivisions) + (int(subdivisions) % 2),MAXTHETASUBDIVISIONS)
            self.parameter_dict["theta_subdivisions"] = new_theta_subdivisions
            return 0
        except:
            return -1

    def get_theta_subdivisions(self):
        """Returns the present number of subdivisions in theta.

        """

        return self.parameter_dict["theta_subdivisions"]

    def set_energy_subdivisions(self,subdivisions):
        """Sets the number of energy subdivisions.

        The next even number of subdivisions will be used if subdivisions is
        odd.

        """

        try:
            new_energy_subdivisions = min(int(subdivisions) + (int(subdivisions) % 2),MAXENERGYSUBDIVISIONS)
            self.parameter_dict["energy_subdivisions"] = new_energy_subdivisions
            return 0
        except:
            return -1

    def get_energy_subdivisions(self):
        """Returns the present number of subdivisions in energy.

        """

        return self.parameter_dict["energy_subdivisions"]


    def for_debugging(self):
        """For debugging use only.

        """

        pass


    def Z_projectile(self):
        """Returns the projectile Z.

        """
        
        # Determine which is the target and which is the beam.
        if self.get_parameter("excited_target"):
            Z_projectile = self.get_parameter("Z_n")
        else:
            Z_projectile = self.get_parameter("Z_1")

        return Z_projectile

    def Z_target(self):
        """Returns the target Z.

        """
        
        # Determine which is the target and which is the beam.
        if self.get_parameter("excited_target"):
            Z_target     = self.get_parameter("Z_1")
        else:
            Z_target     = self.get_parameter("Z_n")

        return Z_target

    def A_target(self):
        """Returns the target A.

        """
        
        # Determine which is the target and which is the beam.
        if self.get_parameter("excited_target"):
            A_target     = self.get_parameter("A_1")
        else:
            A_target     = self.get_parameter("A_n")

        return A_target

    def A_projectile(self):
        """Returns the projectile A.

        """
        
        # Determine which is the target and which is the beam.
        if self.get_parameter("excited_target"):
            A_projectile = self.get_parameter("A_n")
        else:
            A_projectile = self.get_parameter("A_1")

        return A_projectile

    def get_name(self):
        """Returns the user-chosen name for this experiment

        """

        try:
            the_name = self.get_parameter("user_name")
        except:
            the_name = None

        return the_name


    def is_inverse_kinematics(self):
        """Returns True if this is an inverse kinematics experiment.

        Otherwise, returns False.

        """

        if self.parameter_dict["excited_target"]:
            target_mass = self.parameter_dict["A_1"]           # "investigated" nucleus
            beam_mass   = self.parameter_dict["A_n"]           # "investigated" nucleus
        else:
            target_mass = self.parameter_dict["A_n"]           # "uninvestigated" nucleus
            beam_mass   = self.parameter_dict["A_1"]           # "investigated" nucleus

        if beam_mass >= target_mass:
            return True
        else:
            return False


    def add_ge_detector(self,ge_detector_parameters):
        """Adds a Ge detector to this experiment.

        This now adds objects representing either a single-crystal detector or
        a cluster.

        The type number will be understood by the_detector_manager.

        """

        identity             = ge_detector_parameters["identity"]

        if identity == "crystal":
            # Add a single-crystal logical detector object.
            ge_list = self.Ge_detectors
            new_logical_detector = logical_detector(ge_detector_parameters)
            ge_list.append(new_logical_detector)
            self.Ge_detectors = ge_list
        elif identity == "cluster":
            ge_list = self.Ge_detectors
            new_cluster_detector = cluster_detector(ge_detector_parameters)
            ge_list.append(new_cluster_detector)
            self.Ge_detectors = ge_list

        return 0

    def plot_all_detectors(self):
        """Plots the positions of all detectors using gnuplot.

        """

        def put_in_range(angle,center_angle):
            """Adjusts the angle of this detector close to that of the center.

            If this detector's azimuthal angle is far from that of the mean phi
            of this cluster, it is adjusted so that the connecting lines don't
            cross the plot from ~360 to ~0.

            """
            if (angle - center_angle) > 180.:
                angle += -360.
            elif (angle - center_angle) < -180.:
                angle +=  360.

            return angle

        # Lists of legend entries and lines to write to the plot data file.
        calculated_legend = []
        lines_to_write = []
        lines_to_write.append("#Positions of detectors \n")

        # Loop over all Ge crystals and clusters to get the theta, phi
        # positions.  Types are translated to colors.
        phi_min = None
        phi_max = None
        all_detectors = self.Ge_detectors
        for internal_detector_number in range(self.get_number_of_detectors()):
            one_detector = all_detectors[internal_detector_number]
            if one_detector.get_detector_information("is_crystal"):
                # This is a single crystal.  Get the type number, theta and phi values.
                internal_type_number = one_detector.return_type_number()
                gosia_type_number    = internal_type_number + 1
                theta                = one_detector.return_mean_theta()
                phi                  = one_detector.return_mean_phi()
                # Make sure phi for a single crystal is between 0 and 360 for the plot.
                if phi == 360.0:
                    phi = 0.
                elif phi < 0.:
                    phi += 360.
                # Update the maximum and minimum phi angles for the plot.
                if phi_max == None:
                    phi_max = phi
                elif phi > phi_max:
                    phi_max = phi
                if phi_min == None:
                    phi_min = phi
                elif phi < phi_min:
                    phi_min = phi
                # Get the type name from type number.
                type_name   = the_detector_manager.get_type_name(internal_type_number)
                # Generate the line for the plot data file.
                this_text_line = str(theta) + "  " + str(phi) + "\n"
                lines_to_write.append(this_text_line)
                # Append two newlines to separate the data set.
                lines_to_write.append("\n\n")
                calculated_legend.append(str(internal_detector_number + 1))
            else:
                # This is a cluster.  Get lists of crystal type numbers, theta and phi values.
                internal_type_numbers = one_detector.return_type_numbers()
                type_names            = one_detector.return_names()
                theta_list            = one_detector.return_thetas()
                phi_list              = one_detector.return_phis()
                number_of_crystals    = one_detector.return_number_of_crystals()
                # Get the mean theta,phi position, so a line can be drawn from it to each detector in the cluster.
                mean_theta = one_detector.return_mean_theta()
                mean_phi   = one_detector.return_mean_phi()
                # phi +- 360 is an equivalent angle, but we want the equivalent
                # angle that keeps the lines connecting the cluster's crystals
                # nearby on the plot:
                mean_phi = put_in_range(mean_phi,mean_phi)
                # Get the ordering of detctors to form a simple loop with no crossing points:
                crystal_ordering_list = []
                for i in range(number_of_crystals):
                    x = theta_list[i] - mean_theta
                    phi = put_in_range(phi_list[i],mean_phi)
                    y = phi  - mean_phi
                    # Make x and y a little larger if they are near zero.
                    if abs(x) < 1.0e-3:
                        x = math.copysign(1.0e-3, x)
                    if abs(y) < 1.0e-3:
                        y = math.copysign(1.0e-3, y)
                    # Calculate the polar coordinates of this point in a plane with the mean angle at the origin.
                    if x > 0. and y > 0.:
                        theta_prime = math.atan(y/x)
                    elif x > 0. and y < 0.:
                        theta_prime = 2. * math.pi - math.atan(-y/x)
                    elif x < 0. and y > 0.:
                        theta_prime = math.pi - math.atan(-y/x)
                    elif x < 0. and y < 0.:
                        theta_prime = math.atan(y/x) + math.pi
                    crystal_ordering_list.append([theta_prime,i])
                # Sort by the relative angle in the theta-phi plane:
                crystal_ordering_list.sort()
                # Keep the angle of the first detector, so that the loop can be closed.
                first_crystal = crystal_ordering_list[0][1]
                first_phi     = phi_list[first_crystal]
                first_phi     = put_in_range(first_phi,mean_phi)
                first_theta   = theta_list[first_crystal]
                # Now add all crystals in this cluster from lowest to highest
                # relative angle, so that they can form the simplest loop
                # possible.
                for one_entry in crystal_ordering_list:
                    i = one_entry[1]  # The second field in each entry is the crystal number.
                    name  = type_names[i]
                    theta = theta_list[i]
                    phi   = phi_list[i]
                    # Make sure phi is between 0 and 360 for the plot.
                    phi = put_in_range(phi,first_phi)
                    # Update the maximum and minimum phi angles for the plot.
                    if phi_max == None:
                        phi_max = phi
                    elif phi > phi_max:
                        phi_max = phi
                    if phi_min == None:
                        phi_min = phi
                    elif phi < phi_min:
                        phi_min = phi
                    # Generate the line for the plot data file.
                    this_text_line = str(theta) + "  " + str(phi) + "\n"
                    lines_to_write.append(this_text_line)
                # Close the loop by adding the first detector again.
                this_text_line = str(first_theta) + "  " + str(first_phi) + "\n"
                lines_to_write.append(this_text_line)
                # Add the starting point again.  This will close the loop.
                this_text_line = str(first_theta) + "  " + str(first_phi) + "\n"
                lines_to_write.append(this_text_line)
                # Append two newlines to separate the data set.
                lines_to_write.append("\n\n")
                # legend entry is n(m), meaning detector n with m detectors.
                calculated_legend.append(str(internal_detector_number + 1) + "(" + str(number_of_crystals) + ")")
                
        # Write the points to a file:
        plot_data_file_name = "temporary_rachel_detectors_plot_data.txt"
        with open(plot_data_file_name,"w") as plot_data_file: 
            plot_data_file.writelines(lines_to_write)
        # Now send the plot data to gnuplot:

        # Adjust the min, max phi values in case all detectors were in the same
        # position (should only happen for one detector in the experiment).
        # This also makes the plot from 0 to 360 in phi unless detectors should
        # be drawn past those limits for clarity (so that connecting lines of
        # clusters don't criss-cross the plot.

        if phi_min > 0.:
            phi_min = 0.
        if phi_max < 360.:
            phi_max = 360.

        title_string = "Ge detectors and/or clusters"
        gnuplot_draw(plot_data_file_name = plot_data_file_name,calculated_legend = calculated_legend,x_label = "theta (deg)",y_label = "phi (deg)",title_string = title_string, withpoints=True,x_range=[0,180],y_range=[phi_min,phi_max],log_y=False)

        return 0



    def return_ge_normalizations(self):
        """Returns a list of all Ge det. normalizations (YNRM).

        """
        ge_normalization_list = []
        ge_list = self.Ge_detectors
        try:
            for one_detector in ge_list:
                this_ge_normalization = one_detector.return_normalization_constant()
                ge_normalization_list.append(this_ge_normalization)
        except:
            print "Missing Ge normalization constants for one or more detectors."
            return -1

        return ge_normalization_list

    def set_detector_normalizations_from_list(self,new_normalization_list):
        """Replaces the detector normalizations with the list passed in.

        """

        number_of_logical_detectors = len(self.Ge_detectors)
        for internal_detector_number in range(number_of_logical_detectors):
            try:
                self.Ge_detectors[internal_detector_number].set_normalization_constant(new_normalization_list[internal_detector_number])
            except:
                print "Could not set normalization: detector #",internal_detector_number + 1," does not exist."
                return -1

    def apply_factors_to_normalizations(self,factors_list,invert=False):
        """Applies the factors in the passed list to the detector normalizations.

        If invert is True, then the factors are inverted first.
        """

        print "Ge normalizations should no longer be stored in this way:"
        normalization_constant_list = self.parameter_dict["Ge Normalizations"]
        if len(normalization_constant_list) == len(factors_list):
            new_normalizations = []
            for i in range(len(normalization_constant_list)):
                if invert == False:
                    new_normalizations.append(normalization_constant_list[i] * factors_list[i])
                else:
                    new_normalizations.append(normalization_constant_list[i] / factors_list[i])
            self.parameter_dict["Ge Normalizations"] = new_normalizations
        else:
            # the number of factors was not the same as the number of constants.
            return "Error in apply_factors_to_normalizations."

    def set_detector_normalization(self,detector_number,new_normalization):
        """Sets a common normalization constant for one or all logical detectors.

        Normally, detector_number should be an integer of an existing detector,
        but if it is the string "all", then this common normalization is
        applied to all detectors for this experiment.

        """

        if detector_number == "all":
            detector_list = range(self.get_number_of_detectors())
        else:
            detector_list = [detector_number]  # Also a list so that we can always loop over it.
        # Loop over all detector numbers in list (possibly only one), and set the normalization
        # to the requested value.
        for one_detector_number in detector_list:
            this_detector = self.Ge_detectors[one_detector_number]
            try:
                this_detector.set_normalization_constant(new_normalization)
            except:
                print "Could not set normalization: detector #",one_detector_number + 1," does not exist."
                return -1

    def delete_detector(self,detector_number):
        """Deletes the requested (internal) detector number from the list of detector objects.

        This deletes a "logical" detector, not a "physical" detector.

        With the new object structure for logical detectors, all data including
        yields are deleted when the object is deleted.

        """
        try:
            ge_list = self.Ge_detectors
            del ge_list[detector_number]
            self.Ge_detectors = ge_list
        except:
            print "Error deleting logical detector #", detector_number + 1


    def get_number_of_detectors(self):
        """Returns the number of detectors in this experiment.

        This counts same-type detectors at different angles as additional
        detectors.  One cluster is counted as a single detector in the return
        value.

        """

        try:
            number_of_detectors = len(self.Ge_detectors)
        except:
            # No detectors are attached to this experiment.
            number_of_detectors = 0

        return number_of_detectors

    def get_detector_information(self,internal_detector_number,what):
        """Passes a call for the requested information to the detector object.

        This method is only to avoid calling the internal variable
        parameter_dict from methods outside this class.

        """

        return self.Ge_detectors[internal_detector_number].get_detector_information(what)


    def get_all_detector_numbers_and_angles(self,for_gosia=False):
        """Returns a list of three lists: type,theta_values,phi_values

        This method is updated to handle crystals and clusters.  If the type
        entry is None (Python None type), then it is a cluster detector.

        if for_gosia == True, then the gosia detector number is given.
        if false, then the internal type number is given.

        The return type had been a tuple of lists; now it is a list of lists:
        [[type1, type2,...], [theta1, theta2,...], [phi1, phi2,...]]

        """

        types  = []
        thetas = []
        phis   = []

        detector_list = self.Ge_detectors
        for one_detector in detector_list:
            this_theta                = one_detector.return_mean_theta()  # valid for crystals or clusters ("average" value)
            this_phi                  = one_detector.return_mean_phi()    # valid for crystals or clusters ("average" value)
            thetas.append(this_theta)
            phis.append(this_phi)
            if one_detector.get_detector_information("is_crystal"):
                this_internal_type_number = one_detector.return_type_number()
                if for_gosia:
                    types.append(this_internal_type_number + 1)
                else:
                    types.append(this_internal_type_number)
            else:
                # This is a cluster.  Set the type number to None and return the "average" theta and phi values.
                this_internal_type_number = None
                types.append(this_internal_type_number)

        return [types,thetas,phis]


    def print_detector_catalog(self,internal_experiment_number=None):
        """Prints a catalog of Ge detectors for this experiment.

        The gosia detector numbers 1--n are printed, not internal numbers.

        Note also that these are the "logical" detectors used in the
        laboratory, not the list of "physical" types defined.

        The value "internal_experiment_number" passed in does not change the
        experiment number for which the table is printed; it is always printed
        for this object of class experiment.  The experiment number only goes
        into the title in the printout if it is not None.

        """

        # Number of spaces per detector column
        column_spaces = 7

        # Get the nested list of detector information:
        all_detectors_list = self.Ge_detectors

        # If clusters_in_use is True, then a footnote will be added.  This will
        # be set to True if one or more clusters are attached to this
        # experiment.
        clusters_in_use = False
        # A flag to issue a warning about mixed types in a single cluster.
        mixed_types_in_cluster = False

        # Lists of lines for the tables.
        detector_number_lines = []
        theta_lines           = []
        phi_lines             = []
        cluster_lines         = []
        type_lines            = []
        solid_angle_lines     = []
        
        detector_number_line_header   = "#          "
        theta_line_header             = "theta      "
        phi_line_header               = "phi        "
        type_line_header              = "type #     "
        cluster_line_header           = "type       "
        solid_angle_line_header       = "Omega [sr] "

        # Keep a list of the type numbers found to generate a key at the bottom of the table.
        ge_type_numbers_found = []
        row_counter = -1
        # Generate the table
        for i in range(len(all_detectors_list)):
            # Create a new set of rows if there are more than 10 detectors on this line (and for the first line).
            if (i % 10) == 0:
                new_rows = True
            else:
                new_rows = False
            this_ge_detector = all_detectors_list[i]
            gosia_detector_number = i + 1
            detector_number_line_entry =  str(gosia_detector_number).ljust(column_spaces)
            theta_line_entry           =  str(round(this_ge_detector.return_mean_theta(),1)).ljust(column_spaces)
            phi_line_entry             =  str(round(this_ge_detector.return_mean_phi(),1)).ljust(column_spaces)

            # Determine if this is a cluster or a crystal.  In the former case,
            # the type number will be replaced with a * to a footnote.
            cluster_or_crystal   = this_ge_detector.identify_crystal_or_cluster().ljust(column_spaces)
            if cluster_or_crystal == "cluster":
                cluster_or_crystal = "CLUSTER"
            cluster_line_entry         =  cluster_or_crystal.ljust(column_spaces)

            if cluster_or_crystal == "crystal":
                # It is a single Ge crystal.  Print the type number in the table.
                internal_type_number = this_ge_detector.return_type_number()
                type_line_entry            =  str(internal_type_number + 1).ljust(column_spaces)
                ge_type_numbers_found.append(internal_type_number)
            else:
                # This detector is a cluster, so it does not in general have a
                # single type number.  
                # If all detectors in this cluster are of the same type, give the type in the output.

                internal_type_numbers = this_ge_detector.return_type_numbers()
                # Reduce this list to a set to see how many different types there are.
                set_of_type_numbers   = set(internal_type_numbers)
                # See if there is only one type number in the cluster.
                if len(set_of_type_numbers) == 1:
                    # Only one type in this cluster.
                    type_line_entry            =  str(internal_type_numbers[0] + 1).ljust(column_spaces)
                    ge_type_numbers_found.append(internal_type_numbers[0])
                else:
                    # This cluster has mixed types.  A warning and footnote will be made.
                    # In this case, print "*" and add a
                    # footnote.
                    type_line_entry            =  "*".ljust(column_spaces)
                    mixed_types_in_cluster = True
                clusters_in_use = True

            solid_angle = this_ge_detector.return_solid_angle()
            solid_angle_line_entry     =  str(round(solid_angle,3)).ljust(column_spaces)

            if new_rows:
                # Make a new row in the lines lists, and put the data on this line.
                detector_number_lines.append(detector_number_line_header + detector_number_line_entry)
                theta_lines.append(theta_line_header + theta_line_entry)
                phi_lines.append(phi_line_header + phi_line_entry)
                cluster_lines.append(cluster_line_header + cluster_line_entry)
                type_lines.append(type_line_header + type_line_entry)
                solid_angle_lines.append(solid_angle_line_header + solid_angle_line_entry)
                # Increment the row counter.
                row_counter += 1
            else:
                # Don't create a new row; just append to the current row.
                detector_number_lines[row_counter] += detector_number_line_entry
                theta_lines[row_counter]           += theta_line_entry
                phi_lines[row_counter]             += phi_line_entry
                cluster_lines[row_counter]         += cluster_line_entry
                type_lines[row_counter]            += type_line_entry
                solid_angle_lines[row_counter]     += solid_angle_line_entry
                
        if internal_experiment_number == None:
            title = "Logical Ge Detector Catalog for this experiment"
        else:
            title = "Logical Ge Detector Catalog for experiment " + str(internal_experiment_number + 1)

        separator = "---------------------------------------------------------------------------------"

        output_lines = [title]
        output_lines.append(separator)
        for row_number in range(len(detector_number_lines)):
            for data_list in [detector_number_lines, theta_lines, phi_lines, type_lines, cluster_lines, solid_angle_lines]:
                output_lines.append(data_list[row_number])
            output_lines.append(separator)


        # Add a table of the type numbers in use.
        type_names_dict = {}
        for one_type_number in ge_type_numbers_found:
            type_name = the_detector_manager.get_type_name(one_type_number)
            # Convert to user/Gosia type number and store the name with it.
            type_names_dict[one_type_number + 1] = type_name

        type_number_keys = type_names_dict.keys()
        type_number_keys.sort()
        output_lines.append("Ge types key")
        for type_number_key in type_number_keys:
            key_string = str(type_number_key).rjust(3) + "  " + type_names_dict[type_number_key]
            output_lines.append(key_string)
        # Add a footnote if one or more clusters are attached to this experiment.
        if mixed_types_in_cluster:
            footnote_lines = ["  * This cluster detector has mixed crystal types.","    If the crystals vary greatly in solid angle,","    this can lead to accuracy errors."]
            output_lines.extend(footnote_lines)


        create_dialog_popup({"text_lines":output_lines,"title":title})

        return 0
            

    def get_first_detector_number_at_position(self,detector_theta,detector_phi):
        """Returns the index in the yield data of the first Ge that matches theta and phi.

        One degree tolerance is allowed in the theta and phi coordinates.

        """
        detector_list = self.Ge_detectors
        detector_found = False
        for n in range(len(detector_list)):
            this_detector = self.Ge_detectors[n]
            theta         = this_detector.return_mean_theta()
            phi           = this_detector.return_mean_phi()
            if abs(detector_theta - theta) < 1.0 and abs(detector_phi - phi) < 1.0:
                detector_found = True
                break # out of for loop

        if detector_found:
            return n
        else:
            return -1   # indicates that there is no detector in the experiment at this position.

    def get_physically_different_detectors(self):
        """Returns a list of the physically different detector numbers.

        This is the internal type number, not the user/gosia number.

        """
        detector_list = self.Ge_detectors
        types_set = set([])  # Set math, so that all type numbers will be unique
        for one_detector in detector_list:
            this_type = one_detector.return_type_number()
            types_set.add(this_type)
        unique_detectors = list(types_set)  # Return as a list

        return unique_detectors

    def calculate_elast_stopping_powers(self):
        """Calculates stopping power meshpoints from the parameter dictionary

        This generates an input stream for J. M. Allmond's modified
        command-line version of elast, calls elast, redirecting output to a
        text file, then parses the output.

        Example of running the modified elast from the command line follows.

        136 Xe beam on a 179 Hf target:
        % elast -Qa 0 lp "1(72,179)" 1.0 "(54,136)" 500. > temp.txt
        
        -Q         very quiet--no table headers
        -a         all output (seems to be required to get stopping power?
        l          give energy loss in MeV
        p          give stopping power in MeV/(mg/cm^2)
        "1(Z,A)"   target has one component of Z,A
        1.0        target thickness in mg/cm^2
        "(Zb,Ab)"  beam has atomic number Zb, mass Ab
        500.       beam energy is 500 MeV
        > temp.txt redirect output to file "temp.txt"

        % cat temp.txt
        31.6197   31.7229 
        % elast -Qa 0 lp "1(72,179)" 1.0 "(54,136)" 400. >> temp.txt
        Redirect output to APPEND to file "temp.txt"
        % elast -Qa 0 lp "1(72,179)" 1.0 "(54,136)" 300. >> temp.txt
        % cat temp.txt
        31.6197   31.7229 
        30.5852   30.8023 
        28.4542   28.8694 

        """

        # For now, we hard-code the number of stopping powers to get for one
        # experiment.  20 is the maximum allowed by Gosia.
        number_of_stopping_power_points = DEFAULT_NUMBER_OF_STOPPING_POWERS

        # Create the empty lists for stopping power data.
        self.stopping_power_data = [[],[]]     # [[energy points],[stopping powers]]

        elast_command = GLOBAL_SETUP_DICT["ELAST_EXECUTABLE"] 
        initial_command_line_options = "-Qa 0 lp"
        output_file = "rachel_elast_output.txt"

        # Get the target Z,A.
        if self.parameter_dict["excited_target"]:
            target_mass = self.parameter_dict["A_1"]           # "investigated" nucleus
            target_atomic_number = self.parameter_dict["Z_1"]  # "investigated" nucleus
        else:
            target_mass = self.parameter_dict["A_n"]           # "uninvestigated" nucleus
            target_atomic_number = self.parameter_dict["Z_n"]  # "uninvestigated" nucleus

        # Get the projectile Z,A.
        if self.parameter_dict["excited_target"]:
            projectile_mass = self.parameter_dict["A_n"]           # projectile is "uninvestigated" nucleus
            projectile_atomic_number = self.parameter_dict["Z_n"]  # "uninvestigated" nucleus
        else:
            projectile_mass = self.parameter_dict["A_1"]           # "investigated" nucleus
            projectile_atomic_number = self.parameter_dict["Z_1"]  # "investigated" nucleus

        # Call elast to get the total energy loss in the target.  Then we can
        # split this energy range into intervals and get the stopping power at
        # each interval.


        def run_elast(target_atomic_number,target_mass,projectile_atomic_number,projectile_mass,beam_energy,append):
            
            # Try to remove the elast output file, in case this fails and there
            # was an output file remaining from a previous call.
            remove_command = "rm " + output_file
            # If the calling method requested overwriting the file, remove the original file.
            if not append:
                with open(".rachel_garbage","w") as garbage_file:
                    subprocess.call(remove_command,shell=True,stderr=garbage_file)  # (Redirect errors to the garbage file.)

            target_string       = "\"1(" + str(target_atomic_number) + "," + str(target_mass) + ")\"" # Leading "1" means one component in target.
            thickness_string    = str(self.parameter_dict["target_thickness"]) 
            projectile_string   = "\"(" + str(projectile_atomic_number) + "," + str(projectile_mass) + ")\"" 
            beam_energy_string  = format(beam_energy,".3f")  # rounded to the nearest keV.
            command_line        = elast_command + " " + initial_command_line_options + " " + target_string + " " +\
                                  thickness_string + " " + projectile_string + " " + beam_energy_string

            if append:
                command_line += " >> "
            else:
                command_line += " > "
            command_line += output_file
                
            with open(".rachel_garbage","w") as garbage_file:
                subprocess.call(command_line,shell=True,stderr=garbage_file)  # (Redirect errors to the garbage file.)

            return 0

        def run_elast_for_multiple_energies(target_atomic_number,target_mass,projectile_atomic_number,projectile_mass,beam_energies):
            """Calls elast multiple times.

            The first time, append is set to False, so that the output file is
            overwritten.  Subsequent times, the output is appended to the
            output file.

            """

            for energy_index in range(len(beam_energies)):
                # If this is the first call, tell the run_elast def to overwrite the output file.  
                if energy_index == 0:
                    append = False  # overwrite
                else:
                    append = True   # append
                this_beam_energy = beam_energies[energy_index]
                run_elast(target_atomic_number,target_mass,projectile_atomic_number,projectile_mass,this_beam_energy,append) 
                
            return 0

        # For the first pass, get the total energy loss.
        initial_beam_energy = self.parameter_dict["E_beam"]
        run_elast(target_atomic_number,target_mass,projectile_atomic_number,projectile_mass,initial_beam_energy,False) # False--don't append to the file.

        # Read the total energy loss from the file.  If there are more than one
        # line in the file, issue an error.
        with open(output_file,'r') as elast_output_file:
            all_elast_lines = elast_output_file.readlines()
            
        if len(all_elast_lines) > 1:
            block_print_with_line_breaks("\nError: the call to elast did not produce the expected output.  The experiment cannot be generated properly.  (You can use the \"Undo\" button to undo this step if necessary.)  Check that elast is compiled, and that the proper path is in the .rachel_setup file.")
            return -1

        # Get the energy loss in the target.
        line_fields = all_elast_lines[0].split()
        total_energy_loss = float(line_fields[0])  
        exit_energy = initial_beam_energy - total_energy_loss

        # Issue a warning to use SRIM for stopped beams.  We do not iterate to solve for the range here!
        if exit_energy < (0.5 * initial_beam_energy):  # MeV
            print "\nNOTE: The stopping power calculation shows that the energy loss is large, or the beam is stopped.  \nTHE ACTUAL RANGE HAS NOT BEEN CALCULATED BY ELAST.  \nYou should call the Rochester SRIM server to get more accurate stopping power and exit-energy data.  The server will also set the target thickness to the effective range, if the beam is truly stopped.  The accuracy of the range will not affect fitting or simulated counts, but will affect the quoted absolute cross sections."
            raw_input("Read the warning above, and press enter. ")

        # The check of maximum Q-value and setting of NCM is now done in
        # the_gosia_shell.generate_cont_lines() every time Gosia is called.
        
        self.parameter_dict["E_exit"] = exit_energy  # Save the exit energy from the target

        # Generate a list of energies for stopping power in Gosia.
        beam_energy_points = numpy.linspace(exit_energy,initial_beam_energy,number_of_stopping_power_points)
        # Add these beam energies to the nested stopping power list.
        self.stopping_power_data[0].extend(beam_energy_points)

        # Call elast again to get the stopping power at each beam energy point.
        run_elast_for_multiple_energies(target_atomic_number,target_mass,projectile_atomic_number,projectile_mass,beam_energy_points)

        # Read the output lines from elast.
        with open(output_file,'r') as elast_output_file:
            all_elast_lines = elast_output_file.readlines()
            
        # Check that there are the expected number of lines in the output file.
        number_of_output_lines = len(all_elast_lines)
        if not number_of_output_lines == number_of_stopping_power_points:
            block_print_with_line_breaks("\nError: the call to elast did not produce the expected output.  The experiment cannot be generated properly.  (You can use the \"Undo\" button to undo this step if necessary.)  Check that elast is compiled, and that the proper path is in the .rachel_setup file.")
            return -1
            
        # Step through the output lines, getting the stopping power for each
        # energy and adding the stopping power to the nested list.

        for stopping_power_index in range(number_of_output_lines):
            line_fields = all_elast_lines[stopping_power_index].split()
            stopping_power_MeV = float(line_fields[1])  # the second entry on the line.
            self.stopping_power_data[1].append(stopping_power_MeV)

        return 0



    def get_user_stopping_powers(self):
        """Prompts the user to enter stopping power data.

        """
        current_stopping_power_data = self.stopping_power_data 
        beam_energies = current_stopping_power_data[0]
        current_beam_energy = self.parameter_dict["E_beam"]
        current_exit_energy = self.parameter_dict["E_exit"]
        current_stopping_powers = current_stopping_power_data[1]
        new_stopping_powers = []
        new_energies = []

        warning_string = "\nTo ensure accuracy in the integration over beam energy in the target, " + str(DEFAULT_NUMBER_OF_STOPPING_POWERS) + " stopping powers should be given."
        block_print_with_line_breaks(warning_string,60)

        print ""
        print "There are two options to follow: "
        print "  Enter ",DEFAULT_NUMBER_OF_STOPPING_POWERS," stopping power points by hand, or"
        print "  Read an arbitrary number (",MINIMUM_NUMBER_OF_STOPPING_POWERS,"--",DEFAULT_NUMBER_OF_STOPPING_POWERS,") of stopping power points from a file."
        print ""

        def get_exit_energy():
            # Get information about this experiment that is needed to prompt the user.
            print "The final (exit) energy of the beam depends on the stopping power."
            print "The current exit energy is ",format(current_exit_energy,".3f")," MeV."
            new_exit_energy = prompt_number("Enter a new exit energy in MeV: ","f")
            if new_exit_energy == "quit":
                return None
            elif not new_exit_energy < current_beam_energy:
                print "Exit energy must be less than the initial beam energy of ",current_beam_energy
                return None
            else:
                return new_exit_energy

        adjust_by_hand = yes_no_prompt("Do you want to enter values by hand [y/N]? ",False) 
        if adjust_by_hand:

            new_exit_energy = get_exit_energy()
            if new_exit_energy == None:
                print "Cancelled."
                return 0
        
            new_beam_energies = numpy.linspace(new_exit_energy,current_beam_energy,DEFAULT_NUMBER_OF_STOPPING_POWERS)
            print "Enter a new stopping power \"P\" in MeV/(mg/cm^2) for each energy, or \"q\" to cancel."
            for i in range(DEFAULT_NUMBER_OF_STOPPING_POWERS):
                prompt_string = "P(" + format(new_beam_energies[i],".3f") + " MeV): "
                stopping_power = prompt_number(prompt_string,"f")
                if not stopping_power == "quit":
                    new_stopping_powers.append(stopping_power)
                else:
                    print "Cancelled."
                    return 0

            # Check that there are the correct number of stopping powers.
            if len(new_stopping_powers) == DEFAULT_NUMBER_OF_STOPPING_POWERS:
                print "Setting new stopping powers for this experiment."
                # Now save the new exit energy and stopping data to this experiment.
                self.stopping_power_data = copy.deepcopy([new_beam_energies,new_stopping_powers])
                self.parameter_dict["E_exit"] = new_exit_energy 
                print "Done."
                return 0
            else:
                print "Incorrect number of stopping powers were entered.  Cancelled."
                return 0

        else:
        
            adjust_by_file = yes_no_prompt("Do you want to read values from a file (using your own energy points) [y/N]? ",False) 
            if adjust_by_file:

                new_exit_energy = get_exit_energy()
                if new_exit_energy == None:
                    print "Cancelled."
                    return 0

                print "You can read stopping power from a file of the following format."
                print "Energy[MeV]  dE/dx[MeV/(mg/cm^2)]"
                print "e.g."
                for index in range(min(len(beam_energies),3)):
                    print format(beam_energies[index],".3f"), "    ", format(current_stopping_powers[index],".3f")
                print "The range in beam energy must meet or exceed the range " + str(new_exit_energy) + " to " + str(current_beam_energy) + " MeV."
                # Get the minimum and maximum beam energy to instruct the user.
                read_now = yes_no_prompt("Do you want to read new energies and stopping powers from a file now [Y/n]? ",True)
                if read_now:
                    file_name = prompt_for_file_name(prompt_string = "Enter file name: ")
                    try:
                        with open(file_name,"r") as input_file:
                            stopping_file_lines = input_file.readlines()
                        # Parse the file lines.
                        parsing_dict = {}
                        good_line_count = 0

                        for one_line in stopping_file_lines:
                            line_fields = one_line.split()
                            if len(line_fields) > 0 and line_fields[0][0] == "#":
                                # comment line
                                pass
                            elif len(line_fields) < 2:
                                print "Line ",good_line_count + 1," is not complete.  Skipping."
                            else:
                                # May be a good line
                                try:
                                    line_fields = one_line.split()
                                    if len(line_fields) >= 2:
                                        energy = float(line_fields[0])
                                        stopping_power = float(line_fields[1])
                                        parsing_dict[energy] = stopping_power
                                        good_line_count += 1
                                except:
                                    print "Format of this line: ",one_line," is incorrect.  Skipping."

                        if good_line_count > 20:
                            print "Too many stopping power entries in this file (maximum 20).  All changes cancelled."
                            return 0
                        elif good_line_count < 6:
                            print "Not enough stopping power entries in this file (minimum 6).  All changes cancelled."
                            return 0

                        sorting_keys = parsing_dict.keys()
                        sorting_keys.sort()
                        # make new lists of energy and stopping power.
                        for energy in sorting_keys:
                            stopping_power = parsing_dict[energy]
                            new_energies.append(energy)
                            new_stopping_powers.append(stopping_power)
                    except:
                        print "Could not parse the stopping power file.  Check the format."
                        print "All changes cancelled."
                        return 0

                    # Check that the stopping power data span the required beam energy range.
                    if (not new_energies[0] <= new_exit_energy) or (not new_energies[-1] >= current_beam_energy):
                        print "The energy range in the file did not span ",new_exit_energy," MeV to ",current_beam_energy," MeV!"
                        print "All changes cancelled."
                        return 0
                    # Now save the new exit energy and stopping data to this experiment.
                    print "Setting new stopping powers for this experiment."
                    self.parameter_dict["E_exit"] = new_exit_energy 
                    self.stopping_power_data = copy.deepcopy([new_energies,new_stopping_powers])
                    print "Done."
                    return 0

                else:
                    print "All changes cancelled."
                    return 0


    def get_stopping_power_data_from_rochester_server(self):
        """Calls the Rochester SRIM server to get new stopping powers and exit energy.

        """

        block_print_with_line_breaks("\nThe Rochester server does NOT do a full Monte Carlo calculation; it integrates the SRIM 2011 stopping power data to get the exit energy (or range for a stopped beam) assuming that straggling is not significant.\nYou will need the following:\n  1) The target density in g/cm^3\n  2) Either the target thickness in mg/cm^2 OR the measured projectile exit energy.  The stopping power MESHPOINTS returned are quoted directly from SRIM.\nServer calls usually take 20--30 seconds, if there is no queue at the server.  There is no timeout, but you can press CTRL-C to cancel, if the call takes too long.\nTo keep the server load reasonable, PLEASE DO NOT ATTEMPT TO USE THE ROCHESTER SERVER OUTSIDE OF THE GUI.",60)
        to_continue = yes_no_prompt("Do you want to continue [Y/n]? ",True)

        if not to_continue:
            return 0

        target_density = prompt_number("Enter the target density in g/cm^3: ","f")
        if target_density == "quit":
            return 0

        exit_energy_or_target_thickness_known = raw_input("Do you know the [e]xit energy or the [t]arget thickness [e/t]? ").lower()
        try:
            if exit_energy_or_target_thickness_known[0] == "e":
                exit_energy_is_known = True
                target_thickness_is_known = False
                thickness_or_exit_energy_flag = "-e-"
            elif exit_energy_or_target_thickness_known[0] == "t":
                exit_energy_is_known = False
                target_thickness_is_known = True
                thickness_or_exit_energy_flag = "-t-"
            else:
                print "Invalid choice.  Cancelled."
                return 0
        except:
            print "Invalid choice.  Cancelled."
            return 0

        if exit_energy_is_known:
            target_thickness_or_exit_energy = prompt_number("Enter the known exit energy in MeV: ","f")
        else:
            target_thickness_or_exit_energy = prompt_number("Enter the known target thickness in mg/cm^2: ","f")
        if target_thickness_or_exit_energy == "quit":
            return 0

        have_number_of_meshpoints = False
        while not have_number_of_meshpoints:
            instruction = "You must use between " + str(MINIMUM_NUMBER_OF_STOPPING_POWERS) + " and " + str(DEFAULT_NUMBER_OF_STOPPING_POWERS) + " stopping power meshpoints.  The maximum of " + str(DEFAULT_NUMBER_OF_STOPPING_POWERS) + " points is recommended for accurate Gosia calculations and does not use significant CPU time."
            block_print_with_line_breaks(instruction,60)

            number_of_meshpoints = prompt_number("Number of meshpoints: ","i")
            if number_of_meshpoints == "quit":
                return 0
            elif (number_of_meshpoints >= MINIMUM_NUMBER_OF_STOPPING_POWERS) and (number_of_meshpoints <= DEFAULT_NUMBER_OF_STOPPING_POWERS):
                have_number_of_meshpoints = True

        print "\nCalling the Rochester server.  This may take up to 2 minutes."
        print "Press CTRL-C to cancel."

        # Get the required beam and target parameters.
        beam_Z = self.Z_projectile()
        beam_mass = float(self.A_projectile())
        target_Z = self.Z_target()
        target_name = str(target_Z)
        target_mass = float(self.A_target())
        initial_energy = self.get_parameter("E_beam")
        fractional_padding_on_energy_meshpoints = 0.01


        # Call the Rochester server.
        print "\n"
        try:
            all_stopping_power_data = call_rochester_srim_server(beam_Z, beam_mass, target_density, target_Z, target_name, target_mass, initial_energy, target_thickness_or_exit_energy, fractional_padding_on_energy_meshpoints, number_of_meshpoints, thickness_or_exit_energy_flag)
        except:
            block_print_with_line_breaks("The Rochester server did not return any data.  This could mean that you pressed CTRL-C.  If you think there is a bug or that the server is down, please report it to A. Hayes (abraunhayes@gmail.com)",60)
            return 0
        if all_stopping_power_data == None:
            block_print_with_line_breaks("The Rochester server did not return any data.  This could mean that you pressed CTRL-C.  If you think there is a bug, please report it in the Gosia forum, or to A. Hayes (abraunhayes@gmail.com)",60)
            return 0

        # Stopped beam looks like:
        #{'error_strings': [], 
        # 'energies': [0.001, 14.0283, 28.0565, 56.112000000000002, 84.167500000000004, 112.223, 140.27850000000001, 168.334, 196.3895, 224.44499999999999, 252.50049999999999, 280.55599999999998, 308.61149999999998, 336.66699999999997, 364.72250000000003, 392.77800000000002, 420.83350000000002, 448.88900000000001, 476.94450000000001, 505.0], 
        # 'calculated_exit_energy': None, 
        # 'stopping_powers': [0.50060000000000004, 5.5541999999999998, 8.6639999999999997, 13.8668, 17.532399999999999, 20.299800000000001, 22.495899999999999, 24.312100000000001, 25.8444, 27.160599999999999, 28.3096, 29.3505, 30.202999999999999, 30.8065, 31.370999999999999, 31.836200000000002, 32.221899999999998, 32.538200000000003, 32.794800000000002, 33.001800000000003], 
        # 'calculated_target_thickness': None, 
        # 'calculated_range': 24.899999999999999}

        print "Setting new stopping powers for this experiment...  ",

        # See if the server thinks this is a stopped beam.
        if not all_stopping_power_data["calculated_range"] == None:

            # If the range was not None, then it is a stopped beam.
            found_stopped_beam = True

            block_print_with_line_breaks("\nThis appears to be a stopped beam.  Note that this is not a Monte Carlo calculation--you may want to use the SRIM Monte Carlo code and input stopping power data by hand (option \"m\" above).",60)
            print "Calculated range: " + str(all_stopping_power_data["calculated_range"]) + " mg/cm^2.\n"

            # Set the experiment's target thickness to the ion range, so that
            # cross sections will be accurate!  (This should not affect count
            # rates, because the thickness cancels.)
            block_print_with_line_breaks("NOTE: An incorrect thickness will result in incorrect quoted *absolute* cross sections (in millibarns) on yield plots, but in most THICK TARGET EXPERIMENTS will not affect fitting.\n***The target thickness for this experiment has been set to the calculated range given above.\nIf you are detecting backscattered ions from a thick target, the appropriate beam energy range for integration is from the initial beam energy down to the minimum energy at which backscattered particles can be detected in the particle counter.  In this case, you should calculate this lower-bound energy and repeat the SRIM server call specifying a *known exit energy*.")

            raw_input("\nRead the warning above, and press enter. ")

            self.parameter_dict["target_thickness"] = copy.deepcopy(all_stopping_power_data["calculated_range"])
            energy_of_highest_state = investigated_nucleus.maximum_level_energy()
            lowest_allowed_beam_energy = minimum_beam_energy(beam_mass,target_mass,energy_of_highest_state)
            new_exit_energy = lowest_allowed_beam_energy * 1.01 # slightly higher to avoid rounding problems.
            # The choice of whether to change the range to correspond to this energy is not clear.
            # For now, we will leave it at the original range, which should be very close.

        # Set the new exit energy for this experiment.
        elif exit_energy_is_known:
            new_exit_energy = target_thickness_or_exit_energy 
            found_stopped_beam = False
        else:
            # Target thickness was known, and the Rochester server should have returned the calculated exit energy.
            new_exit_energy = copy.deepcopy(all_stopping_power_data["calculated_exit_energy"])
            found_stopped_beam = False

        # The gosia shell will set the NCM flag properly for stopped beams, so we don't change it from 0 here.
        self.parameter_dict["E_exit"] = new_exit_energy 

        # Now save the new stopping power data to this experiment.
        new_beam_energies   = copy.deepcopy(all_stopping_power_data["energies"])
        new_stopping_powers = copy.deepcopy(all_stopping_power_data["stopping_powers"])
        self.stopping_power_data = copy.deepcopy([new_beam_energies,new_stopping_powers])

        # Update the target thickness with either the calculated thickness from the known exit energy or the user's known thickness.
        if exit_energy_is_known:
            # No thickness would be calculated by the Rochester server in this case.  Leave the thickness in the experiment as it was.
            new_target_thickness = float(raw_input("The target thickness has NOT been calculated from the exit energy.\nEnter the target thickness in mg/cm^2: "))
            self.parameter_dict["target_thickness"] = new_target_thickness
        elif not found_stopped_beam:
            new_target_thickness = target_thickness_or_exit_energy
            self.parameter_dict["target_thickness"] = new_target_thickness
        else:
            # It was found to be a stopped beam.  In this case, the new target thickness has been updated above.
            pass

        print "Done."
        print "You should re-plot the stopping power curve for the same experiment number."
        print "(Then mouse over the gnuplot window, and press \"l\" (lower-case \"L\") to get"
        print "  a linear scale.)"
        print "NOTE: If the SRIM stopping powers curve has flat regions,"
        print "  e.g. for a thin target, you can recalculate"
        print "  with fewer meshpoints or use the [s]mooth option."

    def plot_stopping_power_data(self):
        """Calls gnuplot methods to plot the stopping power for this experiment.

        """

        # Get the energy and stopping power lists from this experiment object.
        energies, stopping_powers = self.stopping_power_data

        if not len(energies) == len(stopping_powers):
            block_print_with_line_breaks("\nError: There are not an equal number of  energy and stopping power points.  Please report this bug.")
            return -1

        # Set the x axis label for the plot.
        x_label = "Beam energy in target [MeV]"
        y_label = "Stopping power [MeV/(mg/cm^2)]"

        # Put all data in one file for gnuplot.  Otherwise, gnuplot colors get
        # confused.
        plot_data_file_name = "temp_rachel_plot_data.dat"

        # Header comments for the plot data file.
        lines_to_write = ["# Stopping power data \n",\
                          "# Beam energy in MeV  \n",\
                          "# Stopping power dE/dx in MeV/(mg/cm^2) \n"]

        # Set the legend strings
        calculated_legend = ["dE/dx"]

        print "Beam    Stopping"
        print "Energy  Power"
        print "[MeV]   [MeV/(mg/cm^2)]"
        print "-----------------------"
        # Generate the text lines for gnuplot.
        for index in range(len(energies)):
            this_text_line = str(energies[index]) + "    " + str(stopping_powers[index]) + "\n"
            lines_to_write.append(this_text_line)
            # Write the plot data to the terminal.
            one_line = this_text_line.strip("\n")
            print one_line

        block_print_with_line_breaks("If the data are not smooth, you can select \"smooth\" from the prompts that follow.  Small steps should not cause problems with Gosia's interpolation.",60)

        lines_to_write.append("\n\n")  # two blank lines to separate sets
        
        with open(plot_data_file_name,"w") as plot_data_file: 
            plot_data_file.writelines(lines_to_write)
        print "Data for this plot were written to the file \"" + plot_data_file_name + "\"."

        # Call a routine to launch gnuplot
        experimental_legend=None
        better_gnu_plot_launch(plot_data_file_name,calculated_legend,x_label,y_label,experimental_legend)

        return 0


    def get_stopping_power_lines(self):
        """Return the stopping power data in a list of 3 lines:
        
        [NP,energy_points_line,stopping_powers_line]
        """
        NP = len(self.stopping_power_data[0])
        NP_line = str(NP)
        energy_points = self.stopping_power_data[0]
        energy_points_line = str(energy_points).strip('[]')
        stopping_power_points = self.stopping_power_data[1]
        stopping_power_points_line = str(stopping_power_points).strip('[]')
        lines_for_gosia = [NP_line,energy_points_line,stopping_power_points_line]
        return lines_for_gosia
        

    def set_parameter(self,parameter_name,parameter_value):
        """Sets a parameter in the parameter_dict.

        """

        self.parameter_dict[parameter_name] = parameter_value

        return 0
        


    def get_full_parameter_dict(self):
        
        return self.parameter_dict

    def get_parameter(self,parameter_name):
        
        return self.parameter_dict[parameter_name]


    def mean_scattering_angle(self,return_com_solution=False):
        """Returns the mean scattering angle.

        This returns the mean scattering (projectile) angle in the lab frame
        correctly, whether the projectile or target was detected.

        If return_com_solution is True, then return also "forward" or "backward".

        """
        excited_target = self.get_parameter("excited_target")
        A_1 = self.get_parameter("A_1")
        A_n = self.get_parameter("A_n")

        # Get the Z,A of each particle, identified as projectile or target.
        if excited_target:
            A_proj = A_n
            A_targ = A_1
        else:
            A_proj = A_1
            A_targ = A_n

        # For target detection and inverse kinematics, we should carefully
        # consider both solutions to get a sensible mean projectile angle for
        # EXPT.
        inverse = self.is_inverse_kinematics()

        # Get the beam energy and Q-value
        temp,temp,Q_value = the_gosia_shell.return_kinematics_state_data()
        Q_value = Q_value / 1000.  # MUST BE IN MEV for the inelastic scattering functions.
        E_mean = self.parameter_dict["E_mean"]

        detected_particle = self.get_parameter("detected_particle")
        if detected_particle == "t":
            theta_lab_mean_recoil = self.get_parameter("theta_lab_mean")

            # In this case, the forward c.o.m. solution for the TARGET angle is
            # for the low-exit-energy solution that exists for normal or
            # inverse kinematics with Q<>0.  Gosia does not treat this, so
            # False indicates the backward com solution for the given TARGET
            # angle.

            theta_lab_projectile_mean = inelastic_lab_recoil_angle_to_lab_scattering_angle(A_proj,A_targ,theta_lab_mean_recoil,False,E_mean,Q_value)

        else:
            # This is the simpler case, where the user entered projectile
            # scattering angles: just get the mean scattering angle.
            theta_lab_projectile_mean = self.get_parameter("theta_lab_mean")

        return theta_lab_projectile_mean 




    def set_one_detector_experimental_yields(self,internal_detector_number,yield_list):
        """Sets experimental yields of one detector only.

        With the new object structure for Ge detectors, this becomes only a
        matter of passing the yields already in the correct format to the
        detector object.

        """

        this_detector = self.Ge_detectors[internal_detector_number]
        this_detector.set_experimental_yields(yield_list)
        return 0
                
    def set_all_experimental_yields(self,nested_yield_list):
        """Sets experimental yields for all detectors in a nested list.

        This list is usually passed from the experiment_manager, which has
        parsed them from the gosia output file.

        The format is [[detector 0 yields], [detector 1 yields],... ], where

        detector n yields are formatted as [[initial_internal_level_number,
        final_internal_level_number, yield, self-normalized_yield],["],...]

        """

        detector_list = self.Ge_detectors
        for n in range(len(detector_list)):
            this_detector = detector_list[n]
            this_detector_experimental_yields = nested_yield_list[n]
            this_detector.set_experimental_yields(this_detector_experimental_yields)
        return 0

    def set_one_detector_calculated_yields(self,internal_detector_number,yield_list):
        """Sets calculated yields of one detector only.

        With the new object structure for Ge detectors, this becomes only a
        matter of passing the yields already in the correct format to the
        detector object.

        """

        this_detector = self.Ge_detectors[internal_detector_number]
        this_detector.set_calculated_yields(yield_list)
        return 0
                
    def set_all_calculated_yields(self,nested_yield_list):
        """Sets calculated yields for all detectors in a nested list.

        This list is usually passed from the experiment_manager, which has read
        them from disk or generated simulated data.

        The format is [[detector 0 yields], [detector 1 yields],... ], where

        detector n yields are formatted as [[initial_internal_level_number,
        final_internal_level_number, yield, error],["],...]

        """

        detector_list = self.Ge_detectors
        for n in range(len(detector_list)):
            this_detector = detector_list[n]
            this_detector_calculated_yields = nested_yield_list[n]
            this_detector.set_calculated_yields(this_detector_calculated_yields)
        return 0

    def get_calculated_yields(self,internal_detector_number):
        """Returns calculated (integrated) yields read by experimentmanager from the gosia output.

        Does not properly treat band pseudonyms, but it can be used safely with this in mind.
        
        SOME FUNCTIONS STILL USE THIS CORRECTLY, BUT IT SHOULD EVENTUALLY BE REMOVED.

        """
        the_detector = self.Ge_detectors[internal_detector_number]
        calculated_yield_list = the_detector.return_calculated_yields()
        return calculated_yield_list 

    def get_experimental_yields(self,internal_detector_number):
        """Returns experimental yields in memory.

        Does not properly treat band pseudonyms, but it can be used safely with this in mind.
        
        SOME FUNCTIONS STILL USE THIS CORRECTLY, BUT IT SHOULD EVENTUALLY BE REMOVED.

        """
        the_detector = self.Ge_detectors[internal_detector_number]
        experimental_yield_list = the_detector.return_experimental_yields()
        return experimental_yield_list 

    def get_normalizing_experimental_yield(self):
        """Returns the experimental yield of the normalizing transition for this experiment.

        Yields are normalized to the first detector (internal number 0).

        This is handled by the experiment object because it has information
        about all detectors.  

        """

        # Rewritten for new object structure, Aug 2011.

        # Get the states of the normalization transition.
        normalizing_initial_state_key, normalizing_final_state_key = investigated_nucleus.get_normalization_transition_keys()
        internal_normalizing_detector_number = 0
        # Get all the yields for this detector
        all_yields = self.Ge_detectors[internal_normalizing_detector_number].return_experimental_yields()
        for one_yield in all_yields:
            initial_band_name, initial_spin, final_band_name, final_spin, experimental_yield, error = one_yield
            initial_state_key = (initial_band_name, initial_spin)
            final_state_key   = (final_band_name, final_spin)
            if normalizing_initial_state_key == initial_state_key and normalizing_final_state_key == final_state_key:
                # This is the normalizing yield
                return [experimental_yield, error]
                break

        # If the transition was not found return error code None
        return [None, None]

    def get_normalizing_calculated_yield(self):
        """Returns the calculated (intg) yield of the normalizing transition for this experiment.

        Yields are normalized to the first detector (internal number 0).

        This is handled by the experiment object because it has information
        about all detectors.  

        """

        # Rewritten for new object structure, Aug 2011.

        # Get the states of the normalization transition.
        normalizing_initial_state_key, normalizing_final_state_key = investigated_nucleus.get_normalization_transition_keys()
        internal_normalizing_detector_number = 0
        # Get all the yields for this detector
        all_yields = self.Ge_detectors[internal_normalizing_detector_number].return_calculated_yields()
        for one_yield in all_yields:
            initial_band_name, initial_spin, final_band_name, final_spin, calculated_yield = one_yield
            initial_state_key = (initial_band_name, initial_spin)
            final_state_key   = (final_band_name, final_spin)
            if normalizing_initial_state_key == initial_state_key and normalizing_final_state_key == final_state_key:
                # This is the normalizing yield
                return calculated_yield
                break

        # If the transition was not found return error code None
        return None

    def get_experimental_yields_with_requested_normalization(self,internal_detector_number):
        """Returns experimental yields normalized to the proper experiment and detector.

        """
        # Get LN, the gosia experiment number to which yields should be normalized.
        gosia_LN = self.get_parameter("LN")
        internal_LN = gosia_LN - 1  # convert to internal experiment number.
        # Get the initial and final internal state numbers of the normalizing transition.

        # Now get the normalizing yield for that experiment number.  This will be for
        # internal detector number 0.
        normalizing_yield_list = the_experiment_manager.allexperiments[internal_LN].get_normalizing_experimental_yield()
        normalizing_yield, normalizing_yield_error = normalizing_yield_list
        if normalizing_yield == None:
            # An error occurred
            return None  # pass the error on

        # Get all the yields for this detector
        all_yields = self.Ge_detectors[internal_detector_number].return_experimental_yields()
        # Make a new list for the renormalized yields.
        renormalized_yields = []
        # Now calculate the renormalized experimental yields for this experiment and detector.
        for one_yield in all_yields:
            initial_band_name, initial_spin, final_band_name, final_spin, original_yield, original_yield_error  = one_yield
            renormalized_yield = original_yield / normalizing_yield
            renormalized_yield_error = renormalized_yield * (original_yield_error / original_yield)
            # Now put the entry into the new list with the new normalized yield
            renormalized_yields.append([initial_band_name, initial_spin, final_band_name, final_spin, renormalized_yield, renormalized_yield_error])

        # Now return the new list of renormalized yields:
        return renormalized_yields

    def get_calculated_yields_with_requested_normalization(self,internal_detector_number):
        """Returns calculated (intg) yields normalized to the proper experiment.

        """

        # Get LN, the gosia experiment number to which yields should be normalized.
        gosia_LN = self.get_parameter("LN")
        internal_LN = gosia_LN - 1  # convert to internal experiment number.
        # Get the initial and final internal state numbers of the normalizing transition.

        # Now get the normalizing yield for that experiment number.  This will be for
        # internal detector number 0.
        normalizing_yield = the_experiment_manager.allexperiments[internal_LN].get_normalizing_calculated_yield()
        if normalizing_yield == None:
            # An error occurred
            return None  # pass the error on

        # Get all the yields for this detector
        all_yields = self.Ge_detectors[internal_detector_number].return_calculated_yields()
        # Make a new list for the renormalized yields.
        renormalized_yields = []
        # The format for the new yield data will be [[internal_initial_state,internal_final_state,original_yield,renormalized_yield],[...],[...],...]
        # Now calculate the renormalized experimental yields for this experiment and detector.
        for one_yield in all_yields:
            # The last two entries will be replace and not used
            initial_band_name, initial_spin, final_band_name, final_spin, original_yield = one_yield
            renormalized_yield = original_yield / normalizing_yield
            # Now put the entry into the new list with the new normalized yield
            renormalized_yields.append([initial_band_name, initial_spin, final_band_name, final_spin, renormalized_yield])

        # Now return the new list of renormalized yields:
        return renormalized_yields

class detectormanager:
    """Manages the database of physical detector types.  

    These are the physically unique detectors, with different geometries or
    distances from the target, as well as special types, e.g. 4pi arrays.

    The internal type number is base 0; the gosia type numbers must be base 1.

    """

    def __init__(self):

        # Names of absorber types.  This is not currently in use, because the
        # GUI does not handle absorbers--it assumes that all data are
        # efficiency-corrected.
        self.absorber_names = ["Al","C","Fe","Cu","Ag/Cd/Sn","Ta","Pb"]

        # The efficiency curve types that are understood are defined below.
        self.understood_efficiency_curve_types = \
         {"radware":\
                   {"formula":"ln(eff) = [(A + Bx + Cx^2)^(-G) + (D + Ey +Fy^2)^(-G)]^(-1/G), x = ln(E_keV/100), y = ln(E_keV/1000)",\
                    "parameter_names":["A","B","C","D","E","F","G"],\
                    "default_parameter_values":{"A":5.7021, "B":4.83491, "C":0., "D":6.20016, "E":-6.06E-01, "F":-5.36E-03, "G":4.5934},\
                    "description":"D.C. Radford, NIM A 361:297 (1995)"\
                   },\
#          "gremlin":\
#                   {"formula":"eff = P * F * W, where P = a0 + a1 * [ln(E/Eo)] + a2 * [ln(E/Eo)]^2 + a3 * [ln(E/Eo)]^3, F = exp{f / [ln(E/Eo)]^N}, W = 1 / (1 + exp[(b - E)/c])",\
#                    "parameter_names":["a0","a1","a2","a3","f","N","b","c","Eo"],\
#                    "default_parameter_values":{"a0":0.,"a1","a2","a3","f","N","b","c","Eo"},\
#                    "description":"See Gosia manual on GREMLIN. This curve does not include attenuation factors A(E) for absorbers."\
#                   }\
          "miniball":\
                   #{"formula":"eff = a0 + a1 * ln(E_keV/1000) + a2 * (ln(E_keV/1000))^2 + a3 * (ln(EkeV/1000))^3 + a4 * (ln(E_keV/1000))^4",\
                   {"formula":"eff = a0 + a1 * ln(E_keV/) + a2 * (ln(E_keV/))^2 + a3 * (ln(EkeV/))^3 + a4 * (ln(E_keV/))^4",\
                    "parameter_names":["a0","a1","a2","a3","a4"],\
                    "default_parameter_values":{"a0":-1077.3, "a1":724.582, "a2":-172.58, "a3":17.7101, "a4":-0.668257},\
                    "description":"Miniball fit code"\
                   }\
         }

        # The default parameters for a single crystal are defined in terms of
        # the Radware parameters.  These are used by a new physical detector if
        # the user did not specify any efficiency parameters (for simulations
        # only).  These will be accessed by the objects of class
        # physical_detector.
        self.default_efficiency_parameters_four_pi_array = \
          {"A":5.7021, "B":4.83491, "C":0., "D":6.20016, "E":-6.06E-01, "F":-5.36E-03, \
           "G":4.5934, "absolute_calibration_energy_keV":1333., \
           "absolute_calibration_absolute_efficiency":0.089}

        # The curve defined above for a summed 4pi array assumes the measured
        # absolute efficiency for Gammasphere (covering ~49% of 4pi) measured
        # by T. Lauritsen et al., PRC 75:064309 (2007), giving the peak
        # efficiency of 8.9(2)% at 1333 keV.  The Radware parameters A--G are
        # from a relative efficiency calibration by A.B. Hayes et al., in a
        # 2008 experiment.

        self.default_efficiency_parameters_single_crystal = \
          {"A":5.7021, "B":4.83491, "C":0., "D":6.20016, "E":-6.06E-01, "F":-5.36E-03, \
           "G":4.5934, "absolute_calibration_energy_keV":1333., \
           "absolute_calibration_absolute_efficiency":0.00089}
        # The absolute efficiency calibration point of 0.00089 is derived from
        # Lauritsen et al. for 1 of the 100 detectors used in that measurement.
        # (0.089 / 100 = 0.00089)  This is most accurate for a 7cm diameter by
        # 7cm length crystal.

        self.alldetectors = []  # list of all detectors defined

    def for_upgrade(self,restored_version):
        """Sets new variables as appropriate for an upgrade from

        version restored_version to present VERSION.

        """

        # June 7, 2011.  This needs to be upgraded using the method
        # remove_whitespace_from_detector_names() now that it is possible to
        # read a detector or array from a file.

        total_errors = 0
        return_text = []

        if restored_version in []:
            # Add to the list above to select for upgrades by session file's version number.
            try:

                # Add to the commands here to upgrade the object of this class.

                success_string = "Physical Ge detector definitions successfully upgraded to version " + str(VERSION) + "."
                return_text.extend(textwrap.wrap(success_string,TEXTVIEW_COLUMNS))
            except:
                total_errors += 1
                angular_limit_set_error = "Error in setting angular limits for one or more experiments."
                return_text.extend(textwrap.wrap(angular_limit_set_error,TEXTVIEW_COLUMNS))
            
            # Examples of syntactically correct error codes are below.
            #total_errors += 1
            #return_text.extend(textwrap.wrap("ipsum lorem blah blah blah",TEXTVIEW_COLUMNS))
        else:
            # No upgrade necessary.
            pass

        return total_errors,return_text


    def change_efficiency_parameters(self):
        """Allows the user to change efficiency parameters for physical detectors

        """

        rachel_ge_types_file = "rv_rachel_detector_dict.txt"

        block_print_with_line_breaks("The efficiency curve is used only in simulating data, since real experimental data must be efficiency-corrected.\nThe default efficiency curve most accurately represents a 7 cm diameter X 7.5 cm long Ge crystal with no absorbers.\nYou can modify the efficiency curve for one or more detectors to reproduce the response of a crystal of any geometry.",60)

        internal_detectors_changed = set([])  # will be updated with crystals that were modified, so that they can be saved.

        number_of_physical_detectors = self.getnumberofdetectors()
        to_continue = True
        while to_continue:
            self.display_all_physical_detectors()
            external_physical_detector_number = prompt_number("Enter detector number [\"q\" to quit]: ","i")
            if external_physical_detector_number == "quit":
                break # out of the while loop.  Will continue to prompt whether to save the detector changes to the library.

            internal_physical_detector_number = external_physical_detector_number - 1

            # Make sure the detector number exists.
            try:
                self.alldetectors[internal_physical_detector_number]
                good_detector = True
            except:
                print "That detector number is not in memory."
                good_detector = False
            
            if good_detector:
                # Get the efficiency parameters and curve type for this physical detector.
                efficiency_curve_type = self.alldetectors[internal_physical_detector_number].get_efficiency_curve_type()
                efficiency_parameters = self.alldetectors[internal_physical_detector_number].get_efficiency_parameters()
                absolute_calibration_energy_keV = efficiency_parameters["absolute_calibration_energy_keV"]
                absolute_calibration_absolute_efficiency = efficiency_parameters["absolute_calibration_absolute_efficiency"]

                print "Efficiency parameters for this detector:\n"
                print "Parametrization: ",efficiency_curve_type
                print "Formula:         ",self.understood_efficiency_curve_types[efficiency_curve_type]["formula"]
                print "with parameters  ",str(self.understood_efficiency_curve_types[efficiency_curve_type]["parameter_names"]).strip("[]").replace("'","")
                print "of values        ",
                temporary_keys = efficiency_parameters.keys()
                temporary_keys.sort()
                for one_key in temporary_keys:
                    if not "absolute" in one_key:
                        print one_key + " = " + str(efficiency_parameters[one_key]) + ", ",
                print
                print "and absolute efficiency of " + format(absolute_calibration_absolute_efficiency,".5f") + " at " + \
                  format(absolute_calibration_energy_keV,".1f") + " keV"

                efficiency_plot_data  = self.alldetectors[internal_physical_detector_number].get_efficiency_vs_energy()
                plot_efficiency_curve(efficiency_plot_data[0],efficiency_plot_data[1])

                block_print_with_line_breaks("You will be prompted with the options to change both the absolute efficiency calibration and the shape of the efficiency curve.")

                # Check whether this is a 4pi summed array or a single crystal.
                four_pi = self.alldetectors[internal_physical_detector_number].get_parameter("four_pi")

                to_reset = yes_no_prompt("Reset the efficiency curve to the default parameters [y/N]? ",False)
                if to_reset:
                    internal_detectors_changed.add(internal_physical_detector_number)
                    self.alldetectors[internal_physical_detector_number].detector_parameters_dict["efficiency_curve_type"] = "radware"
                    if four_pi:
                        self.alldetectors[internal_physical_detector_number].detector_parameters_dict["efficiency_parameters"] = copy.deepcopy(the_detector_manager.default_efficiency_parameters_four_pi_array)
                    else:
                        self.alldetectors[internal_physical_detector_number].detector_parameters_dict["efficiency_parameters"] = copy.deepcopy(the_detector_manager.default_efficiency_parameters_single_crystal)
                    print "The efficiency parameters have been reset to the default\nvalues for a ",
                    if four_pi:
                        print "4pi array."
                    else:
                        print "7cm diameter X 7.5 cm long crystal."
                    
                to_change = yes_no_prompt("Change the absolute efficiency calibration [y/N]? ",False)
                if to_change:
                    internal_detectors_changed.add(internal_physical_detector_number)
                    # Get the absolute efficiency point at the standard energy
                    # first.  The user can then change the relative curve, or
                    # leave it as it is.
                    prompt_string = "Enter the energy (keV) of the absolute efficiency calibration point [" + format(absolute_calibration_energy_keV,".1f") + "]: "
                    new_calibration_energy  = prompt_default(prompt_string,absolute_calibration_energy_keV,"f")
                    prompt_string = "Enter the absolute efficiency at " + format(new_calibration_energy,".1f") + " keV: "
                    new_absolute_efficiency = prompt_default(prompt_string,absolute_calibration_absolute_efficiency,"f")
                    self.alldetectors[internal_physical_detector_number].detector_parameters_dict["efficiency_parameters"]["absolute_calibration_energy_keV"] = new_calibration_energy
                    self.alldetectors[internal_physical_detector_number].detector_parameters_dict["efficiency_parameters"]["absolute_calibration_absolute_efficiency"] = new_absolute_efficiency

                to_change = yes_no_prompt("Change the efficiency curve parameters [y/N]? ",False)
                if to_change:
                    internal_detectors_changed.add(internal_physical_detector_number)
                    allowed_curve_types = self.understood_efficiency_curve_types.keys()
                    print "Currently allowed curve types are:"
                    print str(allowed_curve_types).strip("[]")
                    good_type = False
                    while not good_type:
                        new_curve_type = raw_input("Type the name of the curve type in full, e.g. \"radware\": ")
                        if new_curve_type in allowed_curve_types:
                            good_type = True

                    # Since GREMLIN uses a polynomial of arbitrary order for
                    # one factor, if the curve type is gremlin, will will
                    # insert here a call to a small def to prompt for the
                    # polynomial order, coefficients, etc.

                    # Now get the user's new values for all parameters in this curve type.
                    parameter_names = self.understood_efficiency_curve_types[new_curve_type]["parameter_names"]
                    formula = self.understood_efficiency_curve_types[new_curve_type]["formula"]

                    print "Enter the following parameters: ",str(parameter_names).strip("[]").replace("'",""), " for the formula"
                    print formula
                    print "Press enter for the defaults in []."
                    new_curve_parameters = {}
                    # Get the default value from the defaults for the new
                    # curve type ("radware", etc.) if it is the same as the
                    # original curve type.  Otherwise, get them from the
                    # defaults for this curve type.
                    if efficiency_curve_type == new_curve_type:
                        default_efficiency_parameters = efficiency_parameters
                        found_defaults = True
                    elif new_curve_type in self.understood_efficiency_curve_types.keys():
                        try:
                            default_efficiency_parameters = self.understood_efficiency_curve_types[new_curve_type]["default_parameter_values"]
                            found_defaults = True
                        except:
                            found_defaults = False
                    else:
                        found_defaults = False

                    for one_parameter in parameter_names:
                        if found_defaults:
                            default_value = default_efficiency_parameters[one_parameter]
                            prompt_string = one_parameter + " [" + format(default_value,"e") + "]: "
                            new_value = prompt_default(prompt_string,default_value,"f")
                        else:
                            new_value = "quit"
                            while new_value == "quit":
                                prompt_string = one_parameter + " []: "
                                new_value = prompt_number(prompt_string,"f")
                        new_curve_parameters[one_parameter] = new_value

                    # Now copy the new curve parameters to the physical detector.
                    self.alldetectors[internal_physical_detector_number].detector_parameters_dict["efficiency_curve_type"] = new_curve_type # from "radware" Dec 21 2011
                    # Get the absolute calibration point from the original
                    # definition.  If the user modified this calibration point,
                    # then it has already been added to the physical detector
                    # definition.
                    calibration_energy = \
                      self.alldetectors[internal_physical_detector_number].detector_parameters_dict["efficiency_parameters"]["absolute_calibration_energy_keV"]
                    absolute_efficiency = \
                      self.alldetectors[internal_physical_detector_number].detector_parameters_dict["efficiency_parameters"]["absolute_calibration_absolute_efficiency"]
                    # Add the absolute calibration point to the new parameter dict.
                    new_curve_parameters["absolute_calibration_energy_keV"]          = calibration_energy
                    new_curve_parameters["absolute_calibration_absolute_efficiency"] = absolute_efficiency
                    self.alldetectors[internal_physical_detector_number].detector_parameters_dict["efficiency_parameters"] = copy.deepcopy(new_curve_parameters)
                        
        if not len(internal_detectors_changed) == 0:  # At least one detector's efficiency was modified.
            to_save = yes_no_prompt("Save the modified crystals to the library in the working directory [y/N]? ")
            if to_save:
                # Try to read the standard types from the detector dictionary pickle in the working directory.
                # The file name has been changed to "rv_rachel_detector_dict.txt" because of a change in the format.
                try:
                    with open(rachel_ge_types_file,"r") as detector_dict_file:
                        current_ge_library = pickle.load(detector_dict_file)
                    #print "Read the current crystal types library from the working directory."
                    read_standard_types = True
                except:
                        # No library file in working directory.  Start with an empty one.
                        current_ge_library = {}  

                # Add this modified type to the library, and write the modified library to the working directory.
                for internal_physical_detector_number in internal_detectors_changed:
                    detector_name = self.alldetectors[internal_physical_detector_number].get_parameter("detector_name")
                    current_ge_library[detector_name] = self.alldetectors[internal_physical_detector_number].get_all_parameters()
                    print "Updating detector " + str(internal_physical_detector_number + 1) + " named \"" + detector_name + "\"."
                try:
                    with open(rachel_ge_types_file,"w") as detector_dict_file:
                        pickle.dump(current_ge_library,detector_dict_file)
                    print "New crystal types saved to library."
                    return 0
                except:
                    print "There was an error writing the file \"" + rachel_ge_types_file + "\"."
                    print "Could not save the updated crystal types library!"
                    print "Check the permissions of this file."
                    return -1
            else:
                print "Modified crystal types not saved."

        return 0

    def examine_detectors_interactive(self):
        """Allows the user to see what detectors are defined.

        These are the physical detectors in memory, some of which may not be in
        use as logical detectors.

        """
        print "The following physical detectors are in memory."
        print "All of them need not be attached to experiments."
        self.display_all_physical_detectors()

        return 0

    def is_ready(self):
        
        if self.getnumberofdetectors() == 0:
            return False
        else:
            return True

    def getnumberofdetectors(self):
        """Returns the number of detectors

        """
        return len(self.alldetectors)

    def define_physical_Ge_types_from_file(self):
        """Adds physical types from a human-readable file.

        An arbitrary number may be created.  

        """

        # Set default thicknesses of 0 for all types.
        absorber_thicknesses = [0 for i in range(len(self.absorber_names))]

        # Dictionary of the expected keywords in the geometry lines for
        # checking the file format.  The keywords point to the keys used in the
        # internal storage of detector dictionaries.
        expected_keywords = {"description":"detector_description","distance":"d","outer_radius":"R","inner_radius":"r","length":"L"}
        expected_keywords_list = expected_keywords.values()
        expected_keywords_list.sort()

        # A nested dictionary for all new detector type dictionaries read from the user's file.
        all_new_detector_dicts = {}

        # A list in the order that the new detector type names were read from
        # the file, so that we can add them with increasing type numbers in
        # that order.
        all_new_detector_names = []

        # Read the user's physical crystal definitions.  We don't provide a
        # method to read an isotropic 4pi detector here, since that requires
        # only the definition in the standard library and isn't helpful in
        # defining clusters or arrays.

        physical_detector_file_name = prompt_for_file_name(prompt_string = "Enter file name to read physical Ge crystal types: ")
        try:
            with open(physical_detector_file_name,"r") as physical_detector_file:
                detector_file_lines = physical_detector_file.readlines()
            print "Read physical Ge crystal types file."
        except:
            print "File not found.  Quitting."
            return -1

        print ""
        print "Reading the current libraries on disk to find duplicate names..."
        print ""

        # Read the standard types from the detector dictionary pickle.
        # The file name has been changed to "rv_rachel_detector_dict.txt" because of a change in the format.
        try:
            print "Trying to read detector types library from the file "
            print "\"rv_rachel_detector_dict.txt\" in the working directory..."
            rachel_ge_types_file = "rv_rachel_detector_dict.txt"
            with open(rachel_ge_types_file,"r") as detector_dict_file:
                current_local_ge_types = pickle.load(detector_dict_file)
            print "Read the detector types library from the working directory."
            read_local_types = True
        except:
            print "Could not find the detector types library in the working directory."
            print "(This is ok.)"
            read_local_types = False
            current_local_ge_types = {}

        try:
            print "Trying to read detector types library from the file "
            print "\"rv_rachel_detector_dict.txt\" in the Rachel installation directory..."
            rachel_ge_types_file = GLOBAL_SETUP_DICT["RACHEL_DIRECTORY"] + "/necessary_files/rv_rachel_detector_dict.txt"
            with open(rachel_ge_types_file,"r") as detector_dict_file:
                current_standard_ge_types = pickle.load(detector_dict_file)
            print "Read the detector types library from the installation directory."
            read_standard_types = True
        except:
            block_print_with_line_breaks("Could not find the detector types library in the installation directory.\n(You can create your own types, or you can get the newest detector library from Rochester.)",60)
            read_standard_types = False
            # Set empty dictionary for the standard types.
            current_standard_ge_types = {}
    
        # Combine the two dicts (possibly empty):
        all_library_types = copy.deepcopy(current_standard_ge_types)
        all_library_types.update(current_local_ge_types)

        # Parse the user's detector definition file to form detector dictionaries.

        line_number = 0
        crystal_count = 0
        try:
            while line_number < len(detector_file_lines):
                this_line = detector_file_lines[line_number]
                line_fields = this_line.split()
                if len(line_fields) == 0:
                    # Nothing on the line.  Just step to the next line.
                    line_number += 1
                else:
                    if line_fields[0][0] == "#":
                        # This is a comment.  Don't process this line.
                        line_number += 1
                    else:
                        # This should be the start of a six-line definition.
                        # Only the first word is kept as the name.
                        user_name_for_crystal = line_fields[0] 
                        this_crystal_type_dictionary = {}

                        print "Reading crystal type: \"",user_name_for_crystal , "\" ..."

                        # The next four lines should define the geometry.
                        definition_finished = False

                        # Step to the next line to look for the rest of the definition.
                        line_number += 1

                        while not definition_finished:
                            # Step through the file lines until the four parameters are defined.
                            this_line = detector_file_lines[line_number]
                            line_fields = this_line.split()
                            # Skip comments and blank lines.
                            if not line_is_comment(this_line) and not line_is_whitespace(this_line):
                                try:
                                    this_keyword = line_fields[0]
                                    if this_keyword in expected_keywords.keys():
                                        if this_keyword == "description":
                                            # This is treated differently.  The entire rest of the line is added as the description value.
                                            description_string = this_line.strip().replace("description","",1).strip()
                                            storage_keyword = expected_keywords[this_keyword]
                                            this_crystal_type_dictionary[storage_keyword] = description_string
                                        else:
                                            # This should just be a numerical dimension.
                                            # Add this value to the dictionary for this crystal.
                                            this_value   = float(line_fields[1])
                                            storage_keyword = expected_keywords[this_keyword]
                                            this_crystal_type_dictionary[storage_keyword] = this_value

                                        # See if the definition is complete.
                                        keys_so_far = this_crystal_type_dictionary.keys()
                                        keys_so_far.sort()
                                        if expected_keywords_list  == keys_so_far:
                                            # The definition is complete.
                                            definition_finished = True
                                            # Print the detector read.
                                            print "  Understood crystal type \"", user_name_for_crystal, "\"."
                                            crystal_count += 1

                                except:
                                    print "Error parsing crystal types."
                                    print "No changes made."
                                    return -1
                                
                            line_number += 1

                        # Save this successfully read detector dictionary to a dict.
                        all_new_detector_dicts[user_name_for_crystal] = this_crystal_type_dictionary
                        # Record the order in which they were read, so that they appear in memory with type numbers in that order.
                        all_new_detector_names.append(user_name_for_crystal)

        except:
            print "Error parsing crystal types."
            print "No changes made."
            return -1


        # Now check that the types read from the user's file don't have the
        # same names as any in memory.  These names should be the same as the
        # ones in the file stored in the working directory.

        # Step through the types just read to find duplicate names in the
        # detector manager.  Duplicates should not be added, because they will
        # confuse the GUI.
        duplicate_found_in_memory = False
        for one_new_name in all_new_detector_names:
            existing_type_number = self.get_internal_type_number(one_new_name)
            if not existing_type_number == None:
                print "A crystal type called \"",one_new_name,"\" is in memory!"
                duplicate_found_in_memory = True
                
        print ""
        if duplicate_found_in_memory:
            block_print_with_line_breaks("One or more of the crystal names defined in this file were found in memory.  Set unique crystal names in the file, and try again.\nNo crystal types were saved.\n",60)
            return -1
        else:
            # Create the new detectors in memory.
            for one_new_name in all_new_detector_names:
                new_detector_parameter_dict = copy.deepcopy(all_new_detector_dicts[one_new_name])
                # This tool is used for generating detector arrays quickly, so no 4pi detectors should be added this way.
                new_detector_parameter_dict["four_pi"] = False  
                # Add the detector name to the dictionary for the session.
                new_detector_parameter_dict["detector_name"] = one_new_name 
                # Add the absorber thicknesses.
                new_detector_parameter_dict["l"] = absorber_thicknesses
                # Add to the physical detectors in memory (which will be sent to the GDET run for Gosia).
                self.alldetectors.append(physical_detector(new_detector_parameter_dict))
                print "Added new crystal type \"",one_new_name,"\" to this session."
        print ""


        # Check to see if any new type names are in the library read from disk.
        # Get all the type names read from the library on disk.
        library_type_names = all_library_types.keys()
        already_in_library = False
        for one_new_name in all_new_detector_names:
            if one_new_name in library_type_names:
                print "A crystal type called \"", one_new_name,"\" is already in the detector library!"
                already_in_library = True

        if already_in_library:
            block_print_with_line_breaks("If you save these new crystal types to the library (in the working directory), one or more types will be overwritten!",60)

        # Ask the user whether or not to save these to the library.
        save_to_library = yes_no_prompt("Save these new crystal types to the library file in the working directory [y/N]?",False)
        if save_to_library:
            for one_new_name in all_new_detector_names:
                new_detector_parameter_dict = copy.deepcopy(all_new_detector_dicts[one_new_name])
                # Add the new types to the standard type dictionary.
                current_local_ge_types[one_new_name] = new_detector_parameter_dict 
                # Update the standard types file in the working directory only (!) with this type.
                rachel_ge_types_file = "rv_rachel_detector_dict.txt"
            with open(rachel_ge_types_file,"w") as detector_dict_file:
                pickle.dump(current_local_ge_types,detector_dict_file)
            print "New crystal types saved to library."

        create_popup_tip("gdet_for_clusters")

        print "Done."
        
        return 0


    def newdetector(self):
        """Creates a new detector.

        An arbitrary number may be created.

        """

        # Set default thicknesses of 0 for all types.
        absorber_thicknesses = [0 for i in range(len(self.absorber_names))]

        # Geometric definition of standard types.  These do not include
        # absorber information.  NOTE: THESE MUST NOT BE DEFINED IN THE
        # __init__ METHOD!  IF THEY ARE, THEN THE POINTERS ARE NOT HANDLED
        # CORRECTLY, AND THE LIST OF physical_detector OBJECTS DOES NOT ACCESS
        # PARAMETERS CORRECTLY FOR OBJECTS WITH SIMILAR CONTENTS.  

        # Read the detector types from the rv_rachel_detector_dict.txt files in
        # both the installation directory and in the working directory.

        # (The file name has been changed to "rv_rachel_detector_dict.txt"
        #  because of a change in the format.)

        try:
            print "Trying to read detector types library from the file "
            print "\"rv_rachel_detector_dict.txt\" in the working directory..."
            rachel_ge_types_file = "rv_rachel_detector_dict.txt"
            with open(rachel_ge_types_file,"r") as detector_dict_file:
                local_ge_types = pickle.load(detector_dict_file)
            print "Read the detector types library from the working directory."
            read_local_types = True
        except:
            print "Could not find the detector types library in the working directory."
            print "(This is ok.)"
            read_local_types = False
            local_ge_types = {}

        try:
            print "Trying to read detector types library from the file "
            print "\"rv_rachel_detector_dict.txt\" in the Rachel installation directory..."
            rachel_ge_types_file = GLOBAL_SETUP_DICT["RACHEL_DIRECTORY"] + "/necessary_files/rv_rachel_detector_dict.txt"
            with open(rachel_ge_types_file,"r") as detector_dict_file:
                standard_ge_types = pickle.load(detector_dict_file)
            read_standard_types = True
        except:
            block_print_with_line_breaks("Could not find the detector types library in the installation directory.\n(You can create your own types, or you can get the newest detector library from Rochester.)",60)
            read_standard_types = False
            # Set empty dictionary for the standard types.
            standard_ge_types = {}
    

        # Prompt for a standard detector type, if desired.
        print "Standard types in library:"
        print "Name                    Description"
        print "---------------------------------------------------"
        if read_standard_types:
            # Get all the type names read from the file library file.
            standard_type_names = standard_ge_types.keys()
            standard_type_names.sort()

            for one_type_name in standard_type_names:
                # print one_type_name.ljust(20),"  ",standard_ge_types[one_type_name]["detector_description"]
                # To accomodate long descriptions:
                print one_type_name.ljust(20),"  ",
                description_lines = block_print_with_line_breaks(standard_ge_types[one_type_name]["detector_description"],50,True,False)
                for line_number in range(len(description_lines)):
                    one_line = description_lines[line_number]
                    if line_number == 0:
                        print one_line
                    else:
                        print "".ljust(20),"  ",one_line

        else:
            standard_type_names = []

        if read_local_types:
            print
            print "Types in local library (working directory):"
            print "Name                    Description"
            print "---------------------------------------------------"
            # Get all the type names read from the file library file.
            local_type_names = local_ge_types.keys()
            local_type_names.sort() 

            for one_type_name in local_type_names:
                # print one_type_name.ljust(20),"  ",local_ge_types[one_type_name]["detector_description"]
                # To accomodate long descriptions:
                print one_type_name.ljust(20),"  ",
                description_lines = block_print_with_line_breaks(local_ge_types[one_type_name]["detector_description"],50,True,False)
                for line_number in range(len(description_lines)):
                    one_line = description_lines[line_number]
                    if line_number == 0:
                        print one_line
                    else:
                        print "".ljust(20),"  ",one_line
                if len(description_lines) == 0:
                    # If the description is empty, need to print a blank line.
                    print ""

        else:
            local_type_names = []
            

        block_print_with_line_breaks("\nEnter one of the names above if desired, or a new alphanumeric name to define your own detector.\nNew in version 1.0 is an option to load physical detector definitions from a human-readable text file.  This is option \"ip\" in the Tools button menu.")

        name_is_invalid = True
        while name_is_invalid:
            type_name = raw_input("Enter detector name [\"q\" to quit]: ").strip()
            if type_name == "q" or type_name == "quit":
                print "Cancelled."
                return 0
            # Strip out whitespace from the type name.  This is vital to be
            # able to reference it from a detector array file.
            type_name = type_name.replace(" ","")
            if type_name == "":
                print "Detector name must have at least one character."
            else:
                name_is_invalid = False
                print "Name taken as \""+type_name+"\"."
                

        if type_name in standard_type_names:
            library_pointer = standard_ge_types
        elif type_name in local_type_names:
            library_pointer = local_ge_types
        else:
            library_pointer = None

        if library_pointer == None:
            # No standard type was chosen.  Prompt for all information.

            # If this is meant to be a 4pi array, then mark a flag.  This will 
            # have to be handled after the OP,GDET run of gosia by replacing 
            # appropriate fields in the .gdt file.
            four_pi = yes_no_prompt("Do you want a summed isotropic 4pi array [y/N]? ",False)
            if four_pi:
                # Make a detector with inner inactive radius very small.  The
                # efficiency curve will take care of everything else.
                detector_parameter_dict = {"detector_name":type_name,"detector_description":"Isotropic summed 4pi array","r":0.001,"R":3.55,"L":7.5,"d":25.25,"four_pi":True}
                new_type_added = True
            else:

                print "All length quantities are in cm."
                print "Enter \"q\" to quit."
                r = prompt_number("Radius of inactive p-core: ","f")
                if r  == "quit":
                    return 0
                R = prompt_number("Radius of active n-core: ","f")
                if R  == "quit":
                    return 0
                L = prompt_number("Length of crystal: ","f")
                if L  == "quit":
                    return 0
                d = prompt_number("Distance from target: ","f")
                if d  == "quit":
                    return 0
                detector_description = raw_input("Enter a short description: ")
                detector_parameter_dict = {"detector_name":type_name,"detector_description":detector_description,"r":r,"R":R,"L":L,"d":d,"four_pi":False}
                # The absorber definitions must be added later.
                new_type_added = True

        else:
            # Use standard type parameters for the 4 geometric quantities
            detector_parameter_dict = library_pointer[type_name]
            new_type_added = False

        # Get absorber information, or append 0's for the thicknesses For the
        # near future, Rachel will only accept relative-efficiency corrected
        # data.  Commenting this part out.

        detector_parameter_dict["l"] = absorber_thicknesses

        #block_print_with_line_breaks("This version of Rachel handles only data that have been corrected for the relative efficiencies of all Ge data over which the data are partitioned.  For accurate fitting, the data must be efficiency-corrected with a consistent relative efficiency for all data sets.  That is, the data must be corrected for the RELATIVE efficiency vs. gamma-ray energy and the relative efficiency of each detector, by any arbitrary overall normalization.")

        # If this detector name is in the detector manager already, force the
        # user to pick a unique name.  Otherwise, the "id" (import detector
        # array) function may find the wrong detector.
        all_type_names_in_session = self.get_all_detector_names_in_memory()
        if type_name in all_type_names_in_session:
            good_new_name = False
            original_choice = type_name
            while type_name in all_type_names_in_session or not good_new_name:
                block_print_with_line_breaks("This Ge type name is in use in this session.\nYou must pick a unique type name for this detector in this session.\nNo whitespaces are allowed.")
                type_name = raw_input("New type name: ").replace(" ","")
                if not type_name == "":
                    good_new_name = True
            # Now change the type name in the parameter dict before saving in the session.
            detector_parameter_dict["detector_name"] = type_name

            print "A copy of \"" + original_choice + "\" has been added as \"" + type_name + ".\"\nYou can change the efficiency parameters during simulations.\n(Real gamma-ray yield data must be efficiency-corrected.)"

        # Add to the physical detectors in memory (which will be sent to the GDET run for Gosia).
        self.alldetectors.append(physical_detector(detector_parameter_dict))

        # Add the detector type to the Ge types file, if a new type was
        # defined.  This will not include the four-pi status, so that a crystal
        # can be used as a single crystal or turned into a 4pi array at the
        # user's choice.
        if new_type_added:
            # Add this type to the standard type dictionary.
            local_ge_types[type_name] = detector_parameter_dict
            # Update the standard types file in the working directory only (!) with this type.
            rachel_ge_types_file = "rv_rachel_detector_dict.txt"
            with open(rachel_ge_types_file,"w") as detector_dict_file:
                pickle.dump(local_ge_types,detector_dict_file)

        self.display_all_physical_detectors()
        print "Finished."

        return 0

    def get_parameter_dict(self,detector_type_number):
        return self.alldetectors[detector_type_number].get_all_parameters()

    def get_detector_solid_angle(self,detector_type_number):
        """Returns the solid angle coverage of a Ge detector.

        This is the solid angle of a single Ge crystal (physical detector in
        Gosia terms--see manual).

        """
        parameters = self.get_parameter_dict(detector_type_number)
        if parameters["four_pi"]:
            return 4. * math.pi
        else:
            # Use the closed-form integral of solid angle:
            R = parameters["R"]
            d = parameters["d"]
            theta_half = math.atan(R/d)
            delta_Omega = 2. * math.pi * (1. - math.cos(theta_half))
            return delta_Omega


    def display_all_physical_detectors(self):
        """Prints the detector numbers and geometric definitions for all physically-different detectors.

        """

        lines_to_display = []

        this_line = str(self.getnumberofdetectors()) + " physical detectors have been defined."
        lines_to_display.append(this_line)
        for detector_number in range(self.getnumberofdetectors()):
            lines_to_display.append("------------------------------------------------------------")
            this_detector_parameter_dict = self.alldetectors[detector_number].get_all_parameters()
            this_type_line = "**Type** # " + str(detector_number + 1)  # User/gosia identity is internal number + 1
            lines_to_display.append(this_type_line)
            all_keys = this_detector_parameter_dict.keys()
            all_keys.sort()
            for item in all_keys:
                if not item == "l" and not "efficiency" in item:   # printing the absorber information is omitted now.  This can only cause confusion, because eff. corr. data are required.
                    parameter_value = this_detector_parameter_dict[item]
                    this_line = str(item) + " = " + str(parameter_value)
                    lines_to_display.append(this_line)

        # Add explanatory footnotes.
        lines_to_display.append("")
        footnotes = block_print_with_line_breaks("Parameter  Description\n------------------------------------------------------------\nL          length of crystal (cm)\nR          outer radius of crystal (cm)\nr          inner radius of inactive electrode (cm)\nd          distance from crystal face to target (cm)\nfour_pi    a flag indicating a summed isotropic 4pi array",60,True,False)
        lines_to_display.extend(footnotes)

        # Call the dialog popup class to either create a popup, or to write to the terminal if popups are disabled.
        arguments = {"text_lines":lines_to_display,"title":"Physical Ge types defined"}
        create_dialog_popup(arguments)


    def get_all_detector_names_in_memory(self):
        """Returns a list of the names of detectors in memory.

        """

        number_of_types = self.getnumberofdetectors()
        all_type_names = []

        for internal_type_number in range(number_of_types):
            all_type_names.append(self.get_type_name(internal_type_number))

        return all_type_names

    def generate_op_gdet(self):
        """Makes op,gdet input for gosia.

        If a detector type is marked as being 4pi (a full array), after op,gdet
        is run in gosia, another method must read the gdt file and change
        records for that detector type to make it simulate a 4pi array.

        If any experiment uses op raw, the first entry in the gdet input is
        flagged with a - sign to generate the extra file for op raw.

        """

        NPD = self.getnumberofdetectors()
        op_gdet_lines = ["OP,GDET"]

        # Ask the experiment manager if any experiment uses clusters:
        if the_experiment_manager.any_raw_detectors():
            # Raw detectors are in use.  Flag NPD with a - sign.
            npd_line = str(-1 * NPD)
        else:
            npd_line = str(NPD)

        op_gdet_lines.append(npd_line)

        for physical_detector_number in range(NPD):
            one_detector_entry_lines = self.alldetectors[physical_detector_number].get_op_gdet_entry()
            op_gdet_lines.extend(one_detector_entry_lines)

        return op_gdet_lines

    def remove_whitespace_from_detector_names(self):
        """To be called by version upgrade method.

        """

        for one_detector in self.alldetectors:
            current_name = one_detector.get_parameter("detector_name")
            new_name     = current_name.replace(" ","")
            one_detector.set_paramter("detector_name",new_name)

    def get_internal_type_number(self,type_name):
        """Returns the INTERNAL type number corresponding to the detector name.

        """

        for detector_number in range(len(self.alldetectors)):
            this_name = self.alldetectors[detector_number].get_parameter("detector_name")
            if this_name == type_name:
                return detector_number

        # If the loop is finished, and it didn't return, then the name was not
        # found.  Return None.

        return None

            
    def get_type_name(self,internal_type_number):
        """Returns the detector name of an INTERNAL type number.

        If the type number is not known, None is returned.

        """

        try:
            # If this fails, the internal type number is not one of the existing detector types.
            this_name = self.alldetectors[internal_type_number].get_parameter("detector_name")
        except:
            # This type is not in memory.  Return None
            this_name = None

        return this_name


    def retouch_gdt_file(self):
        """Reads the gdt file from disk.  

        If any detectors need adjustments after the OP,GDET run, then the 
        file is modified.
        """

        # Get name of file number 9 (the OP,GDET output).
        gdt_file_name = the_gosia_shell.get_base_file_name() + "." + FILE_DEF_DICT[9]["extension"]
        # Read the gdt file
        with open(gdt_file_name,'r') as gdt_file:
            gdt_lines = gdt_file.readlines()

        # See which detectors, if any, need modification.
        number_of_physical_detectors = self.getnumberofdetectors()
        for i in range(number_of_physical_detectors):
            needs_modification = self.alldetectors[i].get_parameter("four_pi")   # parameter "four_pi" is either True or False
            if needs_modification:
                # Get the line number in the gdt file for this detector.  The format of the gdt lines
                # is fixed, so we can calculate it.
                detector_line_number = 1 + i * 10   # numbering from zero in the list of lines
                q_line = detector_line_number + 2   # The line with the start of the attenuation parameters
                # Step through the 8 lines of atten. params. and replace the first two terms with 0's.
                for line_number in range(q_line,q_line+8):
                    line_fields = gdt_lines[line_number].split()
                    replacement_line = "0.  0.  " + line_fields[2] + " \n"
                    gdt_lines[line_number] = replacement_line

        # Write the final file.
        with open(gdt_file_name,'w') as gdt_file:
            gdt_file.writelines(gdt_lines)
            

class physical_detector:
    """A data set to define a gosia-type germanium detector

    Variables

    Parameters for detector definition are stored in self.detector_parameters_dict, 
    which must be passed in at definition.
        detector_parameter_dict = {"detector_name":detector_name,"r":r,"R":R,"L":L,"d":d,"l":absorber_thicknesses,"four_pi":True/False}

    """

    def __init__(self,parameter_dict):

        # Store the detector parameter definition permanently.
        self.detector_parameters_dict = parameter_dict
        self.expected_parameter_names = ["detector_name","r","R","L","d","l","four_pi"]

        # Other parameters are "efficiency_curve_type" and
        # "efficiency_parameters".  These will be set to defaults if they were
        # not in the dict passed.

        # If the efficiency curve parameters have not been defined, set them to
        # the default for a Gammasphere 7x7 cm crystal or the default for a 4pi
        # array like Gammasphere, if this is a summed 4pi array.

        # If the efficiency parameters were not passed in, set to the default
        # efficiency curve using Radware parameters and the measured efficiency
        # quoted in class detector manager appropriate for a single crystal or
        # summed 4pi array (similar to Gammasphere crystal or array).  See the
        # __init__ method in class detectormanager.

        # If the efficiency parameters were given, then leave them as they are.

        if not "efficiency_curve_type" in self.detector_parameters_dict or not "efficiency_parameters" in self.detector_parameters_dict:
            self.detector_parameters_dict["efficiency_curve_type"] = "radware"
            # Pick the default curve and absolute efficiency appropriate for a
            # single crystal or 4pi summed array.
            try:
                self.detector_parameters_dict["four_pi"]
            except:
                self.detector_parameters_dict["four_pi"] = False

            if self.detector_parameters_dict["four_pi"]:
                self.detector_parameters_dict["efficiency_parameters"] = copy.deepcopy(the_detector_manager.default_efficiency_parameters_four_pi_array)
            else:
                self.detector_parameters_dict["efficiency_parameters"] = copy.deepcopy(the_detector_manager.default_efficiency_parameters_single_crystal)

                

    def radware_efficiency(self,energy_keV,ep):
        """Internal use.  Returns relative efficiency for Radware parameters ep.

        ep is a dict {"A":1.5,"B":2.3,...,"G":1.0}

        Absolute efficiency is done in the accessor def absolute_efficiency by
        two calls to this method--one at the requested energy and one at the
        energy where the absolute efficiency has been defined by the user or by
        default (default assuming a 7x7 cm Ge crystal).

        """

        # See D. Radford, Nucl. Instruments and Methods A 361:297 (1995) for the
        # form of the efficiency curve.

        x = math.log(float(energy_keV) / 100.)
        y = math.log(float(energy_keV) / 1000.)

        first_quadratic  =   ep["A"]  +  ep["B"] * x  +  ep["C"] * x**2
        second_quadratic =   ep["D"]  +  ep["E"] * y  +  ep["F"] * y**2
        ln_efficiency = (first_quadratic**(-ep["G"]) + second_quadratic**(-ep["G"]))**(-1. / ep["G"])
        relative_efficiency = math.exp(ln_efficiency)

        return relative_efficiency

    def miniball_efficiency(self,energy_keV,ep):
        """Internal use.  Returns relative efficiency for Miniball parameters ep.

        ep is a dict {"a0":1.5,"a1":2.3,...}

        Absolute efficiency is done in the accessor def absolute_efficiency by
        two calls to this method--one at the requested energy and one at the
        energy where the absolute efficiency has been defined by the user or by
        default (default assuming a 7x7 cm Ge crystal).

        """

        # See D. Radford, Nucl. Instruments and Methods A 361:297 (1995) for the
        # form of the efficiency curve.

        # math.log is ln.
        relative_efficiency = ep["a0"] + ep["a1"]*math.log(energy_keV) \
          + ep["a2"]*(math.log(energy_keV))**2 + ep["a3"]*(math.log(energy_keV))**3 + ep["a4"]*(math.log(energy_keV))**4

        return relative_efficiency


    def absolute_efficiency(self,energy_keV):
        """Calculates the absolute efficiency at the requested energy in keV.

        This is an accessor that determines the type of efficiency curve
        parametrization selected by the user (default Radware) and calls the
        appropriate function to get the efficiency value.

        This is used only in simulations.  Real data in the GUI are
        efficiency-corrected for the relative efficiency.

        There are two additional parameters added to every set of
        "efficiency_parameters": 
        
        "absolute_calibration_energy_keV" and "absolute_calibration_absolute_efficiency"
        
        These are used to scale the relative efficiency to give the absolute
        efficiency.

        If the curve is not well-defined at the requested energy, None is returned.

        """

        # Get the type of efficiency curve parametrization.
        curve_type = self.detector_parameters_dict["efficiency_curve_type"]
        # Get the dictionary of efficiency parameters.
        ep = self.detector_parameters_dict["efficiency_parameters"]

        # Use the formula corresponding to the requested curve type.
        if curve_type == "radware":
            try:
                relative_efficiency = self.radware_efficiency(energy_keV,ep)
                relative_efficiency_at_absolute_calibration_point = self.radware_efficiency(ep["absolute_calibration_energy_keV"],ep) 
                can_calculate = True
            except:
                can_calculate = False
        elif curve_type == "leuven":
            print "LEUVEN CURVE NOT FINISHED"
            relative_efficiency = 1.0  # NOT FINISHED
            relative_efficiency_at_absolute_calibration_point = 1.0  # NOT FINISHED
        elif curve_type == "miniball":
            try:
                relative_efficiency = self.miniball_efficiency(energy_keV,ep)
                relative_efficiency_at_absolute_calibration_point = self.miniball_efficiency(ep["absolute_calibration_energy_keV"],ep) 
                can_calculate = True
            except:
                can_calculate = False


        # Get the absolute efficiency using the user's specified absolute
        # energy at some reference energy.
        if can_calculate:
            if relative_efficiency <= 0. or relative_efficiency_at_absolute_calibration_point <= 0.:
                absolute_efficiency = None
            else:
                absolute_efficiency = relative_efficiency * ep["absolute_calibration_absolute_efficiency"] / relative_efficiency_at_absolute_calibration_point 
        else:
            absolute_efficiency = None  # Efficiency curve not well-defined at this energy.

        return absolute_efficiency

    def get_efficiency_curve_type(self):
        curve_type = self.detector_parameters_dict["efficiency_curve_type"]
        return curve_type

    def get_efficiency_parameters(self):
        # Get the dictionary of efficiency parameters.
        ep = self.detector_parameters_dict["efficiency_parameters"]
        return ep

    def get_efficiency_vs_energy(self):
        """Returns two lists: energy points, efficiency points

        energy points are in keV,
        efficiency is by the standard definition of photopeak efficiency

        """

        energies = list(numpy.linspace(50.,2000.,100))
        efficiencies = []

        for energy_keV in energies:
            efficiency = self.absolute_efficiency(energy_keV)
            efficiencies.append(efficiency)

        return energies, efficiencies


    def get_parameter_names(self):
        """Returns all expected parameter names as a list of strings.

        Note that "l" is expected to point to a list of 7 floats.
        """
        return self.expected_parameter_names

    def get_parameter(self,which_parameter):
        try:
            return self.detector_parameters_dict[which_parameter]
        except:
            return None

    def set_parameter(self,which_parameter,value):
        self.detector_parameters_dict[which_parameter] = value
        return 0

    def get_op_gdet_entry(self):
        """Returns lines for one detector which can go directly into OP,GDET.

        NPD, the number of physically-different detectors is handled by the
        detectormanager class and is not returned.
        """
        # These are strings, since they will go into the op,gdet input for gosia
        r = self.detector_parameters_dict["r"]
        R = self.detector_parameters_dict["R"]
        L = self.detector_parameters_dict["L"]
        d = self.detector_parameters_dict["d"]

        line_1_list = [r,R,L,d]
        line_1 = str(line_1_list).strip('[]')    # e.g. "0.1, 5.0, 10.0, 12.5"
        line_2 = str(self.detector_parameters_dict["l"]).strip('[]')  # This is a list of 7 entries converted to a string.

        # Construct a list of strings for gosia gdet entry
        gdet_entry_lines = [line_1,line_2]

        return gdet_entry_lines

    def get_all_parameters(self):
        """Returns the full parameter dictionary used to create the detector.

        """
        return self.detector_parameters_dict

###############################################################################



################################################################################
# Global objects defined here
def setup_globals(action=None,pickle_file_name=None,force=False,rotate=False):
    """Defines global objects and pickles/unpickles them.

    The pickle_file_name is optional.  If it is included, then force can be set
    to True, so that no "are  you sure" prompts will be given.
    
    action "reset" is to prepare for an undo/redo operation.  It keeps the undo
    object, but destroys the others (as much as Python can destroy).

    if rotate==True logrotate is called to keep rotating backups.

    """

    def write_rotate_config():
        try:
            with open(ROTATE_CONFIG_FILE_NAME, 'w') as config_file:
                config_file.writelines(LOGROTATE_CONFIG)
            return True
        except:
            return False

    if action == "new":
        # Create the global objects, including the undo object
        global undo
        global investigated_nucleus
        global the_gosia_shell
        global the_detector_manager
        global the_experiment_manager
        global restored_version
        undo = undo_class()
        investigated_nucleus = nucleus()
        the_gosia_shell = gosia_shell()
        the_detector_manager = detectormanager()
        the_experiment_manager = experimentmanager()
        restored_version = "0"

        # Create the temporary data storage object.  This is not saved.
        global temporary_data_storage
        temporary_data_storage = data_storage()


    elif action == "recover":
        # Create the global objects, and recover the last undo operation
        investigated_nucleus = nucleus()
        the_gosia_shell = gosia_shell()
        the_detector_manager = detectormanager()
        the_experiment_manager = experimentmanager()
        undo = undo_class("recover")

    elif action == "reset":
        # for undo/redo preparation
        # Need to force the GUI to forget what objects are in memory now.
        investigated_nucleus = 0
        the_gosia_shell = 0
        the_detector_manager = 0
        the_experiment_manager = 0
        restored_version = "0"
        investigated_nucleus = nucleus()
        the_gosia_shell = gosia_shell()
        the_detector_manager = detectormanager()
        the_experiment_manager = experimentmanager()

    elif action == "unpickle":
        if force:
            # Don't prompt user
            go_ahead = True
        else:
            print "LOAD SESSION: ",
            go_ahead = yes_no_prompt("This will overwrite any session in memory. Are you sure [y/N]? ",False)
        if go_ahead:
            if pickle_file_name == None:
                pickle_file_name = 'pickle.jar'
            try:
                with open(pickle_file_name ,'r') as picklefile:
                    try:
                        investigated_nucleus = pickle.load(picklefile)
                        if not force:
                            print "Nucleus restored.  Drawing level scheme..."
                            investigated_nucleus.draw_level_scheme()
                            print "Done."
                    except:
                        if not force:
                            print "Nuclear data not found in pickle jar."
                            print "Was this file sent via email with the wrong encoding?"
                        else:
                            print "UNDO: Could not restore nuclear data."
                    try:
                        the_experiment_manager = pickle.load(picklefile)
                        if not force:
                            print "Experimental parameters restored."
                    except:
                        if not force:
                            print "Experimental parameters not found in pickle jar."
                            print "Was this file sent via email with the wrong encoding?"
                        else:
                            print "UNDO: Could not restore experimental parameters."
                    try:
                        the_detector_manager = pickle.load(picklefile)
                        if not force:
                            print "Detector definitions restored."
                    except:
                        if not force:
                            print "Detector definitions not found in pickle jar."
                            print "Was this file sent via email with the wrong encoding?"
                        else:
                            print "UNDO: Could not restore detector definitions."
                    try:
                        the_gosia_shell = pickle.load(picklefile)
                        if not force:
                            print "Gosia shell restored."
                    except:
                        if not force:
                            print "Gosia shell not found in pickle jar."
                            print "Was this file sent via email with the wrong encoding?"
                        else:
                            print "UNDO: Could not restore the Gosia shell."
                    try:
                        restored_version = "0"
                        if not force:
                            print "Checking version number of this session..."
                        restored_version = pickle.load(picklefile)
                        if not force:
                            version_text = "This session is from version "+str(restored_version)+".\nCheck upgrade information in the control panel."
                            print version_text 
                    except:
                        if not force:
                            version_string = "\nNO VERSION NUMBER FOUND IN SESSION FILE.\nEither the session file is corrupted, or pre-dates the release version.  If you cannot repair the file, then you will have to start a new session."
                            block_print_with_line_breaks(version_string,60)
            except:
                # Couldn't open pickle file
                return_text = "No session file named " + pickle_file_name + " was found in the working directory."
                print "No session file named " + pickle_file_name + " was found in the working directory."
                return 1,[return_text]

            if not force:
                if not VERSION == restored_version:
                    first_paragraph = "This session file predates version "+VERSION+".  An attempt will be made to upgrade this session to version "+VERSION+" format.  Check to make sure the upgraded session operates in the new GUI, and then save the session if the upgrade was successful."
                    text_view_output_lines = textwrap.wrap(first_paragraph,TEXTVIEW_COLUMNS) 
                    other_text = "  If this does not work, then you may need to start again with a new session.  You can use your former Rachel version to export nuclear data and then import it into a new version " + str(VERSION) + " session."
                    text_view_output_lines.extend(textwrap.wrap(other_text,TEXTVIEW_COLUMNS))

                    try:
                        nucleus_returned_errors,     nucleus_upgrade_text     = investigated_nucleus.for_upgrade(restored_version)
                        experiment_returned_errors,  experiment_upgrade_text  = the_experiment_manager.for_upgrade(restored_version)
                        gosia_shell_returned_errors, gosia_shell_upgrade_text = the_gosia_shell.for_upgrade(restored_version)
                        detector_returned_errors,    detector_upgrade_text    = the_detector_manager.for_upgrade(restored_version)
                        returned_errors = nucleus_returned_errors + experiment_returned_errors + gosia_shell_returned_errors + detector_returned_errors

                        if returned_errors == 0:
                            text_view_output_lines.extend(nucleus_upgrade_text)
                            text_view_output_lines.extend(experiment_upgrade_text)
                            text_view_output_lines.extend(gosia_shell_upgrade_text)
                            text_view_output_lines.extend(detector_upgrade_text)
                            text_view_output_lines.extend(textwrap.wrap("The session appears to have been upgraded successfully.",TEXTVIEW_COLUMNS))
                            error_count_line =  str(returned_errors) + " errors detected in upgrade."
                            text_view_output_lines.extend(["\n", error_count_line,"\n"])
                        else:
                            print "There were problems upgrading the session.  See the output in the control panel."
                            error_count_line =  str(returned_errors) + " errors detected in upgrade."
                            text_view_output_lines.extend(["\n", error_count_line,"\n"])
                            if not gosia_shell_returned_errors == 0:
                                gosia_shell_warning = "  The gosia shell could not be upgraded.  You may need to start again with a new session.  You can use your former Rachel version to export nuclear data and then import into a new version " + str(VERSION) + " session."
                                text_view_output_lines.extend(textwrap.wrap(gosia_shell_warning,TEXTVIEW_COLUMNS))
                                text_view_output_lines.extend(gosia_shell_upgrade_text)
                            else:
                                text_view_output_lines.extend(["You may need to rebuild the following definitions:"])
                                if not nucleus_returned_errors == 0:
                                    text_view_output_lines.extend(["  Nuclear data"])
                                if not experiment_returned_errors == 0:
                                    text_view_output_lines.extend(["  Experimental definitions"])
                                if not detector_returned_errors == 0:
                                    text_view_output_lines.extend(["  Physical Ge detector definitions"])
                                text_view_output_lines.extend(nucleus_upgrade_text)
                                text_view_output_lines.extend(experiment_upgrade_text)
                                text_view_output_lines.extend(detector_upgrade_text)
                        text_view_output_lines.extend(["\n"])
                    except:
                        failure_string += "  The upgrade was NOT successful.  You may need to start again with a new session.  You can use your former Rachel version to export nuclear data and then import into a new version " + str(VERSION) + " session."
                        text_view_output_lines.extend(textwrap.wrap(failure_string,TEXTVIEW_COLUMNS))
                    finally:
                        # Do this no matter what.
                        #text_view_output_lines.extend(textwrap.wrap("You should probably run \"Make Ge det file\" again and Write the Gosia yld file again to be sure that these files match the contents of this session.",TEXTVIEW_COLUMNS))
                        text_view_output_lines.extend([""])
                        text_view_output_lines.extend(["Check carefully for errors above."])
                        return returned_errors,text_view_output_lines

                else:
                    # This session file is for the present version.
                    print "No updates necessary."
                block_print_with_line_breaks("If you have run calculations with other session files in the same working directory, you should write the Gosia yld file, re-run \"Make Ge det file\" and before fitting rewrite the yield data with \"Write Gosia yld file\" and re-run \"Make corrected yields\".  This will restore external files to the proper state for this session.")


        return 0,[]  # an empty error list is returned to be compatible with error reports from upgrade calls.

    elif action == "pickle":
        if force:
            # Don't prompt user
            go_ahead = True
        else:
            print "\nSAVE TO SESSION FILE: ",
            go_ahead = None
            while go_ahead == None:
                go_ahead = yes_no_prompt("Are you sure [y/n]? ",None)
                if len(investigated_nucleus.levels) == 0:
                    # No levels in memory--user may be saving an empty session.
                    print "\n\nTHE NUCLEUS IS NOT DEFINED.  ARE YOU SAVING AN EMPTY SESSION???\n"
                    go_ahead = yes_no_prompt("Are you REALLY sure [y/n]? ",None)
        if go_ahead:
            if pickle_file_name == None:
                pickle_file_name = 'pickle.jar'
            if rotate:
                # Rotate the existing pickle.jar, if it exists.
                # For now, we write the rotate config file each time.
                success = write_rotate_config()
                if success:
                    rotate_command = "logrotate --state rachel_session_rotate_state " + ROTATE_CONFIG_FILE_NAME
                    try:
                        subprocess.call(rotate_command,shell=True)
                    except:
                        print "UNABLE TO ROTATE THE SESSION FILE BACKUPS."
                else:
                    print "UNABLE TO ROTATE THE SESSION FILE BACKUPS."
                    # Continue to save the session anyway.
            with open(pickle_file_name,'w') as picklefile:
                try:
                    # Remove the existing pickle file, because the pickle module doesn't completely overwrite it.
                    #os.remove(pickle_file_name)  # This is a poor choice, because I can't redirect errors to a file.
                    command_line = "rm " + pickle_file_name
                    with open(".rachel_garbage","w") as garbage_file:
                        subprocess.call(command_line,shell=True,stderr=garbage_file)  # (Redirect file not found errors to the garbage file.)
                except:
                    pass # If the file didn't exist, then it doesn't need to be removed.
                with open(pickle_file_name,'w') as picklefile:
                    try:
                        pickle.dump(investigated_nucleus,picklefile)
                        if not force:
                            print "Saved nuclear data."
                    except:
                        if not force:
                            print "No nuclear data to save."
                    try:
                        pickle.dump(the_experiment_manager,picklefile)
                        if not force:
                            print "Saved experimental parameters."
                    except:
                        if not force:
                            print "No experimental parameters to save."
                    try:
                        pickle.dump(the_detector_manager,picklefile)
                        if not force:
                            print "Saved detector definitions."
                    except:
                        if not force:
                            print "No detector definitions to save."
                    try:
                        pickle.dump(the_gosia_shell,picklefile)
                        if not force:
                            print "Saved gosia shell."
                    except:
                        if not force:
                            print "No gosia shell to save."
                    try:
                        pickle.dump(VERSION,picklefile)
                        if not force:
                            print "Saving version number " + VERSION
                            print "Saved version number."
                    except:
                        if not force:
                            print "No version number to save."

#############################################################################################

def read_dot_rachel_setup_file():
    try:
        # Look for the setup file in the current directory.
        setup_file = open(".rachel_setup","r") 
        print "Rachel setup file found in current directory."
    except:
        try:
            # If it was not in the current directory, look in the 
            # user's home directory
            print "Rachel setup file not found in working directory.  \nLooking in home directory..."
            home_directory = os.path.expanduser("~")
            setup_file_name_with_full_path = home_directory + "/.rachel_setup"
            print "Looking for ",setup_file_name_with_full_path 
            setup_file = open(setup_file_name_with_full_path ,"r") 
            print "Found setup file in home folder."
        except:
            return -1
        
    try:
        # The file should look like
        # ELAST_EXECUTABLE = "elast"
        # GOSIA_EXECUTABLE = "gosia"
        # etc.
        setup_lines = setup_file.readlines()
        setup_file.close()
        # Make a dict for global variables
        global GLOBAL_SETUP_DICT
        GLOBAL_SETUP_DICT = {}
        for one_line in setup_lines:
            line_fields = one_line.split()
            if len(line_fields) == 3:
                # Only evaluate if the line has three fields (skip blank lines)
                GLOBAL_SETUP_DICT[line_fields[0]] = line_fields[2] # set the value of this global as requested in the setup file
        # Special cases:
        if "MAXIMUMUNDOSTEPS" in GLOBAL_SETUP_DICT.keys():
            GLOBAL_SETUP_DICT["MAXIMUMUNDOSTEPS"] = int(GLOBAL_SETUP_DICT["MAXIMUMUNDOSTEPS"]) # Make sure this is an integer.
        if not "POPUPS" in GLOBAL_SETUP_DICT.keys():
            # Set default to no popups, if the user didn't specify in the setup file.
            GLOBAL_SETUP_DICT["POPUPS"] = False
        else:
            # Change this dictionary entry to a real Boolean value, not a string "True"/"False".
            boolean_value = eval(GLOBAL_SETUP_DICT["POPUPS"])
            GLOBAL_SETUP_DICT["POPUPS"] = boolean_value 
        if not "POPUP_TIPS" in GLOBAL_SETUP_DICT.keys():
            # Set default to no popups, if the user didn't specify in the setup file.
            GLOBAL_SETUP_DICT["POPUP_TIPS"] = True
        else:
            # Change this dictionary entry to a real Boolean value, not a string "True"/"False".
            boolean_value = eval(GLOBAL_SETUP_DICT["POPUP_TIPS"])
            GLOBAL_SETUP_DICT["POPUP_TIPS"] = boolean_value 
            
    except:
        return -1

def generate_dot_rachel_setup_file():
    """Interactively attempts to generate a new setup file.

    """

    print "Could not read setup file!"
    print "One will be generated in the current working directory."
    try:
        setup_variables = ["ELAST_EXECUTABLE = ","GOSIA_EXECUTABLE = ","BRICC_IDX_FILE = ","BRICC_ICC_FILE = ","RACHEL_DIRECTORY = "]
        while True:
            home_path = os.path.expanduser("~")
            setup_values = []
            temp_string = prompt_for_file_name(prompt_string = "Please enter the name of the elast executable, including the full path: ")
            setup_values.append(temp_string) 
            temp_string = prompt_for_file_name(prompt_string = "Please enter the name of the gosia executable, including the full path: ")
            setup_values.append(temp_string) 
            temp_string = prompt_for_file_name(prompt_string = "Please enter the name of the BRICC .idx file, including the full path, if it is not in working directory: ")
            setup_values.append(temp_string) 
            temp_string = prompt_for_file_name(prompt_string = "Please enter the name of the BRICC .icc file, including the full path, if it is not in working directory: ")
            setup_values.append(temp_string) 
            temp_string = prompt_for_file_name(prompt_string = "Please enter the full path to the directory where the Rachel executable is stored: ")
            # Strip the final / from the rachel directory, if there is one.
            if temp_string[-1] == "/":
                temp_string = temp_string[:-1]
            setup_values.append(temp_string) 
            lines_to_write = []
            for n in range(len(setup_variables)):
                lines_to_write.append(setup_variables[n] + setup_values[n] + "\n")
            with open(".rachel_setup","w") as new_setup_file:
                new_setup_file.writelines(lines_to_write)
            print ".rachel_setup file has been created in the current working directory."
            print "Attempting to re-read the file..."
            error_code_returned = read_dot_rachel_setup_file()
            if error_code_returned == -1:
                return -1
            else:
                print "Setup file was readable."
                return 0

    except:
        print "Could not create the setup file.  See the Rachel manual."
        print "Quitting."
        quit()

def test_rachel_setup():

    # Now test the directory and file specifications in the rachel setup file.
    # Write system errors to a temporary error file.
    error_file_name = ".rachel_temporary_file_for_errors"
    with open(error_file_name,"w") as error_file:
        # Test the elo executable
        command_line = "which " + GLOBAL_SETUP_DICT["ELAST_EXECUTABLE"] + " > .rachel_garbage"
        subprocess.call(command_line,shell=True,stderr=error_file)
        # Test the gosia executable
        command_line = "which " + GLOBAL_SETUP_DICT["GOSIA_EXECUTABLE"] + " > .rachel_garbage"
        subprocess.call(command_line,shell=True,stderr=error_file)
        # Test the BRICC .idx file.
        command_line = "ls " + GLOBAL_SETUP_DICT["BRICC_IDX_FILE"] + " > .rachel_garbage"
        subprocess.call(command_line,shell=True,stderr=error_file)
        # Test the BRICC .icc file.
        command_line = "ls " + GLOBAL_SETUP_DICT["BRICC_ICC_FILE"] + " > .rachel_garbage"
        subprocess.call(command_line,shell=True,stderr=error_file)
        # Check for the rachel directory.
        command_line = "ls " + GLOBAL_SETUP_DICT["RACHEL_DIRECTORY"] + " > .rachel_garbage"
        subprocess.call(command_line,shell=True,stderr=error_file)
    # Now give a report of any errors.
    with open(error_file_name,"r") as error_file:
        error_lines = error_file.readlines()
    # Delete the temporary error file.
    with open(".rachel_garbage","w") as garbage_file:
        command_line = "rm " + error_file_name
        subprocess.call(command_line,shell=True,stderr=garbage_file)
    print "If there are any errors reported below, you may want to"
    print "  remake the setup file, either interactively, or in a text editor."
    print "--------------------------------------------------------------------------------"
    if len(error_lines) == 0:
        print "No errors!"
        errors = False
    else:
        errors = True
        for error_line in error_lines:
            print error_line
    print "--------------------------------------------------------------------------------"
    # Show the current state of the setup.
    print "Current Rachel setup: "
    for one_key in GLOBAL_SETUP_DICT.keys():
        print one_key, " = ", GLOBAL_SETUP_DICT[one_key]
    if errors:
        if yes_no_prompt("Do you want to remake the setup file interactively [Y/n]: ",True):
            generate_dot_rachel_setup_file()
            return 0
        else:
            block_print_with_line_breaks("Check the online Rachel wiki or the Gosia manual chapter on Rachel.  The GUI cannot start without a .rachel_setup file.  Quitting.")
            quit()
    else:
        return 0

def cleanup_garbage_files():
    command_line = "rm .rachel_garbage"
    subprocess.call(command_line,shell=True)





#############################################################################################

# Main GUI class

class main_gui:
    """The callbacks for the main_gui class mostly have the following structure:

       #deactivate all button presses while this runs.
       self.set_deactivation(self,self.all_button_list)  # This freezes the GUI buttons and turns them grey.
       while gtk.events_pending():                 # This allows the GUI buttons to be
           gtk.main_iteration(False)               # frozen immediately, even if some subprocess.call
                                                   # takes a long time to process.
       try:

           [callback commands]

       except:
           # Reactivate GUI buttons.                   # If some error is not trapped properly by the try/except
           self.set_activation(self,self.all_button_list)  # structures in the [callback commands], then this ensures
           return -1                                   # that the GUI is unfrozen after the callback completes.

    """

    # Callbacks for the main_gui buttons follow.
    
    def set_deactivation(self,widget,button_pointers):

        # Flush the input buffer, so that accidental keystrokes don't go into the next prompt.
        tcflush(sys.stdin, TCIOFLUSH)

        # Deactivate all GUI buttons
        for one_button in button_pointers:
            one_button.set_sensitive(False)
        # Make sure the "Reactivate GUI" button is working.
        if not RECOVERY_MODE:
            self.activate_button28()

    def set_activation(self,widget):
        # Re-activate GUI buttons
        if RECOVERY_MODE:
            button_list = self.recovery_mode_button_list
        else:
            button_list = self.all_button_list
            
        for one_button in button_list:
            one_button.set_sensitive(True)

    def set_recovery_mode(self,widget):
        # Deactivate all GUI buttons
        self.set_deactivation(self,self.all_button_list)
        # Set to active only the buttons for recovery mode.
        self.set_activation(self)

    def activate_textview(self):
        # This does not work when calling outside of the GUI.
        self.scrolled_window.set_sensitive(True)

    def activate_button27(self):
        # Make sure the Examine fig. window button is active.
        self.button27_pointer.set_sensitive(True)

    def activate_button28(self):
        # Make sure the "Reactivate GUI" button is working, in case an untrapped error freezes the GUI.
        self.button28_pointer.set_sensitive(True)

    def activate_band_entries(self):
        self.initial_band_entry.set_sensitive(True)
        self.final_band_entry.set_sensitive(True)
            

    # Callback for Undo button
    def undo(self,widget):
        # Recover the previous states of all objects.
        return_code = undo.undo()
        if return_code == 0:
            investigated_nucleus.draw_level_scheme()

    def redo(self,widget):
        undo.redo()
        investigated_nucleus.draw_level_scheme()

    # Callback for "Go" button
    def gosia_go(self,widget):

        print_separator()

        gosia_function = self.get_active_text(self.gosiafunctioncombobox)
        gosia_action = self.get_active_text(self.gosiaactioncombobox)
   
        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)

        # Call the function in the nucleus object that sets up any missing
        # information required to run gosia.  Same for experimentmanager.
        nucleus_ready = investigated_nucleus.is_ready()
        experiments_ready = the_experiment_manager.is_ready()
        detectors_ready = the_detector_manager.is_ready()

        try:
            gosia_function_display_text = "Gosia function: " + gosia_function + "\n"
            if gosia_function == "Estimate normalizations":
                the_experiment_manager.calculate_ynrm_constants()
                self.set_activation(self)
                undo.save("Estimate normalizations")
                return 0
        
        except:
            print "The Gosia function and action must be selected to the left of the Go button."
            self.set_activation(self)
            print "Quitting."
            return -1

        # All other functions are handled below.
        try:
            gosia_function_display_text = "Gosia function: " + gosia_function + "\n"
            gosia_action_display_text = "Gosia action: " + gosia_action + "\n"
        except:
            # Nothing was selected
            print_error_block("The Gosia function and action must be selected to the left of the Go button.")
            self.set_activation(self)
            print "Quitting."
            return -1

        if gosia_function == "Make Ge det file":
            create_popup_tip("make_ge_det_file")
            if detectors_ready:
                gosia_shell_output = the_gosia_shell.generate(gosia_function,gosia_action)
                if gosia_shell_output == -1:
                    print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                    self.set_activation(self)
                    return -1
                if gosia_action == "View gosia input":
                    for line in gosia_shell_output:
                        line = line + "\n"         # newlines are needed for a list without newlines in the strings
                        self.insertnewtext(line)
                elif gosia_action == "Run gosia input":
                    # Not displaying full output for normalization calculation,
                    # since this uses a dummy level scheme that might be
                    # confusing to the user.
                    for line in gosia_shell_output:
                        self.insertnewtext(line)
                self.set_activation(self)
                print "Done."
                return 0
            else:
                print_error_block("You need to define at least one physical detector first (Button \"Define Ge det.\")")
                self.set_activation(self)
                return -1

        elif gosia_function == "Calculate lifetimes":
            if not nucleus_ready:
                print_error_block("You need a level scheme and matrix to calculate lifetimes.")
                self.set_activation(self)
                return -1
                
            # Write a dummy gdt file.
            if gosia_action == "Run gosia input":
                with open("gosia.rachel_dummy_gdt_file","w") as dummy_gdt_file:
                    dummy_gdt_file.writelines([\
                                               "1\n",\
                                               "25.250000000000000     \n",\
                                                "5.00000007450580597E-002\n",\
                                                "0.  0.  0.99515161576556677 \n",\
                                                "0.  0.  0.98550186179144739 \n",\
                                                "0.  0.  0.97114419718610112 \n",\
                                                "0.  0.  0.95221739364644353 \n",\
                                                "0.  0.  0.93799457708902401 \n",\
                                                "0.  0.  0.90142742262269437 \n",\
                                                "0.  0.  0.87005066192570901 \n",\
                                                "0.  0.  0.83507172411160402 \n"\
                                               ])

            gosia_shell_output = the_gosia_shell.generate(gosia_function,gosia_action)
            if gosia_shell_output == -1:
                print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                self.set_activation(self)
                return -1
            if gosia_action == "View gosia input":
                for line in gosia_shell_output:
                    line = line + "\n"         # newlines are needed for a list without newlines in the strings
                    self.insertnewtext(line)
            elif gosia_action == "Run gosia input":
                # Not displaying full output for normalization calculation,
                # since this uses a dummy level scheme that might be
                # confusing to the user.
                for line in gosia_shell_output:
                    self.insertnewtext(line)
            self.set_activation(self)
            print "Done."
            return 0
            

        elif gosia_function == "Integrated yields" or gosia_function == "Fit" or \
          gosia_function == "Make corrected yields":
            if nucleus_ready and experiments_ready:
                # Tell the gosia shell what type of output to generate (gdet,op intg, op mini, etc.)
                # and what do do with it (return the text here, save it, or run gosia with it).
                # The gosia_shell_output will have different types, depending on the action
                # requested.

                # Give the relevant popup tip for the selected function.
                if gosia_function == "Integrated yields":
                    create_popup_tip("after_integrated_yields")
                elif gosia_function == "Fit":
                    create_popup_tip("after_fit")
                elif gosia_function == "Make corrected yields":
                    block_print_with_line_breaks("DO YOU NEED TO WRITE UPDATED YIELD DATA TO THE gosia.yld FILE?\nThis should be done after loading data or changing the experimental setup, level scheme, or matrix.  \nTo write it now, select \"Y.\"")
                    to_write = yes_no_prompt("Write gosia.yld file [Y/n]? ",True)
                    if to_write:
                        self.write_true_yields(self,to_force=True)
                    create_popup_tip("after_corrected_yields")

                if gosia_function == "Fit":
                    # Call for OP,MAP first, in a separate calculation.  On
                    # some systems MAP and MINI can not be run in the same
                    # call.
                    
                    gosia_shell_output = the_gosia_shell.generate("Map",gosia_action)
                    if gosia_shell_output == -1:
                        print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                        self.set_activation(self)
                        return -1

                gosia_shell_output = the_gosia_shell.generate(gosia_function,gosia_action)
                if gosia_shell_output == -1:
                    print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                    self.set_activation(self)
                    return -1
                else:
                    # Give a brief report of chi-squared.  This is more accurate than the fit output in some cases.
                    if gosia_function == "Integrated yields" and gosia_action == "Run gosia input":
                        the_experiment_manager.properly_weighted_chi_squared_report()

                # If the function was to fit, ask the user now whether the new fitted matrix elements
                # should be read in to replace the originals.  
                if gosia_function == "Fit" and gosia_action == "Run gosia input":
                    block_print_with_line_breaks("If you intend to plot the calculated yields vs. the measured yields, or iterate the fit to try to find a better minimum, then you should replace your original matrix elements with the best-fit values.  You will still be able to modify them or change fit parameters and dependencies before iterating.  Before plotting yields with the new matrix elements, run \"Integrated yields\" again with the best-fit matrix.\nTo iterate the fit again, change any matrix elements or fit parameters if desired, then run \"Make corrected yields\" before fitting again.")
                    read_best_matrix_elements = yes_no_prompt("Replace original matrix elements with best-fit values [Y/n]? ",True)
                    print "Matrix elements that hit user limits, if any:"
                    print "--------------------------------------------------------------------------------"
                    if read_best_matrix_elements:
                        # Call the nucleus method to read the best matrix elements from the .bst file.
                        bst_file_name = the_gosia_shell.base_file_name + ".bst"
                        investigated_nucleus.read_best_fit_matrix_elements(bst_file_name)
                        print "Choose option \"p\" from the \"Examine setup\" button menu to see the new matrix elements."
                    print "--------------------------------------------------------------------------------"
                    # Display the fitted Ge(Li) efficiencies for the user to evaluate.
                    #the_experiment_manager.read_fitted_geli_efficiencies_from_gosia(False)  # False flag means not to apply them at this point.
                    #read_new_ynrm = yes_no_prompt("Apply new Ge(Li) efficiencies fitted by Gosia [y/N]? ")
                    #if read_new_ynrm:
                        # Tell the experiment manager to read them from the
                        # gosia output and distribute to experiment objects.
                        # the_experiment_manager.read_fitted_geli_efficiencies_from_gosia(True) # True flag means to apply them.
                    # Save the undo information from this step.
                    # undo.save("Gosia fit")

                # Take the requested action, if it can be handled here.
                if gosia_action == "View gosia input":
                    for line in gosia_shell_output:
                        line = line + "\n"         # newlines are needed for a list without newlines in the strings
                        self.insertnewtext(line)
                elif gosia_action == "Run gosia input":
                    # Not displaying full output for normalization calculation,
                    # since this uses a dummy level scheme that might be
                    # confusing to the user.
                    for line in gosia_shell_output:
                        self.insertnewtext(line)
                    # Save the undo information from the Gosia run.
                    undo.save(gosia_function)
            else:
                if not nucleus_ready:
                    print_error_block("The level scheme and/or matrix are not defined.  You must define them before running calculations.")
                if not experiments_ready:
                    print_error_block("You must define at least one experiment with at least one Ge detector, and every experiment must have at least one Ge detector attached before running calculations.")
                self.set_activation(self)
                print "Quitting."
                return -1

            # Reactivate GUI buttons.
            self.set_activation(self)
            print "Done."

        elif gosia_function == "Deorientation coeff.":
            if nucleus_ready and experiments_ready:
                # Need to set up a phoney corrected yields file first,
                # because we can only get the deorientation calculation
                # after a fit (of 0 steps).
                print "Generating point-yield data for the deorientation calculation..."
                the_gosia_shell.generate(function="Point yields",action="Run gosia input",tf=False,silent=True,release_for_correlated_errors=False,file_extension_substitution_dict = DEORIENTATION_FILE_DEF_DICT,make_dummy_cor_file=True)   
                print "Generating a q-parameter map for the deorientation calculation..."
                # Make a dummy map file.
                the_gosia_shell.generate(function="Map",action="Run gosia input",tf=False,silent=True,release_for_correlated_errors=False,file_extension_substitution_dict = DEORIENTATION_FILE_DEF_DICT)
                print "Calculating the deorientation coefficients..."
                the_gosia_shell.generate(function="Deorientation coeff.",action="Run gosia input",tf=False,silent=False,release_for_correlated_errors=False,file_extension_substitution_dict = DEORIENTATION_FILE_DEF_DICT)

            else:
                print "\nYou need to define the nucleus, matrix and experimental setup first.\n"

            # Reactivate GUI buttons.
            self.set_activation(self)
            print "Done."


        elif gosia_function == "Make simulated yields":
            if nucleus_ready and experiments_ready:
                print "Enter 'n' to base the simulated yields on the most recent integration."

                recalculate = yes_no_prompt("Re-integrate the predicted yields? [Y/n]: ",True)
                if recalculate:
                    gosia_shell_output = the_gosia_shell.generate(gosia_function,gosia_action)
                    if gosia_shell_output == -1:
                        print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                        self.set_activation(self)
                        return -1
                    if gosia_action == "View gosia input":
                        for line in gosia_shell_output:
                            line = line + "\n"         # newlines are needed for a list without newlines in the strings
                            self.insertnewtext(line)
                    elif gosia_action == "Run gosia input":
                        for line in gosia_shell_output:
                            self.insertnewtext(line)
                        # Save the undo information from the Gosia run.
                        undo.save(gosia_function)
                else:
                    # Don't call the method to re-integrate; adjust the
                    # predictions based on new experimental parameters.  (These
                    # parameters are not stored.)
                    block_print_with_line_breaks("Using the results of the last integration.  If you get an error, you will have to try again by re-integrating the yields.")
                    print "\nAnswering \"no\" to the save prompt will NOT update the experimental yields in memory!\n"
                    save_simulated_yields = yes_no_prompt("Save simulated yields as experimental data in .yld file and in GUI memory [Y/n]? ",True)
                    # Save the yields to the .yld file.
                    # The following line was added as a bug-fix on June 9 2011.
                    # The write... method returns a list of yield file lines, unless there is an error, in which case it returns -1.
                    return_data = the_experiment_manager.write_simulated_yld_file(save_simulated_yields)
                    # Read them back from the .yld file to store experimental
                    # yields in memory.  Doing it this way ensures that gosia
                    # gets passed the simulated experimental data that are in
                    # memory.
                    # The following line was added as a bug-fix on June 9 2011.
                    if not return_data == -1:
                        the_experiment_manager.read_experimental_yields()
                    else:
                        print "User cancelled the simulation.  Yield data were not changed."
                        
                    # Save the undo information.
                    undo.save("Adjust simulation parameters")

            else:
                # nucleus or experiment manager not ready.
                if not nucleus_ready:
                    print_error_block("The level scheme and/or matrix are not defined.  You must define them before running calculations.")
                if not experiments_ready:
                    print_error_block("You must define at least one experiment with at least one Ge detector, and every experiment must have at least one Ge detector attached before running calculations.")
                self.set_activation(self)
                print "Quitting."
                return -1

            # Reactivate GUI buttons.
            self.set_activation(self)
            print "Done."

        elif gosia_function == "Correlated errors":
            # This requires two calls to Gosia--one for the diagonal error and a second for the correlated error
            if nucleus_ready and experiments_ready:
                block_print_with_line_breaks("The present version of Rachel allows several options for calculating the correlated error.  If you have dependent matrix elements coupled to master matrix elements, you can choose option \"r\" to release all of the couplings to correlate the errors among the fit masters and dependents individually.\n  You can also free all matrix elements using the \"[Un]set mr. m.e.\" button, selecting \"m\"ore options.  In prompts for Boolean rules, enter only the rule \"True\" (case sensitive, without quotes).  This will set all matrix elements as variable parameters to do a full correlated error calculation for all matrix elements individually.  After doing this, you can run the correlated error calculation with option \"r\"\n  If you want to calculate correlated errors in a \"parametric\" way, i.e. keeping the couplings you have chosen, selection option \"p\".  This could be used, for instance to estimate the correlated errors in the quadrupole moment of a rotational band, or the intrinsic matrix element coupling two rotational bands by the Alaga rule.\n")
                to_continue = yes_no_prompt("Would you like to continue [Y/n]? ",True)
                if not to_continue:
                    print "Cancelled."
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    return 0

                block_print_with_line_breaks("Would you like to\n [r]elease couplings of all free parameters, or do a \n [p]arametric correlated error calculation (see above)?")
                correlation_type = str(raw_input("Enter r or p: ")).lower()[0]
                if correlation_type == "r":
                    release = True
                else:
                    release = False
                gosia_shell_output_1 = the_gosia_shell.generate("Diagonal errors",gosia_action,False,False,release)
                if gosia_shell_output_1 == -1:
                    print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                    self.set_activation(self)
                    return -1
                gosia_shell_output_2 = the_gosia_shell.generate("Correlated errors",gosia_action,False,False,release)
                if gosia_shell_output_2 == -1:
                    print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                    self.set_activation(self)
                    return -1
                if gosia_action == "Run gosia input":
                    investigated_nucleus.parse_correlated_errors(release=release)
                    undo.save("Correlated error calculation")
                else:
                    self.insertnewtext("\n\nDiagonal error input:\n\n")
                    for one_line in gosia_shell_output_1:
                        one_line += "\n"
                        self.insertnewtext(one_line)
                    self.insertnewtext("\n\nCorrelated error input:\n\n")
                    for one_line in gosia_shell_output_2:
                        one_line += "\n"
                        self.insertnewtext(one_line)
                    block_print_with_line_breaks("\n------------------------------------------------------------\nNote that two inputs are required to calculate the correlated errors.  The first estimates the diagonal (uncorrelated) errors, while the second uses the diagonal error estimates to start the correlated error calculation.  Both of these inputs have been sent to the control panel display.  If you selected \"Save gosia input\", then the correlated error input has been saved.  \nYou can modify this file and then run Gosia outside the GUI according to the instructions in the OP,ERRO section of the Gosia manual.  Once you are satisfied with the new minimum and errors, you can resume fitting following a correlated error calculation by clicking the \"Eval. expression\" button and typing at the prompt ~~> investigated_nucleus.parse_correlated_errors().  Enter \"q\" to exit the interpreter and resume GUI operation with the final matrix from the correlated error analysis.\n\nWorking outside of the GUI is not recommended unless you have a good understanding of the type of error calculation you are doing and the correct procedures.  (For instance, iterating the correlated error calculation without iterating the diagonal error calculation will result in over-estimated error bars.  (This is handled automatically in the GUI.\n------------------------------------------------------------\n\nYou may want to read the help above.",60)
                print "Finished."
            # Reactivate GUI buttons.
            self.set_activation(self)

        elif gosia_function == "[Diagonal errors]":
            # The parse_diag... method of class nucleus is only called here.
            # If a full correlated error calculation is run, then the matrix is
            # only updated after the correlated-error step.  If only diagonal
            # errors were requested, then the matrix can be updated here
            # following a user prompt in that method.
            if nucleus_ready and experiments_ready:
                block_print_with_line_breaks("\n------------------------------------------------------------\nThe present version of Rachel allows several options for calculating the diagonal error.  If you have dependent matrix elements coupled to master matrix elements, you can choose option \"r\" to release all of the couplings to correlate the errors among the fit masters and dependents individually.\n  You can also free all matrix elements using the \"[Un]set mr. m.e.\" button, selecting \"m\"ore options.  In prompts for Boolean rules, enter only the rule \"True\" (case sensitive, without quotes).  This will set all matrix elements as variable parameters to do a full diagonal error calculation for all matrix elements individually.  After doing this, you can run the diagonal error calculation with option \"r\"\n  If you want to calculate diagonal errors in a \"parametric\" way, i.e. keeping the couplings you have chosen, selection option \"p\".  This could be used, for instance to estimate the diagonal errors in the quadrupole moment of a rotational band, or the intrinsic matrix element coupling two rotational bands by the Alaga rule.\n\nIf you selected \"Save gosia input\", then the correlated error input has been saved.  \n\nYou can modify this file and then run Gosia outside the GUI according to the instructions in the OP,ERRO section of the Gosia manual.  Once you are satisfied with the new minimum and errors, you can resume fitting following a correlated error calculation by clicking the \"Eval. expression\" button and typing at the prompt ~~> investigated_nucleus.parse_correlated_errors() \n\nNOTE: The procedure for resuming fitting after a DIAGONAL error calculation done OUTSIDE of the GUI is more complicated.  Only one type of calculation should be done outside of the GUI, parametric or not.  Rachel must be told whether or not a parametric calculation was done (above).  The \"parametric\" flag must be set to True (parametric) or False, as in investigated_nucleus.parse_diagonal_errors(True).  Enter \"q\" to exit the interpreter and resume GUI operation with the final matrix from the diagonal error analysis.\n\nWorking outside of the GUI is not recommended unless you have a good understanding of the type of error calculation you are doing.\n------------------------------------------------------------\n\n",60)
                print "You may want to read the help above before answering."
                to_continue = yes_no_prompt("Would you like to continue [Y/n]? ",True)
                if not to_continue:
                    print "Cancelled."
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    return 0

                block_print_with_line_breaks("Would you like to\n [r]elease couplings of all free parameters, or do a \n [p]arametric diagonal error calculation (see above)?")
                correlation_type = str(raw_input("Enter r or p: ")).lower()[0]
                if correlation_type == "r":
                    release = True
                else:
                    release = False
                gosia_shell_output = the_gosia_shell.generate("Diagonal errors",gosia_action,False,False,release)
                if gosia_shell_output == -1:
                    print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                    self.set_activation(self)
                    return -1
                if gosia_action == "Run gosia input":
                    # Call the method to parse diagonal errors.  These are not stored in a separate file; they are taken from the main gosia output file.
                    parametric_calculation = not release
                    investigated_nucleus.parse_diagonal_errors(parametric_calculation)
                    undo.save("Diagonal error calculation")
                else:
                    self.insertnewtext("\n\nDiagonal error input:\n\n")
                    for one_line in gosia_shell_output:
                        one_line += "\n"
                        self.insertnewtext(one_line)
                print "Finished."
            # Reactivate GUI buttons.
            self.set_activation(self)


    # Temporary empty callback for unfinished buttons
    def nothing(self,widget):
        print "This function not enabled."

    def top_level_testing(self,widget):

        print_separator()

        print "Calling def top_level_testing()."
        top_level_testing()

    def activate_ls_window(self,widget):
        # trying to make the ls window active for zooming, panning, etc.
        investigated_nucleus.activate()

    def testcallback(self,widget):
        pass

    def interactive_help(self,widget):
        """Will use the text data in the help file and a simple search method.

        """

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        # Load the help file data, if not already in memory.
        if HELP_DICTIONARY.keys() == []:
            load_help_data()
        try:
            print "\n\nHelp function\n"
            block_print_with_line_breaks(HELP_DICTIONARY["topics"])
            block_print_with_line_breaks("You can search for other topics by typing \"$ [search terms]\" e.g. \" $ logical experiment\".")
            while True:
                help_request = raw_input("Enter topic, keyword, \"$ [search terms]\", \"topics\"  or \"quit\": ")
                if help_request == "quit" or help_request == "q":
                    print "Exiting help."
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    return 0
                elif len(help_request) > 0:
                    if help_request.split()[0] == "search" or help_request.split()[0][0] =="$":
                        # Allow the user to search for the search terms after "search" or "$".
                        # Strip off the first character
                        search_terms = [one_word.lower() for one_word in help_request[1:].split()]  # a list of search terms in lower-case for case-insensitive matching.
                        # If the search terms are not an empty list...
                        if not len(search_terms)==0:
                            # Loop through search dictionary to find keys whose values
                            # (help text) match all desired terms.
                            matching_keywords = []
                            for keyword in HELP_DICTIONARY.keys():
                                text = HELP_DICTIONARY[keyword]
                                lower_case_text_words = [eliminate_characters("!@#$%^&*(),.;:-_~`",one_word).lower().strip(",./\"\'") for one_word in text.split()]  # change all to lower-case for matching
                                if set(search_terms) <= set(lower_case_text_words):  # True if all terms in the search are in this help entry text.
                                    # Add the keyword for this matching help entry to a list
                                    matching_keywords.append(keyword)
                            # Now print the matching keywords, with snippets
                            print len(matching_keywords)," help entries match these search terms."
                            if len(matching_keywords) > 0:
                                print "Try the following keywords:\n______________________________________________________________________"
                                for one_matching_keyword in matching_keywords:
                                    print one_matching_keyword,": ",HELP_DICTIONARY[one_matching_keyword].replace("\n","...")[:67],"..." # a snippet with newlines stripped out.
                    elif help_request.strip() == "topics":
                        print "\n____________________________________________________________\n"
                        print "All available help topics are\n"
                        topic_list = []
                        for one_key in HELP_DICTIONARY.keys():
                            topic_list.append(one_key)
                        topic_list.sort()
                        topics = ""
                        for one_topic in topic_list:
                            topics = topics + one_topic.ljust(20) + " "
                        block_print_with_line_breaks(topics)
                        print "\n____________________________________________________________\n"

                    elif help_request.strip() == "credits":
                        # Just reprint the about file.
                        # Return credits in the textview window.
                        print "Credits are shown in the GUI textview."
                        self.insertnewtext("\nVersion "+VERSION+"\n",scroll_to_bottom = False)
                        rachel_about_file = GLOBAL_SETUP_DICT["RACHEL_DIRECTORY"] + "/necessary_files/about_rachel.txt"
                        with open(rachel_about_file,'r') as about_file:
                            about_text = about_file.readlines()
                        for one_line in about_text:
                            self.insertnewtext(one_line,scroll_to_bottom = True)

                    else:
                        try:
                            # Change the help keyword to lowercase.
                            help_request = help_request.lower()
                            # This should be an entry in the help file.
                            print "\n____________________________________________________________\n"
                            print help_request.title()
                            print ""
                            block_print_with_line_breaks(HELP_DICTIONARY[help_request.replace(" ","")])
                            print "\n____________________________________________________________\n"
                        except:
                            print "Keyword not found."

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1

    def plot_yields(self,widget):

        print_separator()

        #self.gnuplot_summary()  # Put a summary of gnuplot commands in the textview.
        create_popup_tip("gnuplot")
        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)

        # Take the initial and final band numbers from the GUI control panel.
        try:
            initial_band_number = int(self.initial_band_entry.get_text())
            final_band_number = int(self.final_band_entry.get_text())
        except:
            print "Band numbers must be entered in the control panel."
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1

        the_experiment_manager.plot_yield_data(initial_band = initial_band_number,final_band = final_band_number)
        # Reactivate GUI buttons.
        self.set_activation(self)

        
    def import_yield_data(self,widget):

        print_separator()


        # Display a popup tip:
        create_popup_tip("import_yields_button")

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        the_experiment_manager.print_experiment_catalog()
        print " Import yield data"
        print " ----------------------------------------------------------------"
        print " tx    Import from a Rachel text-format yield file."
        print "       A separate file is required for each detector "
        print "       in each experiment."
        print " ag    Import from an AGS file.  A separate file is required"
        print "       for each detector in each experiment."
        print " go    Import yields from a Gosia yield file.  This uses the "
        print "       standard Gosia yield file format, and loads data for"
        print "       all experiments and detectors from a single file."
        print "       This replaces all yield data in memory."
        print " al    Auto-load yield data into detectors."
        print " fl    FULLY automatic loading of all yield data (NEW)." 
        print "       This uses systematic file names.  Refer to the "
        print "       file naming system after selecting \"fl.\""
        try:
            what = raw_input("Enter two-character choice: ").lower()
            if what == "tx":
                return_code = the_experiment_manager.read_txt_file_yields()
                # Reactivate GUI buttons.
                self.set_activation(self)
                if return_code == 0:
                    undo.save("Import txt file yields")
                else:
                    undo.save("Import txt file yields (failed)")
            elif what == "ag":
                return_code = the_experiment_manager.read_ags_file_yields()
                # Reactivate GUI buttons.
                self.set_activation(self)
                if return_code == 0:
                    undo.save("Import ags file yields")
                else:
                    undo.save("Import ags file yields (failed)")
            elif what == "go":
                block_print_with_line_breaks("Warning: the format of the gosia.yld file is not robust with respect to changes in the level scheme.  Use caution when re-reading a gosia.yld file!  Reading yields from a gosia.yld file requires that all yields for all experiments and detectors are in the gosia.yld file in the proper gosia format.\nThis will replace all yields in memory.")
                sure = yes_no_prompt("\nAre you sure [y/N]? ",False)
                if sure:
                    return_code = the_experiment_manager.read_experimental_yields()
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    if return_code == 0:
                        undo.save("Import gosia.yld file")
                    else:
                        undo.save("Import gosia.yld file (failed)")
                else:
                    print "Cancelled."
                    # Reactivate GUI buttons.
                    self.set_activation(self)
            elif what == "fl":
                return_code = the_experiment_manager.full_auto_load_yield_data()
                if not return_code == -1:
                    undo.save("Auto-load yield data from txt file")
                else:
                    undo.save("Auto-load yield data from txt file (failed)")
                # Reactivate GUI buttons.
                self.set_activation(self)
            elif what == "al":
                return_code = the_experiment_manager.auto_load_yield_data()
                if not return_code == -1:
                    undo.save("Auto-load yield data from txt file")
                else:
                    undo.save("Auto-load yield data from txt file (failed)")
                # Reactivate GUI buttons.
                self.set_activation(self)
            else:
                print "Invalid choice.  Cancelled."
                # Reactivate GUI buttons.
                self.set_activation(self)
                return 0
        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1


    def write_true_yields(self,widget,to_force=False):

        print_separator()

        # Display a popup tip:
        create_popup_tip("write_yields_button")

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)

        # Re-evaluate the coupled states before writing.  If this is not done
        # first, the user hits a roadblock to setting up the calculation.
        the_gosia_shell.get_excited_state_data()
        the_experiment_manager.write_experimental_yld_file(to_force)

        # Reactivate GUI buttons.
        self.set_activation(self)

    # Callback for "add <If||ML||Ii>"
    def add_reduced_me(self,widget):

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            try:
                initial_band_number = int(self.initial_band_entry.get_text())
                final_band_number = int(self.final_band_entry.get_text())
            except:
                print "Band numbers must be entered in the control panel."
                # Reactivate GUI buttons.
                self.set_activation(self)
                return -1
            thismultipole = self.get_active_text(self.multipolecombobox)
            if thismultipole == None:
                print "You must select a multipole from the combobox."
                # Reactivate GUI buttons.
                self.set_activation(self)
                return -1
            else:
                block_print_with_line_breaks("NOTE: For a consistent phase convention, always add in-band matrix elements from lower to higher ENERGY and interband m.e. from LEFT to RIGHT (lower to higher band number).")
                return_code = investigated_nucleus.add_single_matrix_element(thismultipole,initial_band_number,final_band_number)
                if return_code == 0:
                    undo.save("Add single matrix element")
                else:
                    undo.save("Add single matrix element (failed)")
                block_print_with_line_breaks("Before running another Gosia \"fit\" operation, you should \"Write Gosia yld file\" to make sure the yield data are appropriate for this matrix, then re-run \"Make corrected yields\".  If you want to plot yields, with the new matrix, you should re-run \"Integrated yields\".")
                print "Done."
                # Reactivate GUI buttons.
                self.set_activation(self)
                return 0

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    # Callback for "add/change m.e. "
    def add_me(self,widget):

        print_separator()
        create_popup_tip("add_me_button")

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)


        block_print_with_line_breaks("NEW: Starting values for *all* K-allowed matrix elements can be added in one step.  See option \"ka\" in the Tools button menu.")
        try:
            # If initial and final band numbers are the same, then ask for
            # appropriate parameters for adding in-band matrix elements and call
            # the appropriate in-band method of the nucleus object.
            try:
                initial_band_number = int(self.initial_band_entry.get_text())
                final_band_number = int(self.final_band_entry.get_text())
            except:
                print "Band numbers must be entered in the control panel."
                # Reactivate GUI buttons.
                self.set_activation(self)
                return -1
            if initial_band_number == final_band_number:   # Then inband m.e. are chosen.
                # Now the static moments will be added always for E2 and never for
                # M1.  Previously, this was controlled by a combo-box in the GUI.
                thismultipole = self.get_active_text(self.multipolecombobox)
                #stat_mom = self.get_active_text(self.statmomcombobox)
                if thismultipole == None:
                    print "You must select a multipole from the combobox."
                else:
                    print "Multipole selected: " + thismultipole
                    print "Band selected:      " + str(initial_band_number)
                    block_print_with_line_breaks("NOTE: For a consistent phase convention, always add interband m.e. from LEFT to RIGHT (lower to higher band number).")
                    print "Spin limits can be applied to the initial and final states."
                    if yes_no_prompt("Apply spin limits (y/N)? ",False):
                        # Ask the user for spin 
                        low_spin_limit = prompt_number("Lower limit for initial (lower-spin) state: ","r")
                        if low_spin_limit   == "quit":
                            return 0
                        high_spin_limit = prompt_number("Upper limit for final (upper-spin) state: ","r")
                        if high_spin_limit   == "quit":
                            return 0
                    else:
                        low_spin_limit  = None
                        high_spin_limit = None

                    parameter_dict = {}   # to contain gk-gr, b, Q0, etc.  (see add_in_band method)
                    # Add the spin limits (possibly None) to the parameter dict.
                    parameter_dict["low_spin_limit"] = low_spin_limit
                    parameter_dict["high_spin_limit"] = high_spin_limit

                    if thismultipole == "M1":
                        gkgr = input("gK-gR: ")
                        parameter_dict["gkgr"] = gkgr
                        K = investigated_nucleus.getbandinfo(initial_band_number,"K")
                        # Changed Sept. 2011 to check for K=1/2, not any half-integer.
                        #if str(K)[-1] == "5":   # Then it's half-integer spin
                        if K == 0.5:
                            print "A \"decoupling parameter\" b can be added for K=1/2 bands."
                            b = input("Decoupling parameter b (or 0.): ")
                            parameter_dict["b"] = b
                        #if add_stat_mom:
                        #    gr = input("gR: ")
                        #    parameter_dict["gr"] = gr
                    else:    # Adding E2's
                        print "Enter the intrinsic moment with the sqrt[(2l+1)/16pi] factor, e.g. sqrt(5/(16pi))eQo."
                        Q = input("Intrinsic moment: ")
                        parameter_dict["Q"] = Q
                    print "Adding matrix elements..."
                    return_code = investigated_nucleus.add_in_band(thismultipole,initial_band_number,parameter_dict)
                    if return_code == 0:
                        undo.save("Add inband matrix elements")
                    else:
                        undo.save("Add inband matrix elements (failed)")
                    print "Done."
            else:
                # Interband matrix elements should be added, since initial and
                # final bands differ.
                thisrule = self.get_active_text(self.rulecombobox)
                thismultipole = self.get_active_text(self.multipolecombobox)
                if thisrule == None:
                    print "You must select a rule from the combobox."
                elif thismultipole == None:
                    print "You must select a multipole from the combobox."
                else:
                    print "Rule selected: " + thisrule
                    print "Multipole selected: " + thismultipole
                    print "Bands selected:     " + str(initial_band_number) + " --> " + str(final_band_number)
                    block_print_with_line_breaks("NOTE: For a consistent phase convention, always add in-band matrix elements from lower to higher ENERGY and interband m.e. from LEFT to RIGHT (lower to higher band number).  Rachel may refuse to add matrix elements in the wrong order for Gosia, so that the phase conventions can be understood.")
                    print "Spin limits can be applied to the INITIAL band."
                    if yes_no_prompt("Apply spin limits (y/N)? ",False):
                        # Ask the user for spin 
                        low_spin_limit =  prompt_number("Lower limit: ","r")
                        if low_spin_limit   == "quit":
                            return 0
                        high_spin_limit = prompt_number("Upper limit: ","r")
                        if high_spin_limit   == "quit":
                            return 0
                    else:
                        low_spin_limit  = None
                        high_spin_limit = None

                    return_code = investigated_nucleus.add_inter_band(thismultipole,initial_band_number,final_band_number,thisrule,low_spin_limit,high_spin_limit)
                    if return_code == 0:
                        undo.save("Add interband matrix elements")
                    else:
                        undo.save("Add interband matrix elements (failed)")

            block_print_with_line_breaks("Before running another Gosia \"fit\" operation, you should rewrite the yield data with the \"Write Gosia yld file\" and re-run \"Make corrected yields\".  If you want to plot yields with the new matrix you should re-run \"Integrated yields\" with the new matrix.")
            print "Done."
            # Reactivate GUI buttons.
            self.set_activation(self)
            return 0

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    # Callback for close_application.
    def close_application(self, widget):

        # Flush the input buffer, so that accidental keystrokes don't go into the next prompt.
        tcflush(sys.stdin, TCIOFLUSH)

        print_separator()

        print "QUIT: ",
        if yes_no_prompt("Are you sure [y/N]? ",False):
            setup_globals("pickle",rotate=True)  # This will prompt whether to save or not.
            # Delete the Undo information files.
            undo.wipe()
            cleanup_garbage_files()
            gtk.main_quit()

    def refuse_to_quit(self, widget, event):
        """Callback for user trying to hard-quit with the "X" button.

        Refuse to quit this way.

        """

        # Returning True tells gtk not to close the window.
        return True

    def gnuplot_summary(self):
        """Gives a short summary of gnuplot commands in the textview.

        """

        create_popup_tip("gnuplot_summary")

#        for one_line in summary:
#            one_line = one_line + "\n"
#            self.insertnewtext(one_line)

# THIS VERSION WORKS, BUT DOESN'T SCROLL TO END AUTOMATICALLY.
#    def insertnewtext(self,newtext):
#        new_position = self.textbuffer.get_char_count()
#        new_iter = self.textbuffer.get_iter_at_offset(new_position)  # the bottom line?
#        self.textbuffer.insert(new_iter, newtext)  # new
#        new_position = self.textbuffer.get_char_count()
                                                                                                                                        
    def insertnewtext(self,newtext,scroll_to_bottom = True):
        # This will insert text in the main textview window at the bottom and place the scrollbar
        # so that the bottom line is visible afterward.
        new_position = self.textbuffer.get_char_count()
        new_iter = self.textbuffer.get_iter_at_offset(new_position)  # the bottom line?
        self.textbuffer.insert(new_iter, newtext)  # new
        if scroll_to_bottom:
            try:
                self.textview.scroll_mark_onscreen(self.textbuffer.get_insert())
            except:
                pass
                                                                                                                                        
    def clear_textview(self,widget):
        # This will clear the textview
        start_position = self.textbuffer.get_iter_at_offset(0)
        end_position = self.textbuffer.get_end_iter()
        self.textbuffer.delete(start_position, end_position)
                                                                                                                                        

    def about(self,widget):
        # Return credits in the textview window.
        self.insertnewtext("\nVersion "+VERSION+"\n",scroll_to_bottom = False)
        rachel_about_file = GLOBAL_SETUP_DICT["RACHEL_DIRECTORY"] + "/necessary_files/about_rachel.txt"
        with open(rachel_about_file,'r') as about_file:
            about_text = about_file.readlines()
        for one_line in about_text:
            self.insertnewtext(one_line,scroll_to_bottom = False)

    def get_active_text(self,combobox):
        #This will get the active text from a combobox passed into it
        model = combobox.get_model()
        active = combobox.get_active()
        if active < 0:
          return None
        return model[active][0]

    def quick_pickle(self,widget):
        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            setup_globals("pickle",rotate=True)
            # Reactivate GUI buttons.
            self.set_activation(self)
            return 0

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    def quick_unpickle(self,widget):
        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            setup_globals("reset") # to make sure we don't have old data hanging around in the original objects
            unpickle_return_code,textview_summary = setup_globals("unpickle")
            if unpickle_return_code == 0:
                undo.wipe()
                undo.save("Load session")
                create_popup_tip("load_session")
                # Create a popup about what to do if the level scheme window is not active.
                matplotlib_dialog()
            # Reactivate GUI buttons.
            self.set_activation(self)


            for one_line in textview_summary:
                self.insertnewtext(one_line)
                self.insertnewtext("\n")
            return return_code

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    def create_nucleus(self,widget):
        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            # Should eventually ask a status variable if the user needs to be prompted
            # and prompt y/n if necessary.
            investigated_nucleus = nucleus()
            print "Nucleus created."
            # Reactivate GUI buttons.
            self.set_activation(self)
            return 0

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    def show_me(self,widget):
        """Displays matrix elements in level scheme window.

        Gets the desired multipole and band numbers from the control panel and
        passes them to the appropriate method of the nucleus object for inband
        or interband matrix element display.
        """


        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        self.activate_band_entries()
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            thismultipole = self.get_active_text(self.multipolecombobox)
            if thismultipole == None:
                print "You must select a multipole from the combobox.  Quitting."
                self.set_activation(self)
                return -1
            initial_band_number = int(self.initial_band_entry.get_text())
            final_band_number = int(self.final_band_entry.get_text())
            if initial_band_number == final_band_number:   # Then inband m.e. are chosen.
                investigated_nucleus.draw_in_band_details(initial_band_number,thismultipole)
            else:
                investigated_nucleus.draw_interband_details(initial_band_number,final_band_number,thismultipole)
            # Reactivate GUI buttons.
            self.set_activation(self)
            return 0

        except:
            # Reactivate GUI buttons.
            print "Show m.e. error.  Quitting."
            self.set_activation(self)
            return -1
        
        
    def filter_me(self,widget):

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)

        try:

            # Now let the nucleus object delete these matrix elements
            return_code = investigated_nucleus.filter_me()
            if return_code == 0:
                undo.save("Filter (delete) matrix elements")
            else:
                undo.save("Filter (delete) matrix elements (failed)")
            # Reactivate GUI buttons.
            self.set_activation(self)
            return return_code

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            undo.save("Filter (delete) matrix elements (failed)")
            return -1

    def logs(self,widget):

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            investigated_nucleus.notes.print_log("procedure_log")
            if yes_no_prompt("Edit user log [y/N]? ",False) == True:
                investigated_nucleus.notes.edit_log("user_notes")
                undo.save("Edit user log")

            # Reactivate GUI buttons.
            self.set_activation(self)
            print "Done."
            return None

        except:
            # Reactivate GUI buttons.
            undo.save("Edit user log (failed)")
            self.set_activation(self)
            print "Done."
            return -1
            

        
    def define_fit_parameters(self,widget):

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            return_code = investigated_nucleus.user_set_masters()

            if return_code == 0:
                undo.save("Define fit parameters")
            elif return_code < 0:
                undo.save("Define fit parameters (failed)")
            else:
                # e.g. returned None.  Don't save.
                pass
            # Reactivate GUI buttons.
            self.set_activation(self)
            return return_code

        except:
            # Reactivate GUI buttons.
            undo.save("Define fit parameters (failed)")
            self.set_activation(self)
            return -1
            

    def plot_bml(self,widget):

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            initial_band_number = int(self.initial_band_entry.get_text())
            final_band_number = int(self.final_band_entry.get_text())
            multipole = self.get_active_text(self.multipolecombobox)
            investigated_nucleus.plotredtransprob(initial_band_number,final_band_number,multipole)
            # Reactivate GUI buttons.
            self.set_activation(self)
            return 0
            
        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        

    def read_level_scheme(self,widget):



        print_separator()
        create_popup_tip("read_level_scheme")

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            txt_or_ags = raw_input("Import from AGS[a] or TXT[t] file? ").lower()[0]
            file_name = prompt_for_file_name(prompt_string = "Enter filename to read: ")
            if txt_or_ags == "t":
                return_code = investigated_nucleus.read_txt_level_scheme(file_name)
                if return_code == 0:
                    undo.save("Read txt level scheme")
                else:
                    undo.save("Read txt level scheme (failed)")
            elif txt_or_ags == "a":
                return_code = investigated_nucleus.read_ags_file_level_scheme(file_name)
                if return_code == 0:
                    undo.save("Read .ags file")
                else:
                    undo.save("Read .ags file (failed)")
            else:
                print "Invalid choice.  Cancelled."
        except:
            print "Error reading a level scheme."
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1

        # Create a popup about what to do if the level scheme window is not active.
        matplotlib_dialog()

        try:
            # Redraw the level scheme.
            investigated_nucleus.draw_level_scheme()
            # Reactivate GUI buttons.
            self.set_activation(self)
            return return_code

        except:
            print "Error displaying the level scheme."
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1

    def update_ls_window(self,widget):
        print "Drawing level scheme..."
        investigated_nucleus.draw_level_scheme()
        print "Drawing finished."
        print
        print "NOTE: K values shown reflect the band heads."

    def delete_band(self,widget):

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            block_print_with_line_breaks("In this version of Rachel, the delete bands function automatically prunes data sent to Gosia.  Be sure to use \"Write Gosia yld file\" if you plan to do any fitting after deleting bands!",70)
            while True:
                bandtodelete = raw_input("Delete which band (ENTER to quit)? ")
                try:
                    if str(bandtodelete).isdigit():   # if the user typed any letter or an empty string, don't delete
                        return_code = investigated_nucleus.delete_band(int(bandtodelete))
                        if return_code == 0:
                            undo_information = "Delete band " + str(int(bandtodelete))
                            undo.save(undo_information)
                        else:
                            undo.save("Delete band (failed)")
                            
                        investigated_nucleus.draw_level_scheme()
                    else:
                        print "Finished."
                        break  # out of while loop
                except:
                    print "Finished."
            # Reactivate GUI buttons.
            self.set_activation(self)

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    def swap_bands(self,widget):

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)

        try:
            try:  
                # Ask for both band numbers and convert to integer type
                initial_band_number = int(self.initial_band_entry.get_text())
                final_band_number = int(self.final_band_entry.get_text())
            except:  # if error, then cancel the operation
                print "Band numbers to swap must be entered in the control panel."
                # Reactivate GUI buttons.
                self.set_activation(self)
                return -1
            return_code = investigated_nucleus.swap_bands(initial_band_number,final_band_number)
            if return_code == 0:
                undo_information = "Swap bands " + str(initial_band_number) + " and " + str(final_band_number)
                undo.save(undo_information)
            else:
                undo.save("Swap bands (failed)")
            print "Drawing level scheme..."
            investigated_nucleus.draw_level_scheme()
            print "Drawing finished."
            # Reactivate GUI buttons.
            self.set_activation(self)

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    def define_ge_detector(self,widget):

        print_separator()
        create_popup_tip("define_ge_button")

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            return_code = the_detector_manager.newdetector()
            if return_code == 0:
                undo.save("Define new Ge detector type")
            else:
                undo.save("Define new Ge detector type (failed)")
        except:
            print "Detector manager error."
            undo.save("Define new Ge detector type (failed)")
            # Reactivate GUI buttons.
            self.set_activation(self)

        # Reactivate GUI buttons.
        self.set_activation(self)

    def attach_detectors(self,widget):
        """Attaches *or* detaches a detector to or from one or more experiments.

        """

        print_separator()
        create_popup_tip("attach_ge_button")

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)

        try:

            print " Attach/detach detectors "
            print " ----------------------------------------------------------------"
            print " as    Attach a single Ge crystal (including a 4pi detector)"
            print " ds    Detach a single Ge crystal (including a 4pi detector)"
            print " id    Import Ge detector arrays from a robust text format."
            print " pd    Plot detector arrays.  This also gives the Ge detector "
            print "       numbers in use."
            choice = raw_input("Enter two-character choice: ").lower()
            if choice == "as":
                try:
                    return_code = the_experiment_manager.attach_detector()
                    if return_code == 0:
                        undo.save("Attach detector")
                    else:
                        undo.save("Attach detector (failed)")
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                except:
                    print "Experiment manager error."
                    undo.save("Attach detector (failed)")
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    return -1
            elif choice == "ds":
                try:
                    return_code = the_experiment_manager.detach_detector()
                    if return_code == 0:
                        undo.save("Detach detector")
                    else:
                        undo.save("Detach detector (failed)")
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                except:
                    print "Experiment manager error."
                    undo.save("Detach detector (failed)")
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    return -1
            elif choice == "id":
                try:
                    return_code = the_experiment_manager.attach_detector_array_from_file()
                    # Call the experiment manager again to check for problems (too many detectors).
                    # Don't get the return code from this check; we want the return
                    # code from the attach function and a report from the next
                    # check.
                    the_experiment_manager.check_for_problems()
                    # Save undo information only if error code -1 was not returned.
                    # (-1 means that no data in memory were changed; other error
                    # codes may indicate a change in the session in memory.
                    if return_code == 0:
                        undo.save("Import detector array from text file")
                    else:
                        undo.save("Import detector array from text file (failed)")
                except:
                    print "Experiment manager error."
                    undo.save("Import detector array from text file (failed)")
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    return -1
            elif choice == "pd":
                # Call the methods to view a plot of detector arrays.
                # No undo information needs to be saved for plotting.
                the_experiment_manager.plot_all_detectors()
                # Reactivate GUI buttons.
                self.set_activation(self)
            else:
                print "Invalid choice.  Cancelled."
                # Reactivate GUI buttons.
                self.set_activation(self)


            # Reactivate GUI buttons.
            self.set_activation(self)

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    def add_delete_experiment(self,widget):

        print_separator()

        create_popup_tip("add_experiment")

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)

        try:
            if not the_experiment_manager.getnumberofexperiments() == 0:
                the_experiment_manager.print_experiment_catalog()
                try:
                    add_or_delete = raw_input("Add or delete experiment? [a/d]: ")[0].lower()
                except:
                    print "Cancelled."
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    return 0
                if add_or_delete == "a":
                    try:
                        print "Adding experiment."
                        return_code = the_experiment_manager.newexperiment()
                        if return_code == 0:
                            undo.save("Add new experiment")
                        else:
                            undo.save("Add new experiment (failed)")
                            #Draw the detector in theta_phi space
                        # Reactivate GUI buttons.
                        self.set_activation(self)
                    except:
                        print "Experiment manager error."
                        undo.save("Add new experiment (failed)")

                elif add_or_delete == "d":
                    try:
                        return_code = the_experiment_manager.delete_experiment()
                        if return_code == 0:
                            undo.save("Delete experiment(s)")  
                        else:
                            undo.save("Delete experiment(s) (failed)")  
                        # Reactivate GUI buttons.
                        self.set_activation(self)
                    except:
                        print "Experiment manager error."
                        undo.save("Delete experiment(s) (failed)")  
                        # Reactivate GUI buttons.
                        self.set_activation(self)
                        return -1
                else:
                    print "Invalid choice. Cancelled."
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    return 0
            else:
                # No experiments in memory.  Only option is to add one.
                try:
                    print "Adding experiment."
                    return_code = the_experiment_manager.newexperiment()
                    if return_code == 0:
                        undo.save("Add experiment")
                    else:
                        undo.save("Add experiment (failed)")
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    return 0
                except:
                    print "Experiment manager error."
                    undo.save("Add experiment (failed)")
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    return -1

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    def reactivate(self,widget):
        # Log this reactivation, since there was probably an exception.
        # Try to get part of the traceback info to log.
        try:
            last_type_string = str(sys.last_type)
        except:
            last_type_string = "[type unavailable]"
        try:
            last_value_string = str(sys.last_value)
        except:
            last_value_string = "[value unavailable]"
        try:
            last_traceback_string = str(sys.last_traceback)
        except:
            last_traceback_string = "[traceback unavailable]"
        try:
            platform = str(os.uname()).strip("()").replace("'","").replace("\"","")
        except:
            platform = "[platform unavailable]"

#        try:
#            last_traceback_object = sys.last_traceback
#            print dir(last_traceback_object)
#            print "tb_frame, tb_lasti, tb_lineno, tb_next"
#            print last_traceback_object.tb_frame, last_traceback_object.tb_lasti, last_traceback_object.tb_lineno, last_traceback_object.tb_next
#            print "tbframe dir:"
#            print dir(last_traceback_object.tb_frame)
#            print "fcode: ",last_traceback_object.tb_frame.f_code
#            print "ftrace: ",last_traceback_object.tb_frame.f_trace
#            print "fback: ",last_backback_object.tb_frame.f_back
#            print "fbuiltins: ",last_builtinsback_object.tb_frame.f_builtins
#            print "fexc_traceback: ",last_exc_tracebackback_object.tb_frame.f_exc_traceback
#            print "fexc_type: ",last_exc_typeback_object.tb_frame.f_exc_type
#            print "fexc_value: ",last_exc_valueback_object.tb_frame.f_exc_value
#            print "flasti: ",last_lastiback_object.tb_frame.f_lasti
#            print "ftrace: ",last_traceback_object.tb_frame.f_trace
#            print "ftrace: ",last_traceback_object.tb_frame.f_trace
#            print "tbnext dir:"
#            print dir(last_traceback_object.tb_next)
#            print "========================================"
#        except:
#            print "dir tb..."
#            print sys.exc_info()


        try:

            # Make a stringio buffer to act as a file.
            trace_output = StringIO.StringIO()
            # Send the traceback lines to the buffer.
            # Up to "limit" steps of traceback.
            try:

                # Is this traceback the same as the last one (same occurrence)?
                # If so, then don't report it again.  The pointer should be
                # unique for each occurrence.
                try:
                    self.last_traceback_saved
                    if self.last_traceback_saved == sys.last_traceback:
                        same_occurrence = True
                    else:
                        same_occurrence = False
                except:
                    same_occurrence = False

                if same_occurrence:
                    # Don't report it again as though the error happened again.
                    traceback_string = "    No exception appears to have occurred, but user reactivated GUI."
                else:
                    # Save this traceback to compare with next time the "reactivate" function is called.
                    self.last_traceback_saved = sys.last_traceback
                    traceback.print_exception(sys.last_type, sys.last_value, sys.last_traceback, limit=10, file=trace_output)
                    # Read the string from the buffer object, and close it.
                    traceback_string = trace_output.getvalue()
                    trace_output.close()
                    # Indent the lines for readability in the log.
                    traceback_string = "    User reactivated GUI.\n    " + traceback_string.replace("\n","\n    ")
                    # Put together the platform, traceback, etc.
            except:
                traceback_string = "    No exception appears to have occurred, but user reactivated GUI."
                
            try:
                full_description = platform + "\n" + traceback_string
            except:
                # Platform information not available?
                full_description = traceback_string

            try:
                # Report (in log) that we couldn't get the text to log this error.
                investigated_nucleus.notes.append_log("procedure_log",full_description)
            except:
                try:
                    investigated_nucleus.notes.append_log("procedure_log","Problem logging tracebacks in def reactivate(self,widget).")
                except:
                    # Can't log ANYTHING.  Just continue.
                    pass

        except:
            # Not sure what went wrong.  Just reactivate.
            pass


        # Reactivate GUI buttons.
        self.set_activation(self)

        
    def read_bst(self,widget):

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)

        try:
            bst_file_name = the_gosia_shell.base_file_name + ".bst"
            return_code = investigated_nucleus.read_best_fit_matrix_elements(bst_file_name)
            if return_code == 0:
                undo.save("Read best fit matrix elements")
            else:
                undo.save("Read best fit matrix elements (failed)")
            print "Matrix elements were read from file ",bst_file_name
            # Reactivate GUI buttons.
            self.set_activation(self)
            return return_code
        except:
            print "Error reading matrix elements from file ",bst_file_name
            undo.save("Read best fit matrix elements (failed)")
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1

    def set_band_k(self,widget):

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            try:  
                # Ask for band number and convert to integer type
                band = int(raw_input("Band number? "))
            except:  # if error, then cancel the operation
                print "Error--must be an integer."
                # Reactivate GUI buttons.
                self.set_activation(self)
                return -1

            return_code = investigated_nucleus.set_one_band_K_values(band)

            if return_code == 0:
                undo_information = "Changed K values of band " + str(band)
                undo.save(undo_information)
            else:
                undo.save("Set K values (failed)")
            print "Drawing level scheme..."
            investigated_nucleus.draw_level_scheme()
            print "Drawing finished."
            # Reactivate GUI buttons.
            self.set_activation(self)
            return return_code

        except:
            undo.save("Set K values (failed)")
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    def merge_bands(self,widget):

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)

        try:
            try:  
                # Get both band numbers and convert to integer type
                initial_band_number = int(self.initial_band_entry.get_text())
                final_band_number = int(self.final_band_entry.get_text())
            except:  # if error, then cancel the operation
                print "Band numbers to merge must be entered in the control panel."
                # Reactivate GUI buttons.
                self.set_activation(self)
                return -1

            if initial_band_number == final_band_number:
                # Do nothing.
                print "Initial and final bands must be different."
                # Reactivate GUI buttons.
                self.set_activation(self)
                return -1

            print "Merging band " + str(initial_band_number) + " into " + str(final_band_number)
            return_code = investigated_nucleus.merge_bands(final_band_number,initial_band_number)
            if return_code == 0:
                undo_information = "Merge band " + str(initial_band_number) + " into " + str(final_band_number)
                undo.save(undo_information)
            else:
                undo.save("Merge bands (failed)")
            print "Drawing level scheme..."
            investigated_nucleus.draw_level_scheme()
            print "Drawing finished."
            # Reactivate GUI buttons.
            self.set_activation(self)
            return return_code

        except:
            undo.save("Merge bands (failed)")
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    def gosia_controls(self,widget):
        """Allows the user to set some of the switches in the Gosia CONT block.

        Some of the controls are not available to the user, because they change
        the output file format, which would make it impossible for the current
        version of the GUI to parse the output successfully.

        """

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            print "Some Gosia controls are not available to the user in the GUI,"
            print "  because they would change the output format, making it "
            print "  impossible for the GUI to parse the output."
            print " "
            print "Menu:"
            print " Physical parameters"
            print "   v Vacuum deorientation control"
            print "   k State for calculation of the scattering kinematics"
            print " Data handling options"
            print "   t Normalization transition for all normalized yields "
            print "   n Data set normalizations"
            print "   w Data set weights  "
            print " Accuracy and calculation speed options"
            print "   i E-theta integration accuracy"
            print "   f Options for fitting of matrix elements"
            print "   m Number of magnetic substates for calculations"
            try:
                choice = raw_input("Enter choice (one character) from above: ").lower()[0]
                if choice == "n":
                    return_code = the_experiment_manager.user_set_experiment_normalizations()
                    if return_code == 0:
                        undo.save("Change data set normalizations")
                    else:
                        undo.save("Change data set normalizations (failed)")
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                elif choice == "m":
                    return_code = the_gosia_shell.set_number_of_magnetic_substates()
                    if return_code == 0:
                        undo.save("Change number of magnetic substates")
                    else:
                        undo.save("Change number of magnetic substates (failed)")
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                elif choice == "t":
                    return_code = investigated_nucleus.set_normalization_transition()
                    if return_code == 0:
                        undo.save("Change normalization transition")
                    else:
                        undo.save("Change normalization transition (failed)")
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                elif choice == "w":
                    return_code = the_gosia_shell.user_set_data_weights()
                    if return_code == 0:
                        undo.save("Change data set weights")
                    else:
                        undo.save("Change data set weights (failed)")
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                elif choice == "i":
                    block_print_with_line_breaks("The accuracy can be increased at a small expense of speed during the \"Integrated yields\" operations by increasing the number of interpolation points for the beam energy, polar scattering angle (theta) mesh.\n The accuracy can be increased at a greater expense of speed by increasing the number of energy and theta meshpoints.\n NOTE: If you decrease the number of interpolation points, or meshpoints, you should check that the integrated (calculated) yield accuracy has not been reduced.  See \"integration accuracy\" in the Help function.")
                    print "Present E-theta meshpoint settings:"
                    the_experiment_manager.print_all_meshpoints()
                    if yes_no_prompt("Would you like Rachel to choose the optimum settings for all experiments [y/N]? ",False):
                        the_experiment_manager.reset_optimum_angular_meshpoints(True)
                        the_experiment_manager.print_all_meshpoints()
                    while True:
                        requested_experiment = raw_input("Experiment number to change, \"all\", or return to quit:").strip().lower()
                        if requested_experiment == "all":
                            experiment_list = range(the_experiment_manager.getnumberofexperiments())
                        else:
                            try:
                                experiment_list = []
                                experiment_list.append(int(requested_experiment)-1)
                            except:
                                # Nothing entered.  Quit the loop.
                                print "Quitting."
                                # Reactivate GUI buttons.
                                self.set_activation(self)
                                break
                        good_meshpoints = False
                        while not good_meshpoints:
                            new_meshpoints = raw_input("Enter one integer for energy meshpoints and one for theta on the same line. ")
                            try:
                                new_energy_meshpoints = int(new_meshpoints.split()[0])
                                new_theta_meshpoints  = int(new_meshpoints.split()[1])
                                if not new_energy_meshpoints in range(MINENERGYMESHPOINTS,MAXENERGYMESHPOINTS+1) or\
                                  not new_theta_meshpoints in range(MINIMUM_THETA_MESHPOINTS,MAXTHETAMESHPOINTS+1):
                                    print "You must enter two integers between",MINENERGYMESHPOINTS,"and", MAXENERGYMESHPOINTS,"for energy and"
                                    print " and between ",MINIMUM_THETA_MESHPOINTS,"and", MAXTHETAMESHPOINTS ,"for theta."
                                    print "Quitting."
                                    return -1
                                for one_experiment_number in experiment_list:
                                    error_code = 0
                                    error_code = error_code + the_experiment_manager.allexperiments[one_experiment_number].set_parameter("number_of_energy_meshpoints",new_energy_meshpoints)
                                    error_code = error_code + the_experiment_manager.allexperiments[one_experiment_number].set_parameter("number_of_theta_meshpoints",new_theta_meshpoints)
                                if error_code == 0:
                                    good_meshpoints = True
                            except:
                                print "You must enter two integers between the limits given above."
                                break
                        the_experiment_manager.print_all_meshpoints()
                    print "Present settings of integration subdivisions for interpolation."
                    the_experiment_manager.print_all_subdivisions()
                    if yes_no_prompt("Would you like to set the default number of subdivisions for all experiments [y/N]? ",False):
                        for one_experiment in the_experiment_manager.allexperiments:
                            one_experiment.set_theta_subdivisions(DEFAULTTHETASUBDIVISIONS)
                            one_experiment.set_energy_subdivisions(DEFAULTENERGYSUBDIVISIONS)
                        the_experiment_manager.print_all_subdivisions()
                    while True:
                        requested_experiment = raw_input("Experiment number to change, \"all\", or return to quit:").strip().lower()
                        if requested_experiment == "all":
                            experiment_list = range(the_experiment_manager.getnumberofexperiments())
                        else:
                            try:
                                experiment_list = []
                                experiment_list.append(int(requested_experiment)-1)
                            except:
                                # Nothing entered.  Quit the loop.
                                print "Quitting."
                                # Reactivate GUI buttons.
                                self.set_activation(self)
                                break
                        good_subdivisions = False
                        while not good_subdivisions:
                            new_subdivisions = raw_input("Enter one *even* integer for energy subdivisions and one for theta on the same line: ")
                            try:
                                new_energy_subdivisions = int(new_subdivisions.split()[0])
                                new_theta_subdivisions  = int(new_subdivisions.split()[1])
                                if not new_energy_subdivisions in range(MINENERGYSUBDIVISIONS ,MAXENERGYSUBDIVISIONS +1) or\
                                  not new_theta_subdivisions in range(MINTHETASUBDIVISIONS  ,MAXTHETASUBDIVISIONS  +1):
                                    print "You must enter two integers between",MINENERGYMESHPOINTS,"and", MAXENERGYMESHPOINTS,"for energy and"
                                    print " and between ",MINIMUM_THETA_MESHPOINTS,"and", MAXTHETAMESHPOINTS ,"for theta."
                                    print "Quitting."
                                    return -1
                                for one_experiment_number in experiment_list:
                                    error_code = 0
                                    error_code = error_code + the_experiment_manager.allexperiments[one_experiment_number].set_energy_subdivisions(new_energy_subdivisions)
                                    error_code = error_code + the_experiment_manager.allexperiments[one_experiment_number].set_theta_subdivisions(new_theta_subdivisions)
                                if error_code == 0:
                                    good_subdivisions = True
                            except:
                                print "You must enter two even integers between ",MINENERGYSUBDIVISIONS ,"and",MAXENERGYSUBDIVISIONS,"for energy"
                                print " and between",MINTHETASUBDIVISIONS  ,"and",MAXTHETASUBDIVISIONS  ,"for theta."
                        the_experiment_manager.print_all_subdivisions()
                    undo.save("Set integration mesh and subdivisions")

                elif choice == "v":
                    the_gosia_shell.print_vac_parameters()
                    turn_off = yes_no_prompt("Revert to the default settings for the deorientation calculation? [Y/n]: ",True)
                    if turn_off:
                        return_code = the_gosia_shell.use_default_vac_values()
                        if return_code == 0:
                            undo.save("Set default vacuum deorientation parameters")
                        else:
                            undo.save("Set default vacuum deorientation parameters (failed)")
                        # Reactivate GUI buttons.
                        self.set_activation(self)
                    else:
                        vac_parameter_dict = {}
                        print "Press enter to leave any parameter settings at the Gosia defaults."
                        try:
                            J1 = int(raw_input("Average atomic spin J: "))
                            vac_parameter_dict["J1"] = J1
                        except:
                            print "J1 left at default value of 3."
                        try:
                            Gamma = float(raw_input("FWHM of the frequency distribution Gamma (ps^-1): "))
                            vac_parameter_dict["Gamma"] = Gamma
                        except:
                            print "Gamma left at default value of 0.02 ps^-1."
                        try:
                            Lambda = float(raw_input("Fluctuating to static transition rate Lambda (ps^-1): "))
                            vac_parameter_dict["Lambda"] = Lambda
                        except:
                            print "Lambda left at default value of 0.0345 ps^-1."
                        try:
                            g_factor = float(raw_input("g-factor: "))
                            vac_parameter_dict["g"] = g_factor
                        except:
                            print "g left at default value of Z/A."
                        try:
                            tau_c = float(raw_input("Correlation time tau_c (ps): "))
                            vac_parameter_dict["tau_c"] = tau_c
                        except:
                            print "tau_c left at default value of 3.5 ps."
                        try:
                            K = float(raw_input("Hyperfine field coefficient K (Gauss): "))
                            # Convert to TeraGauss for Gosia
                            #K = 1.e-12 * K
                            vac_parameter_dict["K"] = K
                        except:
                            print "K left at default value of 6.0E+06 Gauss."
                        try:
                            x = float(raw_input("Hyperfine field exponent x: "))
                            vac_parameter_dict["x"] = x
                        except:
                            print "x left at default value of 0.6."
                            
                        return_code = the_gosia_shell.set_vac_parameters(vac_parameter_dict)
                        if return_code == 0:
                            undo.save("Set custom vacuum deorientation parameters")
                        else:
                            undo.save("Set custom vacuum deorientation parameters (failed)")
                        # Reactivate GUI buttons.
                        self.set_activation(self)
                        print "Done."
                elif choice == "k":
                    # Set the state for calculation of scattering kinematics.
                    print "Current state for calculation of kinematics is "
                    the_gosia_shell.print_kinematics_state()
                    try:
                        return_code = the_gosia_shell.set_gosia_kinematics_state()
                        if return_code == 0:
                            undo.save("Set gosia kinematics state")
                        else:
                            undo.save("Set gosia kinematics state (failed)")
                        print "Kinematics state set to ",
                        the_gosia_shell.print_kinematics_state()
                        # Reactivate GUI buttons.
                        self.set_activation(self)
                    except:
                        undo.save("Set gosia kinematics state (failed)")
                        print "Cancelled."
                        print "State for calculation of kinematics remains set to ",
                        the_gosia_shell.print_kinematics_state()
                        # Reactivate GUI buttons.
                        self.set_activation(self)

                elif choice == "f":
                    # Adjust minimization parameters
                    return_code = the_gosia_shell.set_minimization_parameters_interactive()
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    if return_code == 0:
                        undo.save("Set minimization parameters")
                    else:
                        undo.save("Set minimization parameters (failed)")
                else:
                    print "Sorry--that option is not complete."
                    # Reactivate GUI buttons.
                    self.set_activation(self)
            except:
                # User probably hit return without typing a choice.
                print "Quitting."
                # Reactivate GUI buttons.
                self.set_activation(self)

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
        
    def tools(self,widget):
        """Various advanced tools for the user.

        """

        print_separator()


        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)

        #try:
        if True:
            print ""
            print " Level and matrix tools"
            print " ----------------------------------------------------------------"
            print " em    Export matrix to a txt file."
            print " im    Import matrix from a txt file."
            print " el    Export the level scheme into robust text format."
            print " ey    Export experimental yields into a robust text format."
            print "        This is used to convert Radware .ags file yields"
            print "        or simulated yields to the Rachel format."
            print ""
            print " Ge array definition and data tools"
            print " ----------------------------------------------------------------"
            print " ip    Import \"physical\" Ge crystal type definitions"
            print "        from a text file."
            print " ed    Export Ge detector arrays to a robust text format."
            print " id    Import Ge detector arrays from a robust text format."
            print " al    Auto-load yield data into detectors."
            print " fl    FULLY automatic loading of all yield data (NEW)." 
            print "       This uses systematic file names.  Refer to the "
            print "       file naming system after selecting \"fl.\""
            print " pd    Plot detector arrays.  This also gives the Ge detector "
            print "       numbers in use."
            print ""
            print " Accuracy testing tools for Gosia calculations "
            print " (more coming soon)"
            print " ----------------------------------------------------------------"
            print " tf    Test accuracy of Coulex calculations for your nuclear"
            print "        level scheme.  This is meant to check that you have not"
            print "        exceeded  adiabaticity limits for your level scheme and"
            print "        that your  integration range has not exceeded Gosia's"
            print "        eccentricity limits.  See topics \"adiabaticity\""
            print "        and \"eccentricity\" using the Help button."
            print ""
            print " ti    Test convergence of the integrated Coulex yields. "
            print "        See topic \"coulexconvergence\" using the Help button."
            print ""
            print " Coulex process"
            print " ----------------------------------------------------------------"
            print " at    Generate time-dependent amplitude data a(omega) for"
            print "        plotting.  This can be used to search for adiabaticity"
            print "        and eccentricity problems.  REQUIRES a recent Gosia "
            print "        version.  UNDER DEVELOPMENT, BUGGY."
            print ""
            print " co    Generate plots of the electromagnetic collision "
            print "        functions.  REQUIRES a recent Gosia version."
            print "        UNDER DEVELOPMENT, BUGGY."
            print ""
            print " Simulation tools"
            print " ----------------------------------------------------------------"
            print " ef    Modify absolute efficiency curves for simulations"
            print "        (This has no effect on real experimental data.)"
            print ""
            print " Fast setup tools"
            print " ----------------------------------------------------------------"
            print " ka    Add (replace) all K-allowed matrix elements to the level "
            print "        scheme using estimates of electromagnetic moments and "
            print "        the rotor model."
            print ""
            print " Statistics etc."
            print " ----------------------------------------------------------------"
            print " ch    Give a chi-squared report for all yield data in memory."


            what = raw_input("Enter two-letter choice: ").lower()[:2]

            if what == "em":
                investigated_nucleus.export_matrix()
                # Reactivate GUI buttons.
                self.set_activation(self)
            elif what == "ch":
                the_experiment_manager.properly_weighted_chi_squared_report()
                self.set_activation(self)
            elif what == "pd":
                # Call the methods to view a plot of detector arrays.
                # No undo information needs to be saved for plotting.
                the_experiment_manager.plot_all_detectors()
                # Reactivate GUI buttons.
                self.set_activation(self)
            elif what == "ed":
                # Export the Ge detector information to a robust text format.
                # No undo information needs to be saved for writing external files.
                the_experiment_manager.save_detector_array_to_file()
                # Reactivate GUI buttons.
                self.set_activation(self)
            elif what == "ip":
                return_code = the_detector_manager.define_physical_Ge_types_from_file()
                # Save undo information only if error code -1 was not returned.
                # (-1 means that no data in memory were changed; other error
                # codes may indicate a change in the session in memory.
                if return_code == 0:
                    undo.save("Import physical Ge types from text file")
                else:
                    undo.save("Import physical Ge types from text file (failed)")
                # Reactivate GUI buttons.
                self.set_activation(self)
            elif what == "id":
                return_code = the_experiment_manager.attach_detector_array_from_file()
                # Call the experiment manager again to check for problems (too many detectors).
                # Don't get the return code from this check; we want the return
                # code from the attach function and a report from the next
                # check.
                the_experiment_manager.check_for_problems()
                # Save undo information only if error code -1 was not returned.
                # (-1 means that no data in memory were changed; other error
                # codes may indicate a change in the session in memory.
                if return_code == 0:
                    undo.save("Import detector array from text file")
                else:
                    undo.save("Import detector array from text file (failed)")
                # Reactivate GUI buttons.
                self.set_activation(self)
            elif what == "fl":
                return_code = the_experiment_manager.full_auto_load_yield_data()
                if not return_code == -1:
                    undo.save("Auto-load yield data from txt file")
                else:
                    undo.save("Auto-load yield data from txt file (failed)")
                # Reactivate GUI buttons.
                self.set_activation(self)
            elif what == "al":
                return_code = the_experiment_manager.auto_load_yield_data()
                if not return_code == -1:
                    undo.save("Auto-load yield data from txt file")
                else:
                    undo.save("Auto-load yield data from txt file (failed)")
                # Reactivate GUI buttons.
                self.set_activation(self)
            elif what == "ti":
                self.gnuplot_summary()  # Put a summary of gnuplot commands in the textview.
                the_experiment_manager.test_integration_convergence()
                # Reactivate GUI buttons.
                self.set_activation(self)
            elif what == "tf":
                ################################################################ 
                # The bulk of the work was done here because of the undo/redo
                # used to restore the original setup.  This is no longer
                # necessary and this code should be moved into the expt mgr.
                ################################################################ 

                print "\nIf errors are found in this test, you should read the entries \"adiabaticity\""
                print "and \"eccentricity\" using the Help button.\n"
                the_experiment_manager.save_current_experiments()
                print "Saved your currently defined experiments."
                print ""
                self.gnuplot_summary()  # Put a summary of gnuplot commands in the textview.
                internal_experiment_number = the_experiment_manager.generate_4pi_experiments()
                print "Running test calculations."
                # Everything is in a try/except, because this has changed the experimental setup!
                try:
                    error_code = the_gosia_shell.generate("Point yields","Run gosia input",True)  # True means to accept lower limits in the point yields than the default lower limit.
                    if error_code == -1:
                        print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                        self.set_activation(self)
                        the_experiment_manager.restore_saved_experiments()
                        print "Your original experiment definitions have been restored."
                        return -1
                    print "Attempting to find all transitions that may have potential problems..."
                    plots_to_make = the_experiment_manager.find_all_inaccurate_transitions()
                    if not plots_to_make == -1 and not len(plots_to_make) == 0:
                        # then at least one problem transition was found.
                        # Let the user try to make plots.
                        if yes_no_prompt("Would you like to cycle through plots of all suspect transitions [Y/n]? ",True):
                            the_experiment_manager.allexperiments[internal_experiment_number].print_detector_catalog()
                            internal_detector_number = int(raw_input("Which Ge detector? ")) - 1
                            detector_types,detector_polar_angles,detector_azimuthal_angles = the_experiment_manager.allexperiments[0].get_all_detector_numbers_and_angles()
                            ge_azimuthal_angle = detector_azimuthal_angles[internal_detector_number]
                            ge_polar_angle = detector_polar_angles[internal_detector_number]
                            for plot_counter in range(len(plots_to_make)):
                                one_entry = plots_to_make[plot_counter]
                                try:
                                    initial_band_number,final_band_number,initial_spin,final_spin = one_entry[:4]
                                    error_strings = list(one_entry[4:])
                                    initial_band_name = investigated_nucleus.get_primary_band_name_from_band_number(initial_band_number)
                                    final_band_name = investigated_nucleus.get_primary_band_name_from_band_number(final_band_number)
                                    plot_description = "\nPlotting "+initial_band_name+" "+str(initial_spin)+" --> "+final_band_name+" "+str(final_spin)+" vs. theta_scat."
                                    print plot_description
                                    for error_string in error_strings:
                                        print error_string 
                                    print ""
                                    # Draw the problem transition
                                    investigated_nucleus.draw_level_scheme()
                                    #investigated_nucleus.drawonetransition(initial_band_name,final_band_name,initial_spin,final_spin,'r',"",False)
                                    investigated_nucleus.drawonetransition(initial_band_name,final_band_name,initial_spin,final_spin,'r',"",True)
                                    # Silence the output the from the plotting method:
                                    # BEGINNING OF PLOTS
                                    #saveout = sys.stdout
                                    #garbage_file = open('.rachel_garbage', 'w')
                                    #sys.stdout = garbage_file
                                    the_experiment_manager.plot_yield_data(initial_band = initial_band_number,final_band = final_band_number,tf = True,initial_spin = initial_spin,final_spin = final_spin,ge_polar_angle = ge_polar_angle,ge_azimuthal_angle = ge_azimuthal_angle)  
                                    # Restore stdout to the terminal.
                                    #sys.stdout = saveout
                                    #garbage_file.close()  
                                    # END OF PLOTS
                                    if yes_no_prompt("Continue reports [Y/n]? ",True):
                                        pass  # continue to the next plot.
                                    else:
                                        investigated_nucleus.draw_level_scheme()
                                        the_experiment_manager.restore_saved_experiments()
                                        # Reactivate GUI buttons.
                                        self.set_activation(self)
                                        the_experiment_manager.restore_saved_experiments()
                                        print "Your original experiment definitions have been restored."
                                        print "Finished."
                                        return 0
                                except:
                                    print "Error in making plot."
                                    if not yes_no_prompt("Would you like to try the next plot [Y/n]: ",True):
                                        # Reactivate GUI buttons.
                                        self.set_activation(self)
                                        # Clear the level scheme
                                        the_experiment_manager.restore_saved_experiments()
                                        investigated_nucleus.draw_level_scheme()
                                        print "Your original experiment definitions have been restored."
                                        print "Finished."
                                        return 0

                            # Finished all plots.
                            print "\nFinished all plots.\n"
                            # Reactivate GUI buttons.
                            self.set_activation(self)
                            # Clear the level scheme
                            the_experiment_manager.restore_saved_experiments()
                            investigated_nucleus.draw_level_scheme()
                            print "Your original experiment definitions have been restored."
                            print "Finished."
                            return 0

                        else:
                            # Reactivate GUI buttons.
                            self.set_activation(self)
                            the_experiment_manager.restore_saved_experiments()
                            print "Your original experiment definitions have been restored."
                            print "Finished."
                            return 0
                    else:
                        # Reactivate GUI buttons.
                        self.set_activation(self)
                        the_experiment_manager.restore_saved_experiments()
                        print "Your original experiment definitions have been restored."
                        print "Finished."
                        return 0
                except:
                    # Just recover with undo.  
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    the_experiment_manager.restore_saved_experiments()
                    print "Your original experiment definitions have been restored."
                    print "Finished."
                    return 0

            elif what == "co":
                self.gnuplot_summary()  # Give a summary of gnuplot commands
                print "Note: collision functions are only available for multipoles"
                print "used in this level scheme."
                while True:
                    raw_input("Under development--only E2 available now.  Press enter.")
                    #lambda_number = prompt_number("Enter electric excitation lambda [1...6]: ","i")
                    lambda_number = 2
                    if lambda_number == "quit":
                        print "Finished."
                        # Reactivate GUI buttons.
                        self.set_activation(self)
                        return 0
                    if (lambda_number > 0) and (lambda_number < 7):
                        print "Running point calculations..."
                        try:
                            error_code = the_gosia_shell.generate("Start","Run gosia input",True,False,False,{"collision function":lambda_number})  
                        except:
                            print "That collision function is not available at this time."
                        if error_code == -1:
                            print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                            self.set_activation(self)
                            return -1
                        # Need to re-calculate every time, since only one multipole is output each time.
                        the_experiment_manager.read_Q_vs_time(lambda_number)
                        return_code = the_experiment_manager.plot_Q_vs_time(lambda_number)
                        if not return_code == 0:
                            print "That collision function is not available at this time."

                    else:
                        print "lambda out of range."
                
            elif what == "ka":
                return_code = investigated_nucleus.add_complete_matrix()
                if return_code == 0:
                    undo.save("Add all K-allowed matrix elements")
                else:
                    undo.save("Add all K-allowed matrix elements (failed)")
                # Reactivate GUI buttons.
                self.set_activation(self)
                # Reactivate GUI buttons.
                self.set_activation(self)
                print "Finished."
                return 0

            elif what == "ef":
                return_code = the_detector_manager.change_efficiency_parameters()
                if return_code == 0:
                    undo.save("Change absolute efficiency curves for simulations")
                else:
                    undo.save("Change absolute efficiency curves for simulations (failed)")
                # Reactivate GUI buttons.
                self.set_activation(self)
                # Reactivate GUI buttons.
                self.set_activation(self)
                print "Finished."
                return 0

            elif what == "at":
                self.gnuplot_summary()  # Give a summary of gnuplot commands
                print "Read Help entries \"adiabaticity\""
                print "  and \"eccentricity\" using the Help button, and use options"
                print "  test \"tf\" above to check the accuracy of calculations.\n"
                print "Adiabaticity problems will show up as large discontinuities"
                print "in the amplitudes for large w (usually greater than 4)"
                print "on the plots."
                recalculate = yes_no_prompt("Re-integrate amplitude data? [Y/n]: ",True)
                if recalculate:
                    print "Running point calculations..."
                    error_code = the_gosia_shell.generate("Start","Run gosia input",True,False,False,{"amplitudes":True},amplitudes=True) 
                    if error_code == -1:
                        print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                        self.set_activation(self)
                        return -1
                    the_experiment_manager.read_amplitudes_vs_time()
                    return_code = the_experiment_manager.plot_amplitudes_vs_time()
                else:
                    return_code = the_experiment_manager.plot_amplitudes_vs_time()
                    if return_code == -2:
                        # Need to re-calculate
                        print "Data need to be re-integrated!"
                        print "Running point calculations..."
                        error_code = the_gosia_shell.generate("Start","Run gosia input",True,amplitudes=True)  # True means to accept lower limits in the point yields than the default lower limit.
                        if error_code == -1:
                            print "Gosia killed by user or cannot run Gosia.  Check for errors above."
                            self.set_activation(self)
                            return -1
                        the_experiment_manager.read_amplitudes_vs_time()
                        return_code = the_experiment_manager.plot_amplitudes_vs_time()

                # Reactivate GUI buttons.
                self.set_activation(self)
                print "Finished."
                return 0


            elif what == "im":
                return_code = investigated_nucleus.import_matrix()
                # Reactivate GUI buttons.
                self.set_activation(self)
                if return_code == 0:
                    undo.save("Import matrix from text file")
                else:
                    undo.save("Import matrix from text file (failed)")
                    investigated_nucleus.draw_level_scheme()
            elif what == "el":
                investigated_nucleus.export_level_scheme()
                # Reactivate GUI buttons.
                self.set_activation(self)
            elif what == "ey":
                the_experiment_manager.export_txt_file_yields()
                # Reactivate GUI buttons.
                self.set_activation(self)
            else:
                print "Invalid choice.  Cancelled."
                # Reactivate GUI buttons.
                self.set_activation(self)

            
    def examine_stopping_power(self,widget):
        """Allows the user to examine and modify stopping power data.

        """

        print_separator()

        
        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)

        the_experiment_manager.examine_stopping_power_interactive()

        self.set_activation(self)
        undo.save("Examine/change stopping powers")

        return 0

    def examine_setup(self,widget):
        """Allows the user to print requested information about the GUI setup.

        This includes nuclear data, Gosia settings and parameters, experimental
        setup (detectors, beam, particle angles, energies, etc.).

        """

        print_separator()

        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            print "What do you want to examine?"
            print "  e   Experimental setup"
            print "  n   Nucleus information including matrix elements"
            print "  y   Yield and nuclear data"
            print "  g   Gamma detector catalog"
            print "  p   List all fit parameters"
            print "  r   Check for errors in setup"

            what = raw_input("Enter e, n, etc.: ").lower()[0]

            if what == "e":
                the_experiment_manager.examine_setup_interactive()
                # Reactivate GUI buttons.
                self.set_activation(self)
                print "Finished."
            elif what == "r":
                investigated_nucleus.check_for_problems(quiet=False)
                the_experiment_manager.check_for_problems(quiet=False)
                # Reactivate GUI buttons.
                self.set_activation(self)
                print "Finished."
            elif what == "n":
                investigated_nucleus.examine_setup_interactive()
                # Reactivate GUI buttons.
                self.set_activation(self)
                print "Finished."
            elif what == "y":
                the_experiment_manager.examine_data_interactive()
                # Reactivate GUI buttons.
                self.set_activation(self)
                print "Finished."
            elif what == "g":
                the_detector_manager.examine_detectors_interactive()
                # Reactivate GUI buttons.
                self.set_activation(self)
                print "Finished."
            elif what == "p":
                investigated_nucleus.display_coupling_information()
                # Reactivate GUI buttons.
                self.set_activation(self)
            else:
                print "Cancelled."
                # Reactivate GUI buttons.
                self.set_activation(self)
                

        except:    
            # Reactivate GUI buttons.
            self.set_activation(self)    #  RESTORE_THIS_LINE
            return -1    #  RESTORE_THIS_LINE
            
    def run_script(self,widget):
        """Runs a script file.

        This is done here, instead of from the interpreter, so that try/except
        does not mask errors in the script.

        """

        print "Warning: undo information is not saved during script execution!"
        script_file_name = prompt_for_file_name(prompt_string = "Enter full script file name (including .py) [enter to quit]: ")
        if script_file_name.strip() == "":
            print "Cancelled."
            return 0
        print "Trying to run script \"" + script_file_name + "\"."

        # Check that the file exists, and if so, save its lines temporarily, so
        # that we can check for quit statements that would crash the GUI.
        try:
            with open(script_file_name,"r") as test_file:
                all_lines = test_file.readlines()
            print "Found file \"" + script_file_name + "\"."
            file_found = True
            print "Running.  Script output follows.\n"
        except:
            print "Could not find file in the working directory.\nInclude the full path."
            file_found = False

        if file_found:
            possible_quit_lines = []
            for line_number in range(len(all_lines)):
                if "quit(" in all_lines[line_number]:
                    possible_quit_lines.append(line_number)
            if len(possible_quit_lines) > 0:
                for line_number in possible_quit_lines:
                    print "Line " + str(line_number) + ": " + all_lines[line_number]
                want_to_continue = yes_no_prompt("THIS FILE MAY CONTAIN A quit() STATEMENT.\nIF IT DOES, THE GUI WILL CRASH WITHOUT SAVING.\nDo you want to continue? [y/N] ",False)
                if want_to_continue:
                    execfile(script_file_name)
                    print "\nScript execution ended."
                else:
                    print "Cancelled.  Check the script for quit() statements."

            else:
                execfile(script_file_name)
                print "\nScript execution ended."

        return 0


    def user_command(self,widget):
        """Let the user evaluate expressions at the console prompt

        This enable evaluation of Clebsch-Gordan coefficients, look at
        internal variables, etc.  
        
        The expressions will be evaluated until "q" is entered to break
        the loop.  The user can do fancy things like this to create objects
        and call their methods, etc.

        Enter 'q' to quit the interpreter.
        ~>self.user_stack
        []
        ~>self.user_stack.append(experiment())
        None
        ~>self.user_stack
        [<__main__.experiment instance at 0x3b6d6c0>]
        ~>self.user_stack[0].selected
        True
        ~>

        """
        #deactivate all button presses while this runs.
        self.set_deactivation(self,self.all_button_list)
        while gtk.events_pending():
            gtk.main_iteration(False)
        try:
            # Maybe I should just let it throw errors that might be clearer
            # to the user instead of the try, except error control.

            block_print_with_line_breaks("Enter \"q\" to quit the interpreter.  It is not recommended to call object methods from this interpreter, unless you understand the GUI structure very well!\n Enter \"functions\" to list available functions for calculating physical or mathematical quantities.  The \"Undo\" button may be used after exiting the interpreter to undo all operations in this interpreter session.")

            while True:
                user_expression = raw_input("Rachel>")
                test_expression = user_expression.lower()
                test_expression.strip()
                #if user_expression == "q" or user_expression == "quit":
                if test_expression == "q" or test_expression == "quit" or test_expression == "quit()":
                    undo.save("User command(s) executed in interpreter.")
                    print "Returning to GUI."
                    # Reactivate GUI buttons.
                    self.set_activation(self)
                    break 
#                elif user_expression == "upgrade":
#                    nucleus_returned_errors,     nucleus_upgrade_text     = investigated_nucleus.for_upgrade()
#                    experiment_returned_errors,  experiment_upgrade_text  = the_experiment_manager.for_upgrade()
#                    gosia_shell_returned_errors, gosia_shell_upgrade_text = the_gosia_shell.for_upgrade()
#                    detector_returned_errors,    detector_upgrade_text    = the_detector_manager.for_upgrade()
#                    returned_errors = nucleus_returned_errors + experiment_returned_errors + gosia_shell_returned_errors + detector_returned_errors
#                    print returned_errors, " errors in upgrade."
#                    if returned_errors == 0:
#                        print "Enter \"q\" to quit the interpreter and save your session file now."
#                    else:
#                        print "Do NOT save your session file.  Something went wrong with the upgrade!"
                elif user_expression.strip() == "functions":

                    block_print_with_line_breaks("The following commands take prompted input for common calculations.  All functions below are accurate for elastic or inelastic scattering.  Quantities are symmetrized over the entrance and exit velocities as appropriate.\n")
                    block_print_with_line_breaks("user_sd - calculates the standard deviation of a list of values (without errors given on the values).")
                    #block_print_with_line_breaks("user_symmetrized_adiabaticity - calculates the adiabaticity for a one-step excitation, symmetrized over the incoming and outgoing beam velocity.")
                    #block_print_with_line_breaks("user_absolute_efficiency - calculates an approximate Ge efficiency based on a typical Gammasphere Ge crystal.  This is used to estimate counts in simulated data.")
                    #block_print_with_line_breaks("user_events - calculates the number of detected p-gamma events from a given beam dose and other experimental parameters.")
                    #block_print_with_line_breaks("user_bml - calculates the B(ML) value of a matrix element in the upward direction")
                    block_print_with_line_breaks("user_wu  - calculates the downward Weisskopf unit")
                    #block_print_with_line_breaks("user_rev - calculates the time-reversed value of a matrix element")
                    block_print_with_line_breaks("user_cgc - calculates a Clebsch-Gordan coefficient (not a 3-J)")
                    block_print_with_line_breaks("user_somm - calculates the Sommerfeld parameter for an experiment")
                    block_print_with_line_breaks("user_barrier - calculates the coulomb barrier energy for a projectile/target combination")
                    block_print_with_line_breaks("user_safe - calculates the Cline \"safe\" energy for a projectile/target combination")
                    block_print_with_line_breaks("user_ruth - the inelastic/elastic differential cross section for a given projectile scattering angle")
                    block_print_with_line_breaks("user_ruth_com - the differential cross section in the center of mass frame")
                    #block_print_with_line_breaks("user_integrated_rutherford_cross_section - Returns the integrated Rutherford cross section in mb in the lab frame for azimuthal symmetry only.")
                    block_print_with_line_breaks("user_com_energy - converts a lab-frame beam energy to the center of mass energy")
                    block_print_with_line_breaks("user_lab_energy - converts a c.o.m. beam energy to the lab-frame energy")
                    block_print_with_line_breaks("user_stor  - returns the recoil (target) angle for a given projectile scattering angle (both lab frame)")
                    block_print_with_line_breaks("user_stoc  - returns the scattering angle in the c.o.m. frame given the laboratory scattering angle")
                    block_print_with_line_breaks("user_rtos  - returns the projectile scattering angle for a given recoil (target) angle (both lab frame)")
                    block_print_with_line_breaks("user_scatmax - returns the maximum projectile scattering angle for a given beam, target pair.  Use this with the target-exit energy and Q-value to find the Q-dependent maximum recoil angle that will be accepted by Gosia.  (This is not arcin(Atarg/Abeam) for Q>0!)")
                    block_print_with_line_breaks("user_recmax - returns the maximum target recoil angle for a given beam, target pair.  Use this with the target-exit energy and Q-value to find the Q-dependent maximum recoil angle that will be accepted by Gosia.  (This is not 90 degrees for Q>0!)")
                    #block_print_with_line_breaks("user_theta_recoil_com - returns the c.o.m. target recoil angle from a given lab frame recoil angle")
                    block_print_with_line_breaks("user_norm - returns the accurate inelastic normalization constant YNRM for an EXPT entry, neglecting any efficiency factors that the user must enter")
                    print "Plotting functions:"
                    block_print_with_line_breaks("user_svsr - Generates a plot of inelastic lab-frame scattering (projectile) angle vs. recoil (target) angle.")
                    block_print_with_line_breaks("user_lvsc - Generates a plot of inelastic lab-frame scattering and recoil angles vs. the c.o.m. scattering angle.")
                    block_print_with_line_breaks("user_evsl - Generates a plot of inelastic lab-frame scattering and recoil energies vs the lab scattering/recoil angle.")
                    block_print_with_line_breaks("user_gs   - Searches for initial and final states whose difference in energy matches a specified gamma-ray energy.")
                    print "These are function calls, so type \"user_evsl()\" for example."
                    
                    print  ""
                    #block_print_with_line_breaks("Syntax for each function can be displayed by typing for example \"safe_energy.__doc__\".")
                    block_print_with_line_breaks("The commands described above will not affect the GUI state.\n")

                elif user_expression.strip() == "experimental":
                    print "DO NOT USE THIS COMMAND.  NO WARRANTY EXPRESSED OR IMPLIED!"
                    the_experiment_manager.delete_all_but_one_transition()

                elif user_expression.strip() == "chisq":
                    the_experiment_manager.properly_weighted_chi_squared_report()

#                elif user_expression.strip() == "script":
#                    script_file_name = prompt_for_file_name(prompt_string = "Enter script file name: ")
#                    with open(script_file_name,"r") as script_file:
#                        script_lines = script_file.readlines()
#                    for one_line in script_lines:
#                        one_line = one_line.strip()
#                        if not len(one_line) == 0:
#                            if not one_line[0] == "#":
#                                print "Rachel>" + one_line
#                                eval(one_line)
#                    print "Script finished."

#                elif user_expression.strip() == "python":
#                    script_file_name = prompt_for_file_name(prompt_string = "Enter script file name: ")
#                    print "Trying to run script \"" + script_file_name + "\"."
#                    try:
#                        with open(script_file_name,"r") as test_file:
#                            test_file.readline()
#                        print "Found file \"" + script_file_name + "\"."
#                        file_found = True
#                        print "Running..."
#                    except:
#                        print "Could not find file in the working directory.\nInclude the full path."
#                        file_found = False
#
#                    if file_found:
#                        execfile(script_file_name)
#                        print "\nScript execution ended."

                elif user_expression.strip() == "exec":
                    block_print_with_line_breaks("This is similar to a python interpreter session, except that evaluation of expressions does not give any output, unless preceded by \"print \"")
                    print "Enter \"print dir()\" to see local definitions."
                    print "Enter \"quit\" to quit."
                    print "DO NOT USE THIS COMMAND.  THIS IS DANGEROUS!"
                    while True:
                        command_line = raw_input(">>> ")
                        if command_line == "quit":
                            break
                        elif command_line.strip() == "quit()":
                            print "quit() would kill the GUI.  It is disabled."
                        else:
                            try:
                                exec(command_line)
                            except:
                                print "Error:", sys.exc_info()[0]
                        
                else:
                    if not user_expression == "":
                        try:
                            print eval(user_expression)
                        except:
                            print "Error."
                    else:
                        # Nothing was typed before pressing 'enter'
                        pass

        except:
            # Reactivate GUI buttons.
            self.set_activation(self)
            return -1
            

    def __init__(self):

        # Create a stack (list) for the user to play with in the module
        # user_command.  Assignments like y=3 don't work in that module,
        # so for now I just put in this stack, which may allow more sophisticated
        # things like self.user_stack.append(nucleus())  or math on saved items, etc.
        # Enter 'q' to quit the interpreter.
        # ~>self.user_stack
        # []
        # ~>self.user_stack.append(experiment())
        # None
        # ~>self.user_stack
        # [<__main__.experiment instance at 0x3b6d6c0>]
        # ~>self.user_stack[0].selected
        # True
        # ~>

        self.user_stack = []

        # The undo stack does not currently function properly in when
        # recovering a crashed session.  To make sure that the user doesn't
        # continue work in recovery moe, there is a global variable
        # RECOVERY_MODE set to True, and a separate button list to activate in
        # recovery mode.  The user is instructed to only check and save the
        # session, then quit and reload the session to resume work.
        # A list of only the buttons that should be made active in recovery mode.
        self.recovery_mode_button_list = []
        # A list of all buttons.
        self.all_button_list = []

        # READ THE RACHEL SETUP FILE, IF IT EXISTS.  This will be in the form of 
        # dictionary keys and values, e.g.
        # gosia_executable    /usr/local/bin/gosia
        # elo_executable      /usr/local/bin/elo
        # etc.


        # Create a new window.
        window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        # Set the window size to be resizable.
        window.set_resizable(True)  
        # If the user hits the "X" button, refuse to close the GUI window.
        window.connect("delete_event", self.refuse_to_quit)
        # Set the title for the window.
        title_string = "Rachel Main Control Panel -- Version " + VERSION 
        window.set_title(title_string)
        # Set the border width.
        window.set_border_width(0)

        # Create a horizontal box in the window.
        box1 = gtk.HBox(False, 0)
        # Add the vertical box to the window. 
        window.add(box1)
        # Show the window.
        box1.show()

        # create a vertical box.
        box2 = gtk.VBox(False, 10)
        # set the border width of this vertical box.
        box2.set_border_width(10)
        # Pack this vertical box into the first vertical box.
        box1.pack_start(box2, False, False, 0)
        # Show the newly created vertical box.
        box2.show()

        # Create a horizontal button box.
        hbox = gtk.HBox()
        # pack the horizontal button box into the vertical box.
        box2.pack_start(hbox, False, False, 0)
        # Show the horizontal button box.
        hbox.show()

        # Create a vertical box.
        # START PUTTING BUTTONS IN HERE AS IN GLADE MODEL
        vbox = gtk.VButtonBox()
        # Show the vertical box.
        vbox.show()
        # Show the vertical box into the horizontal box.
        hbox.pack_start(vbox, False, False, 0)

        # Create a new button 
        button1 = gtk.Button("Load session")
        self.button1_pointer = button1  # So that it can be forced active 
        button1.connect("clicked", self.quick_unpickle)
        # pack the button1 
        vbox.pack_start(button1, False, False)
        # Set the default flags 
        button1.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button1.grab_default()
        # Show the button1.
        button1.show()
        self.all_button_list.append(button1)

        button2 = gtk.Button("Read level scheme")
        self.button2_pointer = button2  # So that it can be forced active 
        button2.connect("clicked", self.read_level_scheme)
        # pack the button 
        vbox.pack_start(button2, False, False)
        # Set the default flags 
        button2.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button2.grab_default()
        # Show the button.
        button2.show()
        self.all_button_list.append(button2)

        button3 = gtk.Button("Redraw LS window")
        self.button3_pointer = button3  # So that it can be forced active 
        button3.connect("clicked", self.update_ls_window)
        # pack the button 
        vbox.pack_start(button3, False, False)
        # Set the default flags 
        button3.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button3.grab_default()
        # Show the button.
        button3.show()
        self.recovery_mode_button_list.append(button3)
        self.all_button_list.append(button3)

        button27 = gtk.Button("Recreate LS window")
        self.button27_pointer = button27  # So that it can be forced active to break out of functions.
        button27.connect("clicked", self.activate_ls_window)
        # pack the button27 
        vbox.pack_start(button27, False, False)
        # Set the default flags 
        button27.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button27.grab_default()
        # Show the button27.
        button27.show()
        self.all_button_list.append(button27)
        self.recovery_mode_button_list.append(button27)

        button4 = gtk.Button("Merge bands")
        self.button4_pointer = button4  # So that it can be forced active 
        button4.connect("clicked", self.merge_bands)
        # pack the button 
        vbox.pack_start(button4, False, False)
        # Set the default flags 
        button4.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button4.grab_default()
        # Show the button.
        button4.show()
        self.all_button_list.append(button4)

        button5 = gtk.Button("Delete bands")
        self.button5_pointer = button5  # So that it can be forced active 
        button5.connect("clicked", self.delete_band)
        # pack the button 
        vbox.pack_start(button5, False, False)
        # Set the default flags 
        button5.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button5.grab_default()
        # Show the button.
        button5.show()
        self.all_button_list.append(button5)

        button6 = gtk.Button("Swap bands")
        self.button6_pointer = button6  # So that it can be forced active 
        button6.connect("clicked", self.swap_bands)
        # pack the button 
        vbox.pack_start(button6, False, False)
        # Set the default flags 
        button6.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button6.grab_default()
        # Show the button.
        button6.show()
        self.all_button_list.append(button6)

        button7 = gtk.Button("View / Set K")
        self.button7_pointer = button7  # So that it can be forced active 
        button7.connect("clicked", self.set_band_k)
        # pack the button 
        vbox.pack_start(button7, False, False)
        # Set the default flags 
        button7.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button7.grab_default()
        # Show the button.
        button7.show()
        self.all_button_list.append(button7)

        button8 = gtk.Button("Add <If||ML||Ii>")
        self.button8_pointer = button8  # So that it can be forced active 
        button8.connect("clicked", self.add_reduced_me)
        # pack the button 
        vbox.pack_start(button8, False, False)
        # Set the default flags 
        button8.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button8.grab_default()
        # Show the button.
        button8.show()
        self.all_button_list.append(button8)

        button9 = gtk.Button("Tools")
        self.button9_pointer = button9  # So that it can be forced active 
        button9.connect("clicked", self.tools)
        # pack the button 
        vbox.pack_start(button9, False, False)
        # Set the default flags 
        button9.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button9.grab_default()
        # Show the button.
        button9.show()
        self.all_button_list.append(button9)

        button10 = gtk.Button("Gosia controls")
        self.button10_pointer = button10  # So that it can be forced active 
        button10.connect("clicked", self.gosia_controls)
        # pack the button10 
        vbox.pack_start(button10, False, False)
        # Set the default flags 
        button10.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button10.grab_default()
        # Show the button10.
        button10.show()
        self.all_button_list.append(button10)

        button11 = gtk.Button("Examine setup")
        self.button11_pointer = button11  # So that it can be forced active 
        button11.connect("clicked", self.examine_setup)
        # pack the button11 
        vbox.pack_start(button11, False, False)
        # Set the default flags 
        button11.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button11.grab_default()
        # Show the button11.
        button11.show()
        self.all_button_list.append(button11)
        self.recovery_mode_button_list.append(button11)

        button12 = gtk.Button("Show m.e.")
        self.button12_pointer = button12  # So that it can be forced active 
        button12.connect("clicked", self.show_me)
        # pack the button12 
        vbox.pack_start(button12, False, False)
        # Set the default flags 
        button12.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button12.grab_default()
        # Show the button12.
        button12.show()
        self.all_button_list.append(button12)
        self.recovery_mode_button_list.append(button12)

        button13 = gtk.Button("Plot B(ML)")
        self.button13_pointer = button13  # So that it can be forced active 
        button13.connect("clicked", self.plot_bml)
        # pack the button13 
        vbox.pack_start(button13, False, False)
        # Set the default flags 
        button13.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button13.grab_default()
        # Show the button13.
        button13.show()
        self.all_button_list.append(button13)
        self.recovery_mode_button_list.append(button13)

        button15 = gtk.Button("Undo")
        self.button15_pointer = button15  # So that it can be forced active 
        button15.connect("clicked", self.undo)
        # pack the button15 
        vbox.pack_start(button15, False, False, 0)
        # Set the default flags 
        button15.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button15.grab_default()
        # Show the button15.
        button15.show()
        self.all_button_list.append(button15)

        button16 = gtk.Button("Redo")
        self.button16_pointer = button16  # So that it can be forced active 
        button16.connect("clicked", self.redo)
        # pack the button16 
        vbox.pack_start(button16, False, False)
        # Set the default flags 
        button16.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button16.grab_default()
        # Show the button16.
        button16.show()
        self.all_button_list.append(button16)

        button17 = gtk.Button("Save session")
        self.button17_pointer = button17  # So that it can be forced active 
        button17.connect("clicked", self.quick_pickle)
        # pack the button17 
        vbox.pack_start(button17, False, False)
        # Set the default flags 
        button17.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button17.grab_default()
        # Show the button17.
        button17.show()
        self.all_button_list.append(button17)
        self.recovery_mode_button_list.append(button17)

        # create a vertical separator.
        separator = gtk.VSeparator()
        # Pack the separator into the container
        hbox.pack_start(separator, False, False, 10)
        # Show the separator.
        separator.show()


        # Create a vertical box.
        vbox = gtk.VButtonBox()
        # Show the vertical box.
        vbox.show()
        # Show the vertical box into the horizontal box.
        hbox.pack_start(vbox, False, False, 0)

        # Can use the get_active_text method, passing this combobox into it to get
        # the active text when relevant buttons are pressed.
        # So, don't re-use the name!
        self.multipolecombobox = gtk.combo_box_new_text()
        self.multipolecombobox.append_text("E2")
        self.multipolecombobox.append_text("M1")
        self.multipolecombobox.append_text("E1")
        self.multipolecombobox.append_text("E3")
        self.multipolecombobox.append_text("E4")
        self.multipolecombobox.append_text("E5")
        self.multipolecombobox.append_text("E6")
        self.multipolecombobox.append_text("M2")
        vbox.pack_start(self.multipolecombobox,False,False)
        self.multipolecombobox.show()

        # Can use the get_active_text method, passing rulecombobox into it to get
        # the active text when Add interband is called.
        # So, don't re-use the name rulecombobox!
        self.rulecombobox = gtk.combo_box_new_text()
        self.rulecombobox.append_text("alaga")
        self.rulecombobox.append_text("kforbidden")
        self.rulecombobox.append_text("mikhailov")
        vbox.pack_start(self.rulecombobox,False,False)
        self.rulecombobox.show()

        #newlabel = gtk.Label("Bands: I/F")
        newlabel = gtk.Label("Initial / final band")
        vbox.pack_start(newlabel)
        newlabel.show()
        
        # Entry box for initial band number
        self.initial_band_entry = gtk.Entry()
        self.initial_band_entry.set_max_length(2)
        self.initial_band_entry.set_text("1")
        vbox.pack_end(self.initial_band_entry, False, False, 0)
        self.initial_band_entry.show()

        # Entry box for final band number
        self.final_band_entry = gtk.Entry()
        self.final_band_entry.set_max_length(2)
        self.final_band_entry.set_text("1")
        vbox.pack_end(self.final_band_entry, False, False, 0)
        self.final_band_entry.show()


        button18 = gtk.Button("Add/change m.e.")
        self.button18_pointer = button18  # So that it can be forced active 
        button18.connect("clicked", self.add_me)
        # pack the button18 
        vbox.pack_start(button18, False, False)
        # Set the default flags 
        button18.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button18.grab_default()
        # Show the button18.
        button18.show()
        self.all_button_list.append(button18)

        button19 = gtk.Button("Filter (delete) m.e.")
        self.button19_pointer = button19  # So that it can be forced active 
        button19.connect("clicked", self.filter_me)
        # pack the button19 
        vbox.pack_start(button19, False, False)
        # Set the default flags 
        button19.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button19.grab_default()
        # Show the button19.
        button19.show()
        self.all_button_list.append(button19)

        button20 = gtk.Button("Fit parameters")
        self.button20_pointer = button20  # So that it can be forced active 
        button20.connect("clicked", self.define_fit_parameters)
        # pack the button20 
        vbox.pack_start(button20, False, False)
        # Set the default flags 
        button20.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button20.grab_default()
        # Show the button20.
        button20.show()
        self.all_button_list.append(button20)

        button23 = gtk.Button("Add/delete expt")
        self.button23_pointer = button23  # So that it can be forced active 
        button23.connect("clicked", self.add_delete_experiment)
        # pack the button23 
        vbox.pack_start(button23, False, False)
        # Set the default flags 
        button23.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button23.grab_default()
        # Show the button23.
        button23.show()
        self.all_button_list.append(button23)

        button21 = gtk.Button("Stopping power")
        self.button21_pointer = button21  # So that it can be forced active 
        button21.connect("clicked", self.examine_stopping_power)
        # pack the button21 
        vbox.pack_start(button21, False, False)
        # Set the default flags 
        button21.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button21.grab_default()
        # Show the button21.
        button21.show()
        self.all_button_list.append(button21)

        button22 = gtk.Button("Define Ge det.")
        self.button22_pointer = button22  # So that it can be forced active 
        button22.connect("clicked", self.define_ge_detector)
        # pack the button22 
        vbox.pack_start(button22, False, False)
        # Set the default flags 
        button22.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button22.grab_default()
        # Show the button22.
        button22.show()
        self.all_button_list.append(button22)

        button24 = gtk.Button("Attach/delete Ge dets.")
        self.button24_pointer = button24  # So that it can be forced active 
        button24.connect("clicked", self.attach_detectors)
        # pack the button24 
        vbox.pack_start(button24, False, False)
        # Set the default flags 
        button24.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button24.grab_default()
        # Show the button24.
        button24.show()
        self.all_button_list.append(button24)

        button25 = gtk.Button("Import yields")
        self.button25_pointer = button25  # So that it can be forced active 
        button25.connect("clicked", self.import_yield_data)
        # pack the button25 
        vbox.pack_start(button25, False, False)
        # Set the default flags 
        button25.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button25.grab_default()
        # Show the button25.
        button25.show()
        self.all_button_list.append(button25)

        button26 = gtk.Button("Write Gosia yld file")
        self.button26_pointer = button26  # So that it can be forced active 
        button26.connect("clicked", self.write_true_yields)
        # pack the button26 
        vbox.pack_start(button26, False, False)
        # Set the default flags 
        button26.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button26.grab_default()
        # Show the button26.
        button26.show()
        self.all_button_list.append(button26)

        button28 = gtk.Button("Reactivate GUI")
        self.button28_pointer = button28  # So that it can be forced active at all times, in case an untrapped error leaves the GUI frozen.
        button28.connect("clicked", self.reactivate)
        # pack the button28 
        vbox.pack_start(button28, False, False)
        # Set the default flags 
        button28.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button28.grab_default()
        # Show the button28.
        button28.show()
        self.all_button_list.append(button28)

        button29 = gtk.Button("Plot yields")
        self.button29_pointer = button29  # So that it can be forced active 
        button29.connect("clicked", self.plot_yields)
        # pack the button29 
        vbox.pack_start(button29, False, False)
        # Set the default flags 
        button29.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button29.grab_default()
        # Show the button29.
        button29.show()
        self.all_button_list.append(button29)
        self.recovery_mode_button_list.append(button29)

        button14 = gtk.Button("Help")
        self.button14_pointer = button14  # So that it can be forced active 
        button14.connect("clicked", self.interactive_help)
        # pack the button14 
        vbox.pack_start(button14, False, False)
        # Set the default flags 
        button14.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button14.grab_default()
        # Show the button14.
        button14.show()
        self.all_button_list.append(button14)
        self.recovery_mode_button_list.append(button14)

        # create a vertical separator.
        separator = gtk.VSeparator()
        # Pack the separator into the container
        box1.pack_start(separator, False, False, 0)
        # Show the separator.
        separator.show()

        # Create a new vertical box.
        box2 = gtk.VBox(False, 10)
        # Set the border width of the box.
        box2.set_border_width(10)
        # Pack the vertical box into the first created vertical box.
        box1.pack_start(box2, False, False, 0)   # changed second true to false
        # Show the newly created vertical box.
        box2.show()

        # create a scrolled window.
        sw = gtk.ScrolledWindow()
        # Set the adjustments for horizontal and vertical scroll bars.
        # POLICY_AUTOMATIC will automatically decide whether you need
        # scrollbars.
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        # Create a text view widget. When a text view is created it will
        # create an associated textbuffer by default.
        self.textview = gtk.TextView()
        # Make it not editable.  This is causing output to be written at the cursor position instead of at the bottom.
        self.textview.set_editable(False)
        # Make the cursor invisible.
        self.textview.set_cursor_visible(False)
        # Trying to make this wide enough to read...
        self.textview.set_size_request(550,400)
        # Retrieving a reference to a textbuffer from a textview. 
        self.textbuffer = self.textview.get_buffer()
        # Add the textview to the scrolled window.
        sw.add(self.textview)
        # Show the scrolled window widget.
        sw.show()
        # Set the font.
        the_font = pango.FontDescription("Courier 12")
        self.textview.modify_font(the_font)
        # Show the text view widget.
        self.textview.show()
        # Pack the scrolled window into the second vertical box.
        box2.pack_start(sw)
        self.scrolled_window = sw
        
        # hbox for bottom buttons
        hbox = gtk.HBox()
        # pack the horizontal button box into the vertical box.
        box2.pack_start(hbox, False, False, 0)
        # Show the horizontal button box.
        hbox.show()

        # Don't reuse the name of this box, because it's neede for reading the selection
        self.gosiafunctioncombobox = gtk.combo_box_new_text()
        self.gosiafunctioncombobox.append_text("Make Ge det file")
        self.gosiafunctioncombobox.append_text("Integrated yields")
        self.gosiafunctioncombobox.append_text("Make corrected yields")
        #self.gosiafunctioncombobox.append_text("Estimate normalizations")
        self.gosiafunctioncombobox.append_text("Fit")  # meant to do the OP,MAP also, since there are no user parameters for OP,MAP
        self.gosiafunctioncombobox.append_text("[Diagonal errors]") 
        self.gosiafunctioncombobox.append_text("Correlated errors") 
        #self.gosiafunctioncombobox.append_text("Quick point yields")
        self.gosiafunctioncombobox.append_text("Make simulated yields")
        self.gosiafunctioncombobox.append_text("Calculate lifetimes")
        self.gosiafunctioncombobox.append_text("Deorientation coeff.")

        hbox.pack_start(self.gosiafunctioncombobox,False,False)
        self.gosiafunctioncombobox.show()

        # Don't reuse the name of this box, because it's neede for reading the selection
        self.gosiaactioncombobox = gtk.combo_box_new_text()
        self.gosiaactioncombobox.append_text("View gosia input")
        self.gosiaactioncombobox.append_text("Save gosia input")
        self.gosiaactioncombobox.append_text("Run gosia input")
        hbox.pack_start(self.gosiaactioncombobox,False,False)
        self.gosiaactioncombobox.show()

        # Create a new button "run gosia input"
        button30 = gtk.Button("Go")
        button30.connect("clicked", self.gosia_go)
        # pack the button30 
        hbox.pack_start(button30, False, False)
        # Set the default flags 
        button30.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button30.grab_default()
        # Show the button30.
        button30.show()
        self.all_button_list.append(button30)

        # Create a new button to clear the textview buffer.
        button33 = gtk.Button("Clear")
        button33.connect("clicked", self.clear_textview)
        # pack the button33 
        hbox.pack_start(button33, False, False)
        # Set the default flags 
        button33.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button33.grab_default()
        # Show the button33.
        button33.show()
        self.all_button_list.append(button33)

        # Create a new button "quit".
        button31 = gtk.Button("Quit")
        # When the button31 is clicked call "close application" which quits
        # GTk.
        button31.connect("clicked", self.close_application)
        # pack the button31 
        hbox.pack_end(button31, False, False)
        # Set the default flags 
        button31.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button31.grab_default()
        # Show the button.
        button31.show()
        self.all_button_list.append(button31)
        self.recovery_mode_button_list.append(button31)
        
        if SCRIPT_MODE:
            # Create a new button to run a python script.
            button34 = gtk.Button("Script")
            # Not sure this will work the way I expect...
            button34.connect("clicked", self.run_script)
            # pack the button34 
            hbox.pack_end(button34, False, False)
            # Set the default flags 
            button34.set_flags(gtk.CAN_DEFAULT)
            # Grab the default
            button34.grab_default()
            # Show the button34.
            button34.show()
            self.all_button_list.append(button34)
        

        # Create a new button to let user give a command
        button32 = gtk.Button("Eval")
        # Not sure this will work the way I expect...
        button32.connect("clicked", self.user_command)
        # pack the button32 
        hbox.pack_start(button32, False, False)
        # Set the default flags 
        button32.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button32.grab_default()
        # Show the button32.
        button32.show()
        self.all_button_list.append(button32)
        
        # Create a new button to view/edit logs
        button35 = gtk.Button("Log")
        # Not sure this will work the way I expect...
        button35.connect("clicked", self.logs)
        # pack the button35 
        hbox.pack_start(button35, False, False)
        # Set the default flags 
        button35.set_flags(gtk.CAN_DEFAULT)
        # Grab the default
        button35.grab_default()
        # Show the button35.
        button35.show()
        self.all_button_list.append(button35)
        
        if DEBUGGING_MODE:
            debugging_button = gtk.Button("DEBUG")
            self.debugging_button_pointer = debugging_button  # So that it can be forced active 
            debugging_button.connect("clicked", self.top_level_testing)
            # pack the debugging_button 
            hbox.pack_end(debugging_button, False, False)
            # Set the default flags 
            debugging_button.set_flags(gtk.CAN_DEFAULT)
            # Grab the default
            debugging_button.grab_default()
            # Show the debugging_button.
            debugging_button.show()
            self.all_button_list.append(debugging_button)

        # Show the window.
        window.show()

        if not nosplash:
            welcome()   # run the splash screen.  
            while gtk.events_pending():
                gtk.main_iteration()
            time.sleep(5)
            welcome(hide=True)

        # Check to see if the GUI is in recovery mode.  If so, set active buttons as appropriate.
        if RECOVERY_MODE:
            self.set_recovery_mode(self)

        # Try to load the about file into the text window.
        try:
            the_welcome_file = GLOBAL_SETUP_DICT["RACHEL_DIRECTORY"] + "/necessary_files/about_rachel.txt"
            infile = open(the_welcome_file, "r")

            if infile:
                string = infile.read()
                infile.close()
            # The file could be read.  Now call the about() method to put it in the textview.
            self.about(self)
        except:
            print "Could not find Rachel auxiliary files.  The .rachel_setup file may not have the correct path."
            if yes_no_prompt("Would you like to generate a new setup file [Y/n]: ",True):
                generate_dot_rachel_setup_file()


        # Display a getting-started tip.
        create_popup_tip("getting_started")

        # Check for version updates or other messages.
        # If result == False, then the server did not give the expected
        # response.  Not much point in trying to notify Rochester.
        up = updater()
        result = up.report_all()


#######################################################################
#  Math functions below.                                              #
#######################################################################

def minimum_beam_energy(beam_mass,target_mass,excitation_energy):
    """Calculates the minimum beam energy that can populate a state, given the energy of the state.

    by inverting the formula for maximum excitation energy used in Gosia:
        ared = 1.0 + a1/a2 
        emax = EP(lexp)/ared 

    where a1, a2 and EP(lexp) are the beam mass, target mass and the beam
    energy for experiment number lexp, respectively.

    EP = ared * emax 

    Pass the excitation energy in keV.
    Returns a beam energy in MeV.

    """

    a1 = float(beam_mass)
    a2 = float(target_mass)
    excitation_energy_MeV = float(excitation_energy) / 1000.

    ared = 1.0 + a1/a2 # reduced mass
    minimum_beam_energy = excitation_energy_MeV * ared

    return minimum_beam_energy

def maximum_excitation_energy(beam_mass,target_mass,beam_energy):
    """Calculates the maximum excitation energy that can be reached

    according to the same formula used in Gosia:
        ared = 1.0 + a1/a2 
        emax = EP(lexp)/ared 

    where a1, a2 and EP(lexp) are the beam mass, target mass and the beam
    energy for experiment number lexp, respectively.
    Pass the beam energy in MeV.
    Returns the excitation energy in keV.

    """

    a1 = float(beam_mass)
    a2 = float(target_mass)
    beam_energy = float(beam_energy)

    ared = 1.0 + a1/a2 # reduced mass
    emax = beam_energy / ared
    emax_keV = emax * 1000.0  # Level energies are always in keV; beam energies in MeV

    return emax_keV


def standard_p_gamma_events(I_passed,days_passed,A_passed,Gosia_yield_passed,gamma_efficiency_passed):
    """Calculates the total number of p-gamma events detected in a beam run 
    using the standard definition of efficiency.

    p_gamma_events(I,days,A,Gosia_yield,gamma_efficiency)

    using "days" days of I [pnA] beam current, for a target of mass number A,
    Gosia_yield [mb*mg/cm^2/sr], gamma photopeak efficiency [0--1] and
    delta_Omega [sr] of the Ge detector.

    This function uses the standard definition of efficiency, i.e., the
    fraction of gammas emitted isotropically into 4pi that are measured in the
    photopeak.  For example, at 1333 keV, for Gammasphere, efficiency = 0.089.

    """

    # Convert to floats
    I = float(I_passed)                                # [pnA]
    days = float(days_passed)                          # [days] of beam run
    A = float(A_passed)                                # [g/mol] mass number of target
    Gosia_yield = float(Gosia_yield_passed)            # [mb*mg/cm^2/sr]
    gamma_efficiency = float(gamma_efficiency_passed)  # [1]
    N_A = 6.02E+23                                     # [atoms per mol] (Avogadro's number)

    total_beam_particles =  I * days * 1.0E-9 * 6.242E+18 * 3600. * 24. 
    detected_events      =  1.0E-30 * total_beam_particles * (N_A / A) * Gosia_yield * gamma_efficiency * 4. * math.pi

    return detected_events

def p_gamma_events(I_passed,days_passed,A_passed,Gosia_yield_passed,gamma_efficiency_passed,delta_Omega_passed):
    """Calculates the total number of p-gamma events detected in a beam run 

    p_gamma_events(I,days,A,Gosia_yield,gamma_efficiency,delta_Omega)

    of "days" days of I [pnA] beam current, for a target of mass number A,
    Gosia_yield [mb*mg/cm^2/sr], gamma photopeak efficiency [0--1] and
    delta_Omega [sr] of the Ge detector.

    The "_passed" subscript is used because all quantities are turned into
    floats before doing the calculation.

    """

    # Convert to floats
    I = float(I_passed)                                # [pnA]
    days = float(days_passed)                          # [days] of beam run
    A = float(A_passed)                                # [g/mol] mass number of target
    Gosia_yield = float(Gosia_yield_passed)            # [mb*mg/cm^2/sr]
    gamma_efficiency = float(gamma_efficiency_passed)  # [1]
    delta_Omega_Ge = float(delta_Omega_passed)         # [sr]
    N_A = 6.02E+23                                     # [atoms per mol] (Avogadro's number)

    total_beam_particles =  I * days * 1.0E-9 * 6.242E+18 * 3600. * 24. 
    detected_events      =  1.0E-30 * total_beam_particles * (N_A / A) * Gosia_yield * gamma_efficiency * delta_Omega_Ge 

    return detected_events




#def absolute_efficiency(E_gamma_passed, efficiency_parameters = None, overall_normalization = None, curve_type = "radware"):
#    """Calculates the absolute gamma efficiency 
#
#    (Radware, others to be added.)
#
#    Syntax absolute_efficiency(E_gamma[keV],parameter_list)
#
#    The efficiency parameters are the ones used in Radware.  Their values can
#    be passed in as a list.  If they are not, then the values are taken from
#    DEFAULT_EFFICIENCY_PARAMETERS.
#
#    e.g.
#    [5.7021, 4.83491, 0., 6.20016, -6.06E-01, -5.36E-03, 4.5934, 0.000219]
#     A       B        C   D        E          F          G       N 
#
#    N is a scale factor for estimated absolute efficiency.
#
#    """
#
#    E_gamma = float(E_gamma_passed)
#
#    if curve_type == "radware":
#        if efficiency_parameters == None:
#            # Use the default values:
#            A, B, C, D, E, F, G = DEFAULT_EFFICIENCY_PARAMETERS[:7]
#        else:
#            # Efficiency parameters were passed in.  Convert them all to floats:
#            A = float(efficiency_parameters[0])
#            B = float(efficiency_parameters[1])
#            C = float(efficiency_parameters[2])
#            D = float(efficiency_parameters[3])
#            E = float(efficiency_parameters[4])
#            F = float(efficiency_parameters[5])
#            G = float(efficiency_parameters[6])
#
#        if overall_normalization == None:
#            # Use the default value.
#            N = DEFAULT_EFFICIENCY_PARAMETERS[7]
#        else:
#            # Use the value passed by the caller.
#            N = float(overall_normalization)
#
#        # See D. Radford, Nucl. Instruments and Methods A 361:297 (1995) for the
#        # form of the efficiency curve.
#
#        x = math.log(float(E_gamma) / 100.)
#        y = math.log(float(E_gamma) / 1000.)
#
#        first_quadratic  =   A  +  B * x  +  C * x**2
#        second_quadratic =   D  +  E * y  +  F * y**2
#        ln_efficiency = (first_quadratic**(-G) + second_quadratic**(-G))**(-1. / G)
#        absolute_efficiency = N * math.exp(ln_efficiency)
#
#    elif curve_type == "miniball":
#        curve_data = the_detector_manager.understood_efficiency_curve_types["miniball"]
#        if efficiency_parameters == None:
#            # Use the default values:
#            par = curve_data[default_parameter_values]
#        else:
#            # Efficiency parameters were passed in.  Convert them all to floats:
#            A = float(efficiency_parameters[0])
#            B = float(efficiency_parameters[1])
#            C = float(efficiency_parameters[2])
#            D = float(efficiency_parameters[3])
#            E = float(efficiency_parameters[4])
#            F = float(efficiency_parameters[5])
#            G = float(efficiency_parameters[6])
#
#        if overall_normalization == None:
#            # Use the default value.
#            N = DEFAULT_EFFICIENCY_PARAMETERS[7]
#        else:
#            # Use the value passed by the caller.
#            N = float(overall_normalization)
#        
#    return absolute_efficiency





def one_step_perturbation_cross_section(elambda_text,BElambda_passed,Z_proj_passed,A_proj_passed,Z_targ_passed,A_targ_passed,E_mean_passed,E_excited_state_passed):
    """Calculates the one-step excitation cross section for 4pi scattering in mb.

    I am not sure that I calculated this correctly.  Should re-check against Alder,Winther _Coulomb_Excitation_ pg. 103.

    This only works for E2 and E1.

    See Alder, Winther, _Coulomb_Excitation_ pg. 103.  

    Syntax: one_step_perturbation_cross_section(elambda_text,BElambda,Z_proj,A_proj,Z_targ,A_targ,E_mean,E_excited_state)

    where E_mean is the mean beam energy as the projectile traverses the target in MeV.
      E_excited_state is the energy of the one excited state in keV!,
      and BElambda is in e,b to appropriate powers

    """

    elambda_text = elambda_text.lower()
    if elambda_text in ["e1","e2"]:
        l = MULTIPOLE_LAMBDA[elambda_text]

        #Convert all to floats
        Z_proj = float(Z_proj_passed)
        Z_targ = float(Z_targ_passed)
        A_proj = float(A_proj_passed)
        A_targ = float(A_targ_passed)
        E_mean = float(E_mean_passed)   # Already in MeV
        E_excited_state = float(E_excited_state_passed)   # Still in keV to pass to adiabaticity function.
        BElambda = float(BElambda_passed)

        sigma_4pi = winther_C_Elambda(elambda_text,Z_proj,A_proj,Z_targ,A_targ) * E_mean**(l-2) *\
          (E_mean - E_excited_state/1000.)**(l-1) * BElambda *\
          f_function(elambda_text,symmetrized_adiabaticity(Z_proj,A_proj,Z_targ,A_targ,E_mean,E_excited_state))\
          *1000.   # Convert to mb

        return sigma_4pi

    else:
        print "Error in one_step_perturbation_cross_section: multipole not allowed."
        return -1



def winther_C_Elambda(elambda_text,Z_proj_passed,A_proj_passed,Z_targ_passed,A_targ_passed):
    """Calculates the Alder,Winther classical f function for E1 or E2 only in barns.

    See Alder, Winther, _Coulomb_Excitation_ pg. 103.  

    Syntax: winther_C_Elambda(elambda_text,Z_proj,A_proj,Z_targ,A_targ)

    """

    elambda_text = elambda_text.lower()
    if elambda_text in ["e1","e2","e3"]:
        l = float(MULTIPOLE_LAMBDA[elambda_text])

        #Convert all to floats
        Z_proj = float(Z_proj_passed)
        Z_targ = float(Z_targ_passed)
        A_proj = float(A_proj_passed)
        A_targ = float(A_targ_passed)

        C_Elambda = ((Z_proj**2 * A_proj) / 40.03) * (0.07199 * (1. + A_proj / A_targ) * Z_proj * Z_targ)**(-2. * l + 2.)
        return C_Elambda 
    else:
        print "Error in winther_C_Elambda: multipole not allowed."
        return -1


def f_function(mlambda_text,xi):
    """Calculates the Alder,Winther classical f function for E1 or E2 only.

    See Alder, Winther, _Coulomb_Excitation_ pg. 103.  This is an interpolation
    from a fit to their table.

    Syntax: f_function(mlambda_text,xi)
    where xi is the SYMMETRIZED adiabaticity for a one-step excitation.

    """

    if xi < 0.05 or xi > 2.:
        print "Error in f_function: xi out of range for accuracy."
        return -1

    mlambda_text = mlambda_text.lower()

    # ln(f) function constants from 3rd order fit:
    # order of constants is for xi**0,xi**1,xi**2,xi**3
    coefficients={"e1":[4.7338E+00,-7.1870E+00,6.5744E-01,-1.6160E-01],\
    "e2":[-1.4619E-02,-1.2862E+00,-2.8688E+00,6.5154E-01]}

    if mlambda_text in coefficients.keys():
        C = coefficients[mlambda_text]
        ln_f = C[0] + C[1]*xi + C[2]*xi**2 + C[3]*xi**3

        f = math.exp(ln_f)
        return f

    else:
        print "Error in f_function--can't calculate for ",mlambda_text
        return -1


def symmetrized_adiabaticity(Z_proj_passed,A_proj_passed,Z_targ_passed,A_targ_passed,E_mean_passed,E_excited_state_passed):
    """Calculates the symmetrized adiabaticity for a two-state system.

    Syntax: 
    symmetrized_adiabaticity(Z_proj,A_proj,Z_targ,A_targ,E_mean,E_excited_state),
    where E_mean [MeV] is the mean beam energy as the projectile traverses the target.
    and E_excited_state is the energy of the excited state in keV!!!


    """

    #Convert all to floats
    Z_proj = float(Z_proj_passed)
    Z_targ = float(Z_targ_passed)
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    E_mean = float(E_mean_passed)   # Already in MeV
    E_excited_state = float(E_excited_state_passed)   # Still in keV to pass to sommerfeld functions!

    excited_state_sommerfeld_parameter = sommerfeld_parameter(Z_proj,A_proj,Z_targ,A_targ,E_mean,E_excited_state)
    ground_state_sommerfeld_parameter = sommerfeld_parameter(Z_proj,A_proj,Z_targ,A_targ,E_mean)

    return excited_state_sommerfeld_parameter - ground_state_sommerfeld_parameter

def final_kinetic_energy_for_one_step_coulex(A_proj_passed,A_targ_passed,E_mean_passed,E_excited_state_passed):
    """Returns the final kinetic energy of the beam after excitation to the excited state.
    
    Syntax: final_kinetic_energy(A_proj,A_targ,E_mean,E_excited_state)
    where E_mean [MeV] is the mean beam energy as the projectile traverses the target.
    and E_excited_state is the energy of the excited state in keV!!!

    """

    #Convert all to floats
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    E_mean = float(E_mean_passed)   # Already in MeV
    E_excited_state = float(E_excited_state_passed)/1000.  # Converted to MeV

    # Checked this against Alder-Winther _Coulomb_Excitation_ and extracted
    # values from modified gosia version gosia_20081208.10-print-eta-xi.f
    final_energy = E_mean - E_excited_state * (1. + A_proj / A_targ)
    return final_energy


def stddev(list_of_values):
    """Calculates the standard deviation of a list of floats

    Syntax stddev(list_of_values),
      where list_of_values is a standard Python list of floats: [1.,2.,4.,3.,2.,3.,5....].

    The values must be passed as a list or similar type, e.g. "[first, second,
    third...]".


    """

    sum_of_list = sum(list_of_values)
    average = sum_of_list/len(list_of_values)
    standard_deviation = 0.
    for one_number in list_of_values:
        standard_deviation += abs((one_number - average)/(len(list_of_values)-1))

    return standard_deviation


def bmlambda(spin,rme):
    """Calculates a reduced transition probability from a reduced matrix element

    Syntax: bmlambda(spin,rme) 

    rme     - the reduced matrix element
    spin    - the spin of the initial state of the transition

    """
    return (float(rme)**2)/(2.*float(spin) + 1)



def calc_wu(A,multipole_text):
    """Returns the Weisskopf estimate in e,b or n.m.

    Syntax: calc_wu(A,multipole)
    where multipole is one of e1...e5 or m1...m5

    The W.u. is calculated in the usual downward direction.

    """
    # Convert multipole to lowercase.
    this_multipole_text = multipole_text.lower()
  
    #Constants for calculating Weisskopf units [e,b,n.m.]
    wu_constant = {'e1': 6.445E-4,'e2': 5.940E-6,'e3': 5.940E-8,'e4': 6.285E-10,\
                   'e5': 6.929E-12,'m1': 1.790,'m2': 1.650E-2,'m3': 1.650E-4,\
                   'm4': 1.746E-6, 'm5': 1.925E-8}
    # powers of A (mass) for calculating W.u.
    A_exponent =  {'e1': 2./3.,'e2':4./3.,'e3':6./3.,'e4':8./3.,'e5':10./3.,\
                   'm1': 0, 'm2':2./3.,'m3':4./3.,'m4':6./3.,'m5':8./3.}
    # The units of B(Ml)_{W.u.}
    wu_units = {'e1':'e^2b', 'e2':'e^2b^2', 'e3':'e^2b^3', 'e4':'e^2b^4',\
                'e5':'e^2b^5', 'e6':'e^2b^6', 'm1':'nm^2', 'm2':'nm^2b',\
                'm3':'nm^2b^2', 'm4':'nm^2b^3', 'm5':'nm^2b^4'}

    # If the requested multipole is not in the keys of the constants,
    # then it cannot be calculated
    if this_multipole_text in wu_constant.keys():
        wu = wu_constant[this_multipole_text] * float(A)**A_exponent[this_multipole_text]
        return wu
    else:
        return "calc_wu error: invalid multipole"


# def integrated_rutherford_cross_section(Z_proj_passed,A_proj_passed,Z_targ_passed,A_targ_passed,E_lab_passed,theta_min_lab_passed,theta_max_lab_passed,recoil=False):
#     """ Returns the integrated Rutherford cross section in mb in the lab frame,
#     currently only for azimuthal symmetry, summed for both kinematic solutions,
#     if the Z,A values indicate inverse kinematics.
# 
#     **************THIS IS NOT SYMMETRIZED AND Q-DEPENDENT.  NEEDS UPDATES.**************
# 
#     Syntax: integrated_rutherford_cross_section(Z_proj,A_proj,Z_targ,A_targ,E_lab,theta_min_lab,theta_max_lab,recoil=False)
#     (If True is not passed as the last parameter, then projectile angles are assumed.)
# 
#     If the maximum scattering angle is greater than allowed for inverse
#     kinematics, it returns -1.
# 
#     If the minimum projectile angle is less than 0.01, then it returns -2
# 
#     If recoil=True, then it interprets the angles theta_min_lab, theta_max_lab
#     as recoil angles.
# 
#     """
# 
# 
# 
#     #Borrowed some lines from Wu's ruthxx.f code, but some 
#     #apparent similarities might be misleading.
# 
#     #         ruthi - multiplicative constant for cross section function
#     #                 The factor 1.296 converts the cross sections to millibarns (mb).
#       
# 
#     # Convert all to floats
#     Z_proj = float(Z_proj_passed)
#     A_proj = float(A_proj_passed)
#     Z_targ = float(Z_targ_passed)
#     A_targ = float(A_targ_passed)
#     E_lab = float(E_lab_passed)
#     theta_min_lab = float(theta_min_lab_passed)
#     theta_max_lab = float(theta_max_lab_passed)
# 
#     E_beam_com = beam_energy_com(A_proj,A_targ,E_lab)
# 
#     am=A_proj*A_targ/(A_proj+A_targ)**2
#     ruthi=(Z_proj*Z_targ)**2*1.296/E_beam_com**2       # gives result in mb.
# 
#     # If projectile angles were passed
#     if A_proj <= A_targ:
#         inverse = False
#     else:
#         inverse = True
# 
#     if not recoil:
#         # If projectile angles were passed
#         if not inverse:
#             theta_scattering_limit = 180.  # In the lab frame
#         else:
#             theta_scattering_limit = math.degrees(math.asin(A_targ/A_proj))   # In the lab frame, in degrees
# 
#         if theta_max_lab > theta_scattering_limit:
#             return -1
# 
#         if theta_min_lab < 0.01:
#             return -2  # Trying to integrate too close to 0 degrees
#         theta_com_low = theta_scattering_com(A_proj,A_targ,theta_min_lab,True)  # True means forward solution
#         theta_com_high = theta_scattering_com(A_proj,A_targ,theta_max_lab,True)  # True means forward solution
#         
# 
#         # For normal kinematics or the first scattering solution for inverse kinematics
#         integrated_cross_section = 2. * math.pi * ruthi * 4. * ((1. / (math.cos(math.radians(theta_com_high)) - 1.))\
#           - (1. / (math.cos(math.radians(theta_com_low)) - 1.)))
# 
#         # If it's an inverse-kinematics case, then compute the same integral for the second solution
# 
#         if inverse:
#             theta_com_low = theta_scattering_com(A_proj,A_targ,theta_min_lab,False)  # False means backward solution
#             theta_com_high = theta_scattering_com(A_proj,A_targ,theta_max_lab,False)  # False means backward solution
# 
#             integrated_cross_section += 2. * math.pi * ruthi * 4. * ((1. / (math.cos(math.radians(theta_com_high)) - 1.))\
#               - (1. / (math.cos(math.radians(theta_com_low)) - 1.)))
#   
#         return integrated_cross_section
# 
#     else:
#         # Recoil angles were passed.
# 
#         if theta_max_lab > 89.9:
#             #Trying to integrate too close to 0 deg scattering (90 recoil)
#             return -2
#         else:
#             # Recoil angles were passed.
#             theta_scat_lab_1 = theta_recoil_to_scattering_lab(A_proj,A_targ,theta_max_lab)
#             theta_scat_lab_2 = theta_recoil_to_scattering_lab(A_proj,A_targ,theta_min_lab)
#             theta_scat_com_1 = theta_scattering_com(A_proj,A_targ,theta_scat_lab_1)
#             theta_scat_com_2 = theta_scattering_com(A_proj,A_targ,theta_scat_lab_2)
#             theta_scat_com_max = max(theta_scat_com_1,theta_scat_com_2)
#             theta_scat_com_min = min(theta_scat_com_1,theta_scat_com_2)
#             integrated_cross_section = 2. * math.pi * ruthi * 4. * ((1. / (math.cos(math.radians(theta_scat_com_max)) - 1.))\
#               - (1. / (math.cos(math.radians(theta_scat_com_min)) - 1.)))
#             if inverse:
#                 # Now we need to add the second solution.
#                 theta_scat_lab_1 = theta_recoil_to_scattering_lab(A_proj,A_targ,theta_max_lab)
#                 theta_scat_lab_2 = theta_recoil_to_scattering_lab(A_proj,A_targ,theta_min_lab)
#                 theta_scat_com_1 = theta_scattering_com(A_proj,A_targ,theta_scat_lab_1,False)
#                 theta_scat_com_2 = theta_scattering_com(A_proj,A_targ,theta_scat_lab_2,False)
#                 theta_scat_com_max = max(theta_scat_com_1,theta_scat_com_2)
#                 theta_scat_com_min = min(theta_scat_com_1,theta_scat_com_2)
#                 integrated_cross_section += 2. * math.pi * ruthi * 4. * ((1. / (math.cos(math.radians(theta_scat_com_max)) - 1.))\
#                   - (1. / (math.cos(math.radians(theta_scat_com_min)) - 1.)))
# 
#             return integrated_cross_section


def time_reversal(I_a,I_b,multipole_text,a_to_b_matrix_element):
    """Calculates a time-reversed matrix element.

    For a_to_b_matrix_element = <b|ML|a>, 
    <a|EL|b> = (-)^(I_b+L-I_a)*<b|EL|a> and
    <a|ML|b> = (-)^(I_b+L-I_a+1)*<b|ML|a>

    Syntax: time_reversal(I_a,I_b,multipole,<b||ML||a>)
    where multipole is one of e1...e5 or m1...m5

    """

    L = MULTIPOLE_LAMBDA[multipole_text]  # lambda of the operator
    if multipole_text.upper()[0] == 'E':
        # Electric transition
        sign_term = (-1)**int(round(I_b + L - I_a))
    else:
        # Magnetic transition
        sign_term = (-1)**int(round(I_b + L - I_a + 1))

    b_to_a_matrix_element = sign_term * a_to_b_matrix_element
    return b_to_a_matrix_element 

def cgc(j1,m1,j2,m2,j3,m3):
    """Calculates a Clebsch-Gordan coefficient <j1 m1 j2 m2 | j3 m3>

    The order of terms is the same as in Bohr and Mottelson.

    Syntax: cgc(j1,m1,j2,m2,j3,m3)


    This is not a 3-j!

    """

    return ned(j1,j2,j3,m1,m2,m3)

def ned(aj,bj,cj,am,bm,cm):
    """Calculates a Clebsch-Gordan coefficient (*not* a 3-J)

    Can easily be modified so that the user can choose cgc or 3-J.

    This is now fully tested and accurate in magnitude and phase for both
    integer and half-integer spins up to I=60hbar.

    It fills a large 2d array each time it is called.  This can be changed by
    changing ned to a class and creating a single object of ned to reuse
    throughout the code, but the execution time is very small in Python,
    possibly due to delayed garbage collection.  

    Translated from ned.f by Arturo Quirantes, "A. Quirantes" in the
    literature.

    http://www.ugr.es/~aquiran/codigos.htm

    Some of the lines of code have the original fortran in comments next to
    them or preceding.
    
    NED original header comments:
    C    ARTURO QUIRANTES SIERRA
    C    Department of Applied Physics, Faculty of Sciences
    C    University of Granada, 18071 Granada (SPAIN)
    C    http://www.ugr.es/local/aquiran/codigos.htm
    C    aquiran@ugr.es
    C
    C    Last update: 20 May 2.003    

    """

    zz=int(max(2.*aj+1.,2.*bj+1.,2.*cj+1.,aj+bj+cj,aj+am,bj+bm,cj+cm))+2

    # Since this creates an array of arbitrary size, we need to prevent the user
    # taking too much memory.
    if (zz+1)**2 > MAX2DARRAYSIZE:
        return 'MAX2DARRAYSIZE violated in ned().' 

    q=numpy.zeros((zz+1,zz+1))     # numpy functions return data on demand, saving space and time.
    for i in range(1,zz+1):                                                     #    loop from 1 to zz
        q[i][1] = 1.0                                                           #    q(i,1)=1.d0
        q[i][i] = 1.0                                                           #    q(i,i)=1.d0
                                                                                #2   continue

    for i in range(2,zz):                                                       #    do 3 i=2,zz-1
        for k in range(2,i+1):                                                  #    do 3 k=2,i
            q[i+1][k] = q[i][k-1] + q[i][k]                                     #    q(i+1,k)=q(i,k-1)+q(i,k)
                                                                                #3   continue
    cg = 0.                                                                     #    cg=0.d0
    ja=int(aj+am+1.01)    # truncate (toward 0)                                 #    ja=aj+am+1.01d0
    ma=int(aj-am+1.01)                                                          #    ma=aj-am+1.01d0
    jb=int(bj+bm+1.01)                                                          #    jb=bj+bm+1.01d0
    mb=int(bj-bm+1.01)                                                          #    mb=bj-bm+1.01d0
    jc=int(cj+cm+1.01)                                                          #    jc=cj+cm+1.01d0
    mc=int(cj-cm+1.01)                                                          #    mc=cj-cm+1.01d0
    la=int(bj+cj-aj+1.01)                                                       #    la=bj+cj-aj+1.01d0
    lb=int(cj+aj-bj+1.01)                                                       #    lb=cj+aj-bj+1.01d0
    lc=int(aj+bj-cj+1.01)                                                       #    lc=aj+bj-cj+1.01d0
    lt=int(aj+bj+cj+1.01)                                                       #    lt=aj+bj+cj+1.01d0
    d= abs(am+bm-cm)-0.01                                                       #    d=dabs(am+bm-cm)-0.01d0

    # The if (expression) a,b,c  form jumps to line number a for expr < 0, b
    # for expr = 0 or c for expr > 0 (fortran).

    if d <= 0.0:                                                                #    if (d) 10,10,20
        ld = min(ja,jb,jc,ma,mb,mc,la,lb,lc)  # integer                         #10  ld=min0(ja,jb,jc,ma,mb,mc,la,lb,lc)
    else:                                     # does not exist  
        return 0.0                            # zero if can't couple

    if ld > 0:                                                                  #    if (ld) 20,20,30
        ja2=int(aj+aj+am+am)                                                    #30  ja2=aj+aj+am+am
        jb2=int(bj+bj+bm+bm)                                                    #    jb2=bj+bj+bm+bm
        jc2=int(cj+cj-cm-cm)                                                    #    jc2=cj+cj-cm-cm
        i2=ja2+jb2+jc2-ja2/2*2-jb2/2*2-jc2/2*2                                  #    i2=ja2+jb2+jc2-ja2/2*2-jb2/2*2-jc2/2*2
        if i2 == 0:                                                             #    if (i2) 20,40,20
            fn=q[ja+ma-1][lc] / q[lt][jc+mc-1]                                  #40  fn=q(ja+ma-1,lc)/q(lt,jc+mc-1)
            fn=fn*q[jb+mb-1][lc] / q[lt+1][2]                                   #    fn=fn*q(jb+mb-1,lc)/q(lt+1,2)
            fn=fn/q[ja+ma-1][ja]                                                #    fn=fn/q(ja+ma-1,ja)
            fn=fn/q[jb+mb-1][jb]                                                #    fn=fn/q(jb+mb-1,jb)
            fn=fn/q[jc+mc-1][jc]                                                #    fn=fn/q(jc+mc-1,jc)
            k0=max(0,lc-ja,lc-mb)+1                                             #    k0=max(0,lc-ja,lc-mb)+1
            k1=min(lc,ma,jb)                                                    #    k1=min(lc,ma,jb)
            x=0.                                                                #    x=0.d0
            for k in range(k0,k1+1):                                            #    do 50 k=k0,k1
                x=-x-q[lc][k]*q[lb][ma-k+1]*q[la][jb-k+1]                       #    x=-x-q(lc,k)*q(lb,ma-k+1)*q(la,jb-k+1)
                                                                                #50  continue
            ip=k1+lb+jc                                                         #    ip=k1+lb+jc
            p=float(1-2*(ip-ip/2*2))                                            #    p=1-2*(ip-ip/2*2)
            cg=p*x*math.sqrt(fn)                                                #    cg=p*x*dsqrt(fn)

            #    What we've calculated is a Wigner 3-j coefficient.  Next,
            #    we'll turn it into a Clebsch-Gordan coefficient.   Python's
            #    "round" returns a float, but for a power of negative 1, this
            #    is accurate.  Physically, aj-bj-cm will always be an integer.

            powerterm = int(abs(aj-bj-cm) + 0.1)
            # (Added 0.1 to make sure it rounds to the nearest integer.)
            cg=cg*math.sqrt(2*cj+1)*(-1)**powerterm                             #    cg=cg*dsqrt(2*cj+1)*(-1)**idnint(aj-bj-cm)
                                                                                #20  continue
            return cg                                                           #    return
        else:
            return 0.0  # Return zero if can't couple.
    else:
        return cg



def sommerfeld_parameter(Z_proj_passed,A_proj_passed,Z_targ_passed,A_targ_passed,E_mean_passed,E_excited_state_passed=None):
    """Returns the Sommerfeld parameter.

    See the Gosia manual or for convenient units Alder, Winther,
    _Electromagnetic_Excitation_, American Elsevier, New York (1975), page 270.

    Syntax: 
    sommerfeld_parameter(Z_proj,A_proj,Z_targ,A_targ,E_mean),
    or sommerfeld_parameter(Z_proj,A_proj,Z_targ,A_targ,E_mean,E_excited_state,
    where E_mean is the mean beam energy [MeV] as the projectile traverses the target
    and E_excited state, if it is included (in keV!!!) indicateds that the sommerfeld
    parameter will be calculated for the one-step excitation final energy.

    """

    #Convert all to floats
    Z_proj = float(Z_proj_passed)
    Z_targ = float(Z_targ_passed)
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    E_mean = float(E_mean_passed)   # Already in MeV
    if not E_excited_state_passed == None:
        # For excited state
        E_excited_state = float(E_excited_state_passed)  
        sommerfeld = 0.157484 * (Z_proj * Z_targ * math.sqrt(A_proj)) / math.sqrt(final_kinetic_energy_for_one_step_coulex(A_proj,A_targ,E_mean,E_excited_state))
    else:
        # Ground state
        sommerfeld = 0.157484 * (Z_proj * Z_targ * math.sqrt(A_proj)) / math.sqrt(E_mean)

    return sommerfeld

def coulomb_barrier(Z_proj,A_proj,Z_targ,A_targ):
    """Returns the Coulomb barrier energy (MeV)

    Syntax: coulomb_barrier(Z_proj,A_proj,Z_targ,A_targ)

    Takes integer arguments Z_proj,A_proj,Z_targ,A_targ

    """
    E_coul= 1.44 * ((float(A_proj) + float(A_targ))/float(A_targ)) * \
            (float(Z_proj) * float(Z_targ))/(1.25*(float(A_proj)**(1./3.) + float(A_targ)**(1./3.)))
    return E_coul

def safe_energy(Z_proj,A_proj,Z_targ,A_targ):
    """Returns the safe energy for back-scattering.

    See D. Cline... [reference to be included later]

    Syntax: safe_energy(Z_proj,A_proj,Z_targ,A_targ)

    """
    E_safe = 1.44 * ((float(A_proj) + float(A_targ))/float(A_targ)) * \
            (float(Z_proj) * float(Z_targ))/(1.25*(float(A_proj)**(1./3.) + float(A_targ)**(1./3.)) + 5.0)
    return E_safe



#  ###################################################################
#  # NEW ACCURATE INELASTIC SCATTERING AND CROSS SECTION FUNCTIONS.  #
#  ###################################################################
#  |                                                                 |
#  |                                                                 |
#  V                                                                 V

# Done
def inelastic_scattering_tau(A_proj_passed,A_targ_passed,E_proj_lab_passed,Q_value):

    """Returns the inelastic value of the scattering parameter tau.
        
        tau is defined in the Gosia manual, section 5.1.2

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!

    Tested against the Mathematic notebook, May 9th.

    """



    E_proj_lab = float(E_proj_lab_passed)
    A_proj     = float(A_proj_passed)
    A_targ     = float(A_targ_passed)
    dE         = float(abs(Q_value))

    tau = (A_proj / A_targ) / math.sqrt(1. - (dE / E_proj_lab) * (1. + (A_proj / A_targ)))

    return tau


# Done
def inelastic_scattering_tau_tilde(A_proj_passed,A_targ_passed,E_proj_lab_passed,Q_value):

    """Returns the inelastic value of the scattering parameter tau-tilde.
        
        tau-tilde is defined in the Gosia manual, section 5.1.2

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!


        Finished May 8th.
        Tested against the Mathematic notebook, May 9th.

    """

    E_proj_lab = float(E_proj_lab_passed)
    A_proj     = float(A_proj_passed)
    A_targ     = float(A_targ_passed)
    dE         = float(abs(Q_value))

    tau_tilde = 1. / math.sqrt(1. - (dE / E_proj_lab) * (1. + (A_proj / A_targ)))

    return tau_tilde


def inelastic_E_tilde(A_proj_passed,A_targ_passed,E_proj_lab_passed,Q_value):

    """Returns the inelastic value of the scattering parameter E-tilde.
        
        E-tilde is defined in the Gosia manual, section 5.1.2

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!


        Finished May 8th.
        Tested against the Mathematic notebook, May 9th.

    """

    E_proj_lab = float(E_proj_lab_passed)
    A_proj     = float(A_proj_passed)
    A_targ     = float(A_targ_passed)
    dE         = float(abs(Q_value))

    E_tilde = E_proj_lab - dE * (1.0 + (A_proj / A_targ))

    return E_tilde 


# Done
def lab_beam_energy_to_com(A_proj,A_targ,E_proj):
    """Returns the c.o.m. beam energy for a lab energy of E_proj.

    Syntax: (A_proj,A_targ,E_proj,Q_value)

    E_proj is the laboratory beam energy in MeV.

        Finished May 8th--no changes, already tested.

    """


    E_com = float(E_proj) * float(A_targ) / (float(A_proj) + float(A_targ))

    return E_com

# Done
def com_beam_energy_to_lab(A_proj,A_targ,E_com):
    """Returns the lab beam energy for a c.o.m. energy of E_com.

    Syntax: (A_proj,A_targ,E_com)

    E_com is the center-of-mass beam energy in MeV.

        Finished May 8th--no changes, already tested.

    """

    E_lab = float(E_com) * (float(A_proj) + float(A_targ)) / float(A_targ)

    return E_lab

def inelastic_lab_scattering_angle_to_lab_scattering_energy(A_proj_passed,A_targ_passed,theta_lab_passed,forward,E_proj_passed,Q_value):
    """Returns the final projectile scattering energy in the lab from the lab scattering (proj) angle

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!

    If forward=False, then the the backward center-of-mass solution is returned
    for inverse kinematics.  Angles are given and returned in degrees.  

    If the requested angle is invalid, then an exception will be raised.  This
    must be trapped by the calling method.

    Tested May 9 2012 against Gosia manual examples.

    """

    # Convert all to floats
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    theta_lab = float(theta_lab_passed)
    E_proj = float(E_proj_passed)

    tau = inelastic_scattering_tau(A_proj,A_targ,E_proj,Q_value)
    # Get the c.o.m. projectile angle for the energy calculation eq. 5.17 in the Gosia manual.
    com_scattering_angle = inelastic_lab_scattering_angle_to_com_scattering_angle(A_proj,A_targ,theta_lab,forward,E_proj,Q_value)
    E_tilde = inelastic_E_tilde(A_proj,A_targ,E_proj,Q_value)

    E_scattering_lab = ( A_targ / (A_proj + A_targ))**2 * (1.0 + tau**2 + 2.0 * tau * math.cos(math.radians(com_scattering_angle))) * E_tilde

    return E_scattering_lab 

def inelastic_lab_recoil_angle_to_lab_recoil_energy(A_proj_passed,A_targ_passed,theta_lab_passed,forward,E_proj_passed,Q_value):
    """Returns the final target recoil energy in the lab from the lab recoil angle

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!

    If forward=False, then the the backward center-of-mass solution is returned
    for inverse kinematics.  Angles are given and returned in degrees.  

    If the requested angle is invalid, then an exception will be raised.  This
    must be trapped by the calling method.

    Tested May 9 2012 against Gosia manual examples.

    """

    # Convert all to floats
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    theta_lab = float(theta_lab_passed)
    E_proj = float(E_proj_passed)

    tau_tilde = inelastic_scattering_tau_tilde(A_proj,A_targ,E_proj,Q_value)
    # Get the c.o.m. recoil angle for the energy calculation eq. 5.16 in the Gosia manual.
    com_recoil_angle = inelastic_lab_recoil_angle_to_com_recoil_angle(A_proj,A_targ,theta_lab,forward,E_proj,Q_value)
    E_tilde = inelastic_E_tilde(A_proj,A_targ,E_proj,Q_value)

    E_recoil_lab = ((A_proj * A_targ) / (A_proj + A_targ)**2) * (1.0 + tau_tilde**2 + 2.0 * tau_tilde * math.cos(math.radians(com_recoil_angle))) * E_tilde

    return E_recoil_lab 


# Done
def inelastic_com_scattering_angle_to_com_recoil_angle(theta_passed):
    """This is universal for elastic and inelastic.

    Tested May 9 2012.

    """


    theta_scattering_com = float(theta_passed)
    theta_scattering_com_rad = math.radians(theta_scattering_com)

    com_recoil_angle = math.degrees(math.pi - theta_scattering_com_rad)

    return com_recoil_angle

# Done
def inelastic_com_recoil_angle_to_com_scattering_angle(theta_passed):
    """This is universal for elastic and inelastic.

    Tested May 9 2012.

    """



    theta_recoil_com = float(theta_passed)
    theta_recoil_com_rad = math.radians(theta_recoil_com)

    com_scattering_angle = math.degrees(math.pi - theta_recoil_com_rad)

    return com_scattering_angle

# Done
def inelastic_lab_scattering_angle_to_lab_recoil_angle(A_proj_passed,A_targ_passed,theta_lab_passed,forward,E_proj_passed,Q_value):
    """

    Angles are given and returned in degrees.  

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!


    If the requested angle is invalid, then an exception will be raised.  This
    must be trapped by the calling method.

    Tested May 9 2012 against Mathematica notebook and Gosia manual examples.

    """




    # Convert all to floats
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    E_proj = float(E_proj_passed)
    dE     = float(abs(Q_value))
    theta_scat_lab = float(theta_lab_passed)  # This is the recoil angle in the lab frame.

    theta_scat_com = inelastic_lab_scattering_angle_to_com_scattering_angle(A_proj,A_targ,theta_scat_lab,forward,E_proj,Q_value)
    theta_rec_com  = inelastic_com_scattering_angle_to_com_recoil_angle(theta_scat_com)
    theta_rec_lab  = inelastic_com_recoil_angle_to_lab_recoil_angle(A_proj,A_targ,theta_rec_com,E_proj,Q_value)

    return theta_rec_lab


# Done
def inelastic_com_recoil_angle_to_lab_recoil_angle(A_proj_passed,A_targ_passed,theta_com_passed,E_proj_passed,Q_value):
    """


    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!

    Tested May 9 2012 against Gosia manual examples.

    """




    # Convert all to floats
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    E_proj = float(E_proj_passed)
    theta_com_rec = float(theta_com_passed)  # This is the recoil angle in the com frame.
    theta_com_rec_rad = math.radians(theta_com_rec)

    tau_tilde = inelastic_scattering_tau_tilde(A_proj,A_targ,E_proj,Q_value)

    theta_recoil_lab = math.degrees(math.atan(math.sin(theta_com_rec_rad) / (math.cos(theta_com_rec_rad) + tau_tilde)))

    return theta_recoil_lab

# Done
def inelastic_com_scattering_angle_to_lab_scattering_angle(A_proj_passed,A_targ_passed,theta_com_passed,E_proj_passed,Q_value):
    """

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!


    Tested May 9 2012 against Gosia manual examples.

    """




    # Convert all to floats
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    E_proj = float(E_proj_passed)
    theta_com_scat = float(theta_com_passed)  # This is the scatoil angle in the com frame.
    theta_com_scat_rad = math.radians(theta_com_scat)

    tau       = inelastic_scattering_tau(A_proj,A_targ,E_proj,Q_value)

    # Need to adjust for the domain of the atan function.
    theta_scat_lab = math.degrees(math.atan(math.sin(theta_com_scat_rad) / (math.cos(theta_com_scat_rad) + tau)))
    if theta_scat_lab < 0:
        theta_scat_lab = 180. + theta_scat_lab

    return theta_scat_lab


def inelastic_lab_recoil_angle_to_lab_scattering_angle(A_proj_passed,A_targ_passed,theta_lab_passed,forward,E_proj_passed,Q_value):
    """Returns the projectile scattering angle in the lab frame given the recoil angle

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!


    Syntax: 

    theta_lab is the recoil (target) angle in degrees in the laboratory frame.

    Angles are given and returned in degrees.  

    If the requested angle is invalid, then an exception will be raised.  This
    must be trapped by the calling method.

    Tested May 9 2012 against Gosia manual examples.

    """


    # Convert all to floats
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    E_proj = float(E_proj_passed)
    theta_recoil_lab = float(theta_lab_passed)  # This is the recoil angle in the lab frame.


    theta_rec_com = inelastic_lab_recoil_angle_to_com_recoil_angle(A_proj,A_targ,theta_recoil_lab,forward,E_proj,Q_value)
    theta_proj_com  = inelastic_com_recoil_angle_to_com_scattering_angle(theta_rec_com)
    theta_proj_lab  = inelastic_com_scattering_angle_to_lab_scattering_angle(A_proj,A_targ,theta_proj_com,E_proj,Q_value)

    return theta_proj_lab

# Done
def inelastic_lab_recoil_angle_to_com_recoil_angle(A_proj_passed,A_targ_passed,theta_lab_passed,forward,E_proj_passed,Q_value):
    """Returns the recoil angle in the c.o.m. frame

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!



    If forward=False, then the the backward center-of-mass solution is returned
    for inverse kinematics.  Angles are given and returned in degrees.  

    If the requested angle is invalid, then an exception will be raised.  This
    must be trapped by the calling method.

    Tested May 9 2012 against Gosia manual examples.

    """



    # Convert all to floats
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    theta_lab = float(theta_lab_passed)
    E_proj = float(E_proj_passed)

    tau_tilde = inelastic_scattering_tau_tilde(A_proj,A_targ,E_proj,Q_value)
    dtheta = math.degrees(math.asin(tau_tilde * math.sin(math.radians(theta_lab))))

    if forward:
        theta_com = 180. - abs(theta_lab - dtheta)
    else:
        theta_com = theta_lab + dtheta

    return theta_com


# Done
def inelastic_lab_scattering_angle_to_com_scattering_angle(A_proj_passed,A_targ_passed,theta_lab_passed,forward,E_proj_passed,Q_value):
    """Returns the projectile scattering angle in the c.o.m. frame

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!

    Note also:
        For normal kinematics, the inelastic Q>0 second solution is ignored (forward).

    Syntax: (A_proj,A_targ,theta_lab,forward,E_proj_passed,Q_value)

    theta_lab is the laboratory-frame scattering angle in degrees.

    If forward=False, then the the backward center-of-mass solution is returned
    for inverse kinematics.  Angles are given and returned in degrees.  

    If the requested angle is invalid, then an exception will be raised.  This
    must be trapped by the calling method.

        Finished May 8th.
    Tested May 9 2012 against Gosia manual examples.

    """


    # Is this a normal or inverse kinematics case?
    if A_proj_passed < A_targ_passed:
        # This is normal kinematics
        normal_kinematics = True
    else:
        # Inverse kinematics
        normal_kinematics  = False

    # Convert all to floats
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    theta_lab = float(theta_lab_passed)
    E_proj = float(E_proj_passed)

    tau = inelastic_scattering_tau(A_proj,A_targ,E_proj,Q_value)

    dtheta = math.degrees(math.asin(tau * math.sin(math.radians(theta_lab))))

    if forward or normal_kinematics:
        theta_com = theta_lab + dtheta
    else:
        theta_com = 180. - abs(theta_lab - dtheta)

    return theta_com


# Done
def inelastic_maximum_scattering_angle(A_proj_passed,A_targ_passed,E_proj_passed,Q_value):
    """Returns the maximum projectile scattering angle in the lab frame.

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!


    for a Q-value of zero.

    Syntax (A_proj,A_targ,Q_value)

    Tested May 9 2012 against Gosia manual examples.

    """




    # Convert all to floats
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    E_proj = float(E_proj_passed)

    tau = inelastic_scattering_tau(A_proj,A_targ,E_proj,Q_value)

    if A_proj < A_targ:
        # This was an unnecessary call for normal kinematics.
        return 180.0
    else:
        return math.degrees(math.asin(1. / tau))


# Done
def inelastic_maximum_recoil_angle(A_proj_passed,A_targ_passed,E_proj_passed,Q_value):
    """Returns the maximum projectile scattering angle in the lab frame.

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!


    for a Q-value of zero.

    Syntax (A_proj,A_targ,Q_value)

    Tested May 9 2012 against Gosia manual examples.

    """




    # Convert all to floats
    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    E_proj = float(E_proj_passed)

    tau_tilde = inelastic_scattering_tau_tilde(A_proj,A_targ,E_proj,Q_value)

    return math.degrees(math.asin(1. / tau_tilde))


# Done
def inelastic_differential_scattering_cross_section(Z_proj_passed,A_proj_passed,Z_targ_passed,A_targ_passed,theta_lab_passed,forward,E_proj_passed,Q_value):
    """Returns dsigma/dOmega in the lab frame (mb/sr) for a projectile scattering angle.

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!


    There is no default kinematic solution.
    
    Syntax: (Z_proj,A_proj,Z_targ,A_targ,E_proj,theta_lab,forward,Q_value)

    forward = True indicates the forward-c.o.m. solution for inverse kinematics;
    forward = False indicates the backward-c.o.m. solution.

    theta_lab is the lab frame scattering angle given in degrees.
    Energy E_proj is in MeV.

    Tested May 9 2012 against Mathematica notebooks and elastic code limits.

    """




    # Convert all to floats
    Z_proj = float(Z_proj_passed)
    A_proj = float(A_proj_passed)
    Z_targ = float(Z_targ_passed)
    A_targ = float(A_targ_passed)
    E_proj = float(E_proj_passed)
    theta_lab = float(theta_lab_passed)

    # Get the scattering angle in the c.o.m. frame.
    theta_com     = inelastic_lab_scattering_angle_to_com_scattering_angle(A_proj,A_targ,theta_lab,forward,E_proj,Q_value)

    # Call the com frame q-dependent cross section first, then apply the transformation.
    com_cross_section = inelastic_differential_scattering_cross_section_com(Z_proj,A_proj,Z_targ,A_targ,theta_com,E_proj,Q_value)

    theta_com_rad = math.radians(theta_com)
    theta_lab_rad = math.radians(theta_lab)

    # The transformation factor to the lab frame is
    numerator    = math.sin(theta_com_rad)**2 
    #              ----------------------------------------------------------------------------------------------------------------------------
    denominator  = math.sin(theta_lab_rad)**2 * abs(math.cos(theta_com_rad - theta_lab_rad))

    differential_cross_section_lab = com_cross_section * numerator / denominator

    return differential_cross_section_lab

# Done
def inelastic_symmetrized_energy(A_proj_passed,A_targ_passed,E_proj_passed,Q_value):
    """ Calculates the symmetrized center-of-mass energy.  See A&W appendix x.2,

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!


    equation 21, and absorb the 1+Ap/At factors.
    Convert all to floats

    Tested May 9 2012 against Mathematica notebooks and elastic code limits.

    """



    A_proj = float(A_proj_passed)
    A_targ = float(A_targ_passed)
    E_proj = float(E_proj_passed)
    E_com  = lab_beam_energy_to_com(A_proj,A_targ,E_proj)
    dE     = float(abs(Q_value))

    # See A&W app. x.2, eq. 21 and preceding definitions.
    Ecm_sym = math.sqrt(E_com**(3./2.) * math.sqrt(E_com - dE))

    return Ecm_sym

# Done
def inelastic_differential_scattering_cross_section_com(Z_proj_passed,A_proj_passed,Z_targ_passed,A_targ_passed,theta_com_passed,E_proj_passed,Q_value):
    """Returns dsigma/dOmega in the c.o.m. frame (mb/sr).

    NOTE:
        E_projectile is in MeV.
        Q_value is in MeV also!


    Syntax: (Z_proj,A_proj,Z_targ,A_targ,E_proj,theta_com,Q_value)

    theta_com is the c.o.m. frame scattering angle given in degrees.
    Energy is in MeV in the LAB frame (the initial projectile energy).

    Tested May 9 2012 against Mathematica notebooks and elastic code limits.

    """



    # Convert all to floats
    Z_proj = float(Z_proj_passed)
    A_proj = float(A_proj_passed)
    Z_targ = float(Z_targ_passed)
    A_targ = float(A_targ_passed)
    E_proj = float(E_proj_passed)
    dE     = float(abs(Q_value))
    theta_com = float(theta_com_passed)
    theta_com_rad = math.radians(theta_com)

    E_sym = inelastic_symmetrized_energy(A_proj_passed,A_targ_passed,E_proj_passed,Q_value)
    # The initial lab and com energies are related by Ep/(1+Ap/At) = E_com.

    numerator   = RUTHERFORD_CONSTANT * Z_proj**2 * Z_targ**2 
    #             -------------------------------------------
    denominator = E_sym**2 * math.sin(theta_com_rad / 2.)**4

    # The differential rutherford cross section in the c.o.m. frame.
    com_cross_section = numerator / denominator

    return com_cross_section

#  ^                                                               ^
#  |                                                               |
#  |                                                               |
#  ###################################################################
#  # end ACCURATE INELASTIC SCATTERING AND CROSS SECTION FUNCTIONS.  #
#  ###################################################################


def gaussian_smooth(equally_spaced_points,strippedXs=False,degree=5):  
    # This Gaussian smoothing routine is from 
    # http://www.swharden.com/blog/2008-11-17-linear-data-smoothing-in-python/
    # by Scott Harden, U. Florida

    equally_spaced_points = [equally_spaced_points[0]]*(degree-1) + equally_spaced_points + [equally_spaced_points[-1]]*degree
    window=degree*2-1  
    weight=numpy.array([1.0]*window)  
    weightGauss=[]  
    for i in range(window):  
        i=i-degree+1  
        frac=i/float(window)  
        gauss=1/(numpy.exp((4*(frac))**2))  
        weightGauss.append(gauss)  
    weight=numpy.array(weightGauss)*weight  
    smoothed=[0.0]*(len(equally_spaced_points)-window)  
    for i in range(len(smoothed)):  
        smoothed[i]=sum(numpy.array(equally_spaced_points[i:i+window])*weight)/sum(weight)  
    return smoothed  

#######################################################################
#  End of math functions.                                             #
#######################################################################


#  ###################################################################
#  #   USER ACCESSORS FOR MATH FUNCTIONS VIA THE INTERPRETER         #
#  ###################################################################
#  |                                                                 |
#  |                                                                 |
#  V                                                                 V

def user_sd():
    """User accessor (prompts) for the stddev function

    """
    
    list_string = raw_input("Enter a list of numbers, comma-delimited 1.1,2.2,3.3...: ")
    the_list = list(eval("[" + list_string + "]"))
    sd = stddev(the_list)
    print "Rachel> stddev([" + str(the_list[0]) + ", " + str(the_list[1]) + "...]) = " + str(sd)
    return sd

def user_wu():
    """User accessor (prompts) for the function calc_wu

    """

    A = int(raw_input("Mass number A:" ))
    multipole = raw_input("Multipole, e.g. E2, M2...: ")
    wu = calc_wu(A,multipole)
    print "Rachel> calc_wu(" + str(A) + ", \"" + multipole + "\") = ",
    return wu

def user_cgc():
    """User accessor (prompts) for the function cgc

    """

    args = raw_input("Enter j1,m1,j2,m2,j3,m3 (comma-delimited) as in <j1 m1 j2 m2 | j3 m3>: ")
    arg = eval(args)
    coeff = cgc(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5])
    print "Rachel> cgc(j1,m1,j2,m2,j3,m3) = ",coeff
    return coeff


def user_somm():
    """User accessor (prompts) for the function sommerfeld_parameter()

    """

    Zp = int(raw_input("Projectile Z: "))
    Ap = int(raw_input("Projectile A: "))
    Zt = int(raw_input("Target Z: "))
    At = int(raw_input("Target A: "))
    E_beam = float(raw_input("Beam energy [MeV]: "))
    E_exc  = float(raw_input("Excitation energy [keV]: "))
    print "Excitation energy taken as " + str(round(E_exc * 1000.,1)) + " KEV."

    s = sommerfeld_parameter(Zp,Ap,Zt,At,E_beam,E_exc)
    print "Rachel> sommerfeld_parameter(Zp,Ap,Zt,At,E_beam,E_exc) = ",s
    return s


def user_barrier():
    """User accessor (prompts) for the function coulomb_barrier

    """

    Zp = int(raw_input("Projectile Z: "))
    Ap = int(raw_input("Projectile A: "))
    Zt = int(raw_input("Target Z: "))
    At = int(raw_input("Target A: "))

    barrier = coulomb_barrier(Zp,Ap,Zt,At)
    print "Rachel> coulomb_barrier(Zp,Ap,Zt,At) = ",barrier
    return barrier


def user_safe():
    """User accessor (prompts) for the function safe_energy

    """

    Zp = int(raw_input("Projectile Z: "))
    Ap = int(raw_input("Projectile A: "))
    Zt = int(raw_input("Target Z: "))
    At = int(raw_input("Target A: "))

    Esafe = safe_energy(Zp,Ap,Zt,At)
    print "Rachel> safe_energy(Zp,Ap,Zt,At) = ",Esafe
    return Esafe

def user_scatmax():
    """User accessor (prompts) for the function inelastic_maximum_scattering_angle

    """

    Ap = int(raw_input("Projectile A: "))
    At = int(raw_input("Target A: "))
    E_beam = float(raw_input("Beam energy [MeV]: "))
    E_exc  = float(raw_input("Excitation energy [keV]: ")) / 1000.  # Converted to MeV for the cross section function
    print "Excitation energy taken as " + str(round(E_exc * 1000.,1)) + " KEV."

    scatmax = inelastic_maximum_scattering_angle(Ap,At,E_beam,E_exc)

    print "Rachel> inelastic_maximum_scattering_angle(A_proj,A_targ,E_proj,Q_value) = ",

    return scatmax

def user_recmax():
    """User accessor (prompts) for the function inelastic_maximum_recoil_angle

    """

    Ap = int(raw_input("Projectile A: "))
    At = int(raw_input("Target A: "))
    E_beam = float(raw_input("Beam energy [MeV]: "))
    E_exc  = float(raw_input("Excitation energy [keV]: ")) / 1000.  # Converted to MeV for the cross section function
    print "Excitation energy taken as " + str(round(E_exc * 1000.,1)) + " KEV."

    recmax = inelastic_maximum_recoil_angle(Ap,At,E_beam,E_exc)

    print "Rachel> inelastic_maximum_recoil_angle(Ap,At,E_beam,E_exc) = ",recmax

    return recmax 


def user_ruth():
    """User accessor (prompts) for the function inelastic_differential_scattering_cross_section

    """

    Zp = int(raw_input("Projectile Z: "))
    Ap = int(raw_input("Projectile A: "))
    Zt = int(raw_input("Target Z: "))
    At = int(raw_input("Target A: "))
    E_beam = float(raw_input("Beam energy [MeV]: "))
    E_exc  = float(raw_input("Excitation energy [keV]: ")) / 1000.  # Converted to MeV for the cross section function
    print "Excitation energy taken as " + str(round(E_exc * 1000.,1)) + " KEV."
    theta_lab = float(raw_input("Lab-frame projectile scattering angle in degrees: "))
    if Ap >= At:
        forward_string = None
        while not forward_string in ["f","b"]:
            try:
                forward_string = raw_input("Enter \"f\"/\"b\" for the forward- or backward-c.o.m. solution: ").lower()[0]
            except:
                # User hit enter.
                pass
        if forward_string == "f":
            forward = True
        else:
            forward = False
    else:
        forward = True  # Ignored for normal kinematics

    cs = inelastic_differential_scattering_cross_section(Zp,Ap,Zt,At,theta_lab,forward,E_beam,E_exc)
    print "Rachel> inelastic_differential_scattering_cross_section(Zp,Ap,Zt,At,theta_lab,forward[True/False],E_beam,E_exc) = ",cs
    return cs

def user_norm():
    """User accessor (prompts) to calculate the appropriate YNRM normalization constant for OP,YIEL

    """

    Zp = int(raw_input("Projectile Z: "))
    Ap = int(raw_input("Projectile A: "))
    Zt = int(raw_input("Target Z: "))
    At = int(raw_input("Target A: "))
    E_beam = float(raw_input("Beam energy [MeV]: "))
    E_exc  = float(raw_input("Excitation energy [keV]: ")) / 1000.  # Converted to MeV for the cross section function
    print "Excitation energy taken as " + str(round(E_exc * 1000.,1)) + " KEV."
    theta_lab = float(raw_input("Lab-frame projectile scattering angle in degrees: "))
    if Ap >= At:
        forward_string = None
        while not forward_string in ["f","b"]:
            try:
                forward_string = raw_input("Enter \"f\"/\"b\" for the forward- or backward-c.o.m. solution: ").lower()[0]
            except:
                # User hit enter.
                pass
        if forward_string == "f":
            forward = True
        else:
            forward = False
    else:
        forward = True  # Ignored for normal kinematics

    # Get the sin(theta) factor
    sine_factor = math.sin(math.radians(theta_lab))

    cs = inelastic_differential_scattering_cross_section(Zp,Ap,Zt,At,theta_lab,forward,E_beam,E_exc)

    normalization_constant = cs * sine_factor

    print "Rachel> inelastic_differential_scattering_cross_section(Zp,Ap,Zt,At,theta_lab,forward[True/False],E_beam,E_exc) = ",cs
    print "Rachel> math.sin(math.radians(theta_lab) = ",sine_factor

    return normalization_constant 



def user_ruth_com():
    """User accessor (prompts) for the function inelastic_differential_scattering_cross_section_com

    """

    Zp = int(raw_input("Projectile Z: "))
    Ap = int(raw_input("Projectile A: "))
    Zt = int(raw_input("Target Z: "))
    At = int(raw_input("Target A: "))
    E_beam = float(raw_input("Beam energy [MeV]: "))
    E_exc  = float(raw_input("Excitation energy [keV]: ")) / 1000.  # Converted to MeV for the cross section function
    print "Excitation energy taken as " + str(round(E_exc * 1000.,1)) + " KEV."
    theta_com = float(raw_input("Center-of-mass frame projectile scattering angle in degrees: "))

    cs = inelastic_differential_scattering_cross_section_com(Zp,Ap,Zt,At,theta_com,E_beam,E_exc)

    print "Rachel> inelastic_differential_scattering_cross_section_com(Zp,Ap,Zt,At,theta_com,E_beam,E_exc) = ", cs

    return cs

def user_com_energy():
    """User accessor (prompts) for the functionlab_beam_energy_to_com

    """

    Ap = int(raw_input("Projectile A: "))
    At = int(raw_input("Target A: "))
    E_beam = float(raw_input("Beam energy [MeV]: "))
    ecom = lab_beam_energy_to_com(Ap,At,E_beam)
    print "Rachel> lab_beam_energy_to_com(Ap,At,E_beam) = ", ecom
    return ecom


def user_lab_energy():
    """User accessor (prompts) for the function com_beam_energy_to_lab

    """

    Ap = int(raw_input("Projectile A: "))
    At = int(raw_input("Target A: "))
    E_com = float(raw_input("Center-of-mass energy [MeV]: "))
    elab = com_beam_energy_to_lab(Ap,At,E_com)
    print "Rachel> com_beam_energy_to_lab(Ap,At,E_com) = ", elab
    return elab


def user_rtos():
    """User accessor (prompts) for the function inelastic_lab_recoil_angle_to_lab_scattering_angle

    """
    Ap = int(raw_input("Projectile A: "))
    At = int(raw_input("Target A: "))
    E_beam = float(raw_input("Beam energy [MeV]: "))
    E_exc  = float(raw_input("Excitation energy [keV]: ")) / 1000.  # Converted to MeV for the cross section function
    print "Excitation energy taken as " + str(round(E_exc * 1000.,1)) + " KEV."
    theta_rec_lab = float(raw_input("Lab-frame target recoil angle in degrees: "))
    if E_exc <> 0.:
        block_print_with_line_breaks("For a non-zero Q-value there are TWO solutions (two lab scattering angles for any recoil angle).  See the Gosia manual section 5.1.  To obtain the low-recoil-energy solution for an inelastic collision, select \"f\".  The usual backward-lab-scattering solution is the default.  If you don't understand this, then the default will almost certainly give you the quantity you want.")
        forward_string = None
        while not forward_string in ["f","","b"]:
            try:
                forward_string = raw_input("Enter \"f\"/\"b\" for the forward- or backward-LAB SCATTERING solution [B/f]: ").lower()[0]
            except:
                # User hit enter for default.
                forward_string = "b"
        if forward_string == "f":
            forward = True
        else:
            forward = False
    theta_scat_lab = inelastic_lab_recoil_angle_to_lab_scattering_angle(Ap,At,theta_rec_lab,forward,E_beam,E_exc)
    print "Rachel> inelastic_lab_recoil_angle_to_lab_scattering_angle(Ap,At,theta_rec_lab,forward[True/False],E_beam,E_exc) = ",theta_scat_lab
    return theta_scat_lab 

    
def user_stoc():
    """User accessor (prompts) for the function inelastic_lab_scattering_angle_to_com_scattering_angle

    """
    Ap = int(raw_input("Projectile A: "))
    At = int(raw_input("Target A: "))
    E_beam = float(raw_input("Beam energy [MeV]: "))
    E_exc  = float(raw_input("Excitation energy [keV]: ")) / 1000.  # Converted to MeV for the cross section function
    print "Excitation energy taken as " + str(round(E_exc * 1000.,1)) + " KEV."
    theta_scat_lab = float(raw_input("Lab-frame projectile scattering angle in degrees: "))
    forward_string = None
    while not forward_string in ["f","b"]:
        try:
            forward_string = raw_input("Enter \"f\"/\"b\" for the forward or backward center-of-mass solution [b/f]: ").lower()[0]
        except:
            # User hit enter.  No default.
            pass 
    if forward_string == "f":
        forward = True
    else:
        forward = False

    com_angle = inelastic_lab_scattering_angle_to_com_scattering_angle(Ap,At,theta_scat_lab,forward,E_beam,E_exc)
    print "Rachel> inelastic_lab_scattering_angle_to_com_scattering_angle(Ap,At,theta_scat_lab,forward[True/False],E_beam,E_exc) = ",   com_angle 
    return com_angle

def user_svsr():
    """User accessor (prompts) to plot beam vs. target angle in the lab frame

    """

    Ap = int(raw_input("Projectile A: "))
    At = int(raw_input("Target A: "))
    E_beam = float(raw_input("Beam energy [MeV]: "))
    E_exc  = float(raw_input("Excitation energy [keV]: ")) / 1000.  # Converted to MeV for the cross section function
    print "Excitation energy taken as " + str(round(E_exc * 1000.,1)) + " KEV."

    # For Q<>0, there is a maximum recoil angle.
    max_rec  = inelastic_maximum_recoil_angle(Ap,At,E_beam,E_exc)

    # For inverse kinematics, there is a maximum projectile scattering angle, which is less than 180 deg. for Q<>0.
    max_scat = inelastic_maximum_scattering_angle(Ap,At,E_beam,E_exc)

    if E_exc <> 0.:
        block_print_with_line_breaks("For a non-zero Q-value there are TWO solutions (two lab scattering angles for any recoil angle).  See the Gosia manual section 5.1.") 

    # The lists of x,y will be filled in the order that will connect the
    # two solutions directly at the max. recoil angle.
    plot_list = [[],[]]  # [[x,x,x,...],[y,y,y,....]]

    # Get the bottom half of the scat vs. rec plot.
    forward = True
    full_list = list(numpy.linspace(0.0, max_rec * 0.999, 1000))
    lo_list   = list(numpy.linspace(max_rec * 0.999, max_rec * 0.9999, 100))
    full_list.extend(lo_list)
    for theta_rec_lab in full_list:
        theta_scat_lab = inelastic_lab_recoil_angle_to_lab_scattering_angle(Ap,At,theta_rec_lab,forward,E_beam,E_exc)
        point = [theta_rec_lab,theta_scat_lab]
        plot_list[0].append(theta_rec_lab)
        plot_list[1].append(theta_scat_lab)

    # Get the top half of the scat vs. rec plot.
    forward = False
    full_list = list(numpy.linspace(max_rec * 0.9999, max_rec * 0.999, 100))
    lo_list = list(numpy.linspace(max_rec * 0.999, 0.0, 1000))
    full_list.extend(lo_list)
    for theta_rec_lab in full_list:
        theta_scat_lab = inelastic_lab_recoil_angle_to_lab_scattering_angle(Ap,At,theta_rec_lab,forward,E_beam,E_exc)
        plot_list[0].append(theta_rec_lab)
        plot_list[1].append(theta_scat_lab)

    block_print_with_line_breaks("The plot shows lab-frame (projectile) scattering angle (y) vs. lab-frame (target) recoil angle in degrees.  The maximum scattering and recoil angles, respectively, are ")

    
    print str(round(max_scat,3)) + " and  " + str(round( max_rec,3)) + " degrees.\n"

    # Call the quick-plot function for gnuplot.
    quick_plot_n_sets({"proj vs. rec":plot_list})

    return 0


def user_lvsc():
    """User accessor (prompts) to plot lab-frame vs. c.o.m. kinematics

    """

    Ap = int(raw_input("Projectile A: "))
    At = int(raw_input("Target A: "))
    E_beam = float(raw_input("Beam energy [MeV]: "))
    E_exc  = float(raw_input("Excitation energy [keV]: ")) / 1000.  # Converted to MeV for the cross section function
    print "Excitation energy taken as " + str(round(E_exc * 1000.,1)) + " KEV."

    # For Q<>0, there is a maximum recoil angle.
    max_rec  = inelastic_maximum_recoil_angle(Ap,At,E_beam,E_exc)

    # For inverse kinematics, there is a maximum projectile scattering angle, which is less than 180 deg. for Q<>0.
    max_scat = inelastic_maximum_scattering_angle(Ap,At,E_beam,E_exc)

    # The lists of x,y will be filled in the order that will connect the
    # two solutions directly at the max. recoil angle.
    plot_dict = {"proj lab vs proj com":[[],[]],"targ lab vs proj com":[[],[]]}  # [[x,x,x,...],[y,y,y,....]] for each trace.

    full_list = list(numpy.linspace(0.0, 180.,1000))
    for theta_com_scat in full_list:
        # projectile lab scat. angle vs. proj com angle
        theta_scat_lab = inelastic_com_scattering_angle_to_lab_scattering_angle(Ap,At,theta_com_scat,E_beam,E_exc)
        plot_dict["proj lab vs proj com"][0].append(theta_com_scat)
        plot_dict["proj lab vs proj com"][1].append(theta_scat_lab)
        # target lab scat. angle vs. PROJ com angle
        theta_rec_com = inelastic_com_scattering_angle_to_com_recoil_angle(theta_com_scat)
        theta_rec_lab = inelastic_com_recoil_angle_to_lab_recoil_angle(Ap,At,theta_rec_com,E_beam,E_exc)
        plot_dict["targ lab vs proj com"][0].append(theta_com_scat)
        plot_dict["targ lab vs proj com"][1].append(theta_rec_lab)


    block_print_with_line_breaks("The plot shows lab-frame projectile scattering angle and target recoil angles (y) vs. the c.o.m. projectile angle in degrees.  The maximum scattering and recoil angles, respectively, are ")
    
    print str(round(max_scat,3)) + " and  " + str(round( max_rec,3)) + " degrees.\n"

    # Call the quick-plot function for gnuplot.
    quick_plot_n_sets(plot_dict)

    return 0


def user_evsl():
    """User accessor (prompts) to plot lab-frame energy vs. lab-frame angle

    """

    Ap = int(raw_input("Projectile A: "))
    At = int(raw_input("Target A: "))
    E_proj = float(raw_input("Beam energy [MeV]: "))
    E_exc  = float(raw_input("Excitation energy [keV]: ")) / 1000.  # Converted to MeV for the cross section function
    print "Excitation energy taken as " + str(round(E_exc * 1000.,1)) + " KEV."

    # For Q<>0, there is a maximum recoil angle.
    max_rec  = inelastic_maximum_recoil_angle(Ap,At,E_proj,E_exc)

    # For inverse kinematics, there is a maximum projectile scattering angle, which is less than 180 deg. for Q<>0.
    max_scat = inelastic_maximum_scattering_angle(Ap,At,E_proj,E_exc)

    # The lists of x,y will be filled in the order that will connect the
    # two solutions directly at the max. recoil angle.
    plot_dict = {"proj energy vs lab angle":[[],[]],"targ lab energy vs lab angle":[[],[]]}  # [[x,x,x,...],[y,y,y,....]] for each trace.

    # We have to do the recoil and projectile separately, because we will plot both projectile solutions.
    # (The very low-energy solutions that exist only for Q<>0 will not be plotted.)
    full_list = list(numpy.linspace(0.0, 180.,1000))
    # Reverse the list for this solution so that the traces connect on the plot
    reversed_list = copy.deepcopy(full_list)
    reversed_list.reverse()
    # Put the first and second solutions in the right order for the plot traces for normal or inverse kinematics
    if Ap>At:
        # Normal kinematics
        list_a_targ = full_list
        list_b_targ = reversed_list
        list_a_scat = full_list
        list_b_scat = reversed_list
    else:
        # Inverse kinematics
        list_a_targ = full_list
        list_b_targ = reversed_list
        list_a_scat = full_list
        list_b_scat = reversed_list

    forward = True
    for theta_lab in list_a_targ:
        if theta_lab < max_rec:
            # In range for recoil angle.
            E_rec  = inelastic_lab_recoil_angle_to_lab_recoil_energy(Ap,At,theta_lab,forward,E_proj,E_exc)
            plot_dict["targ lab energy vs lab angle"][0].append(theta_lab)
            plot_dict["targ lab energy vs lab angle"][1].append(E_rec)

    forward = False
    for theta_lab in list_b_targ:
        if theta_lab < max_rec:
            # In range for recoil angle.
            E_rec  = inelastic_lab_recoil_angle_to_lab_recoil_energy(Ap,At,theta_lab,forward,E_proj,E_exc)
            plot_dict["targ lab energy vs lab angle"][0].append(theta_lab)
            plot_dict["targ lab energy vs lab angle"][1].append(E_rec)

    forward = True
    for theta_lab in list_a_scat:
        if theta_lab < max_scat:
            # In range for scat angle.
            # Need to do both solutions for projectile.
            E_scat = inelastic_lab_scattering_angle_to_lab_scattering_energy(Ap,At,theta_lab,forward,E_proj,E_exc)
            plot_dict["proj energy vs lab angle"][0].append(theta_lab)
            plot_dict["proj energy vs lab angle"][1].append(E_scat)

    # Only do the backward com solution if it is really for inverse kinematics.
    # I don't think the functions are set up to find the solution that exists
    # only for Q<>0.  This one is unimportant anyway.
    if Ap >= At:
        forward = False
        for theta_lab in list_b_scat:
            if theta_lab < max_scat:
                # In range for scat angle.
                # Need to do both solutions for projectile.
                E_scat = inelastic_lab_scattering_angle_to_lab_scattering_energy(Ap,At,theta_lab,forward,E_proj,E_exc)
                plot_dict["proj energy vs lab angle"][0].append(theta_lab)
                plot_dict["proj energy vs lab angle"][1].append(E_scat)


    block_print_with_line_breaks("The plot shows lab-frame final energies (y) vs. the lab-frame projectile/recoil angle in degrees.  The maximum scattering and recoil angles, respectively, are ")
    
    print str(round(max_scat,3)) + " and  " + str(round( max_rec,3)) + " degrees.\n"

    # Call the quick-plot function for gnuplot.
    quick_plot_n_sets(plot_dict)

    return 0


def user_gs():
    """User accessor (prompts) to find possible placements of a specified gamma-ray energy

    """

    gamma_energy = abs(float(raw_input("Gamma peak energy [keV]: ")))
    dE           = abs(float(raw_input("Error (tolerance) to match gamma energy [keV]: ")))
    max_dI       = round(abs(float(raw_input("Maximum change in spin (up or down in spin): "))),1) # rounded to 1/2 integer spin (0.1 really)

    # Search 
    all_level_keys = investigated_nucleus.get_sorted_unique_level_keys()

    # Lists of transition descriptions
    coupled_descriptions   = []
    uncoupled_descriptions = []

    # Loop through all level keys to find a pair with an energy difference that matches within tolerance and max. dI.
    for i in range(len(all_level_keys)):
        first_key = all_level_keys[i]
        first_energy = investigated_nucleus.get_level_information(first_key,"energy")
        first_parity = investigated_nucleus.get_level_information(first_key,"parity")  # (1 or -1)
        for j in range(i+1, len(all_level_keys)):
            second_key = all_level_keys[j]
            second_energy = investigated_nucleus.get_level_information(second_key,"energy")
            second_parity = investigated_nucleus.get_level_information(second_key,"parity")  # (1 or -1)
            # Which is the higher-energy state?
            if second_energy < first_energy:
                higher_key = first_key
                lower_key = second_key
                higher_parity = first_parity
                lower_parity = second_parity
                higher_energy = first_energy
                lower_energy = second_energy
            else:
                higher_key = second_key
                lower_key = first_key
                higher_parity = second_parity
                lower_parity = first_parity
                higher_energy = second_energy
                lower_energy = first_energy
            delta_E = higher_energy - lower_energy # [keV]
            # Does the delta-E match within tolerance?
            if abs(delta_E - gamma_energy) <= dE:
                # Gamma energy matches
                # Is the delta-I within tolerance?
                delta_I = lower_key[1] - higher_key[1] 
                if abs(delta_I) <= max_dI:
                    # dI matches and dE matches.  
                    # These should be added to the list of matches.  First get a complete description as a list.
                    # band,spin,band,spin,gamma energy
                    match_data = [higher_key[0],higher_key[1],lower_key[0],lower_key[1],delta_E]
                    # Should these matching initial and final states be added to the list of coupled or uncoupled states?
                    higher_parity_string = ["-","+"][higher_parity]
                    lower_parity_string  = ["-","+"][lower_parity]
                    initial_state_pre_string = str(higher_key).strip("()").replace("'","").replace(",","") + higher_parity_string
                    final_state_pre_string   = str(lower_key).strip("()").replace("'","").replace(",","") + lower_parity_string
                    initial_state_string = initial_state_pre_string.ljust(15)
                    final_state_string   = final_state_pre_string.ljust(15)
                    transition_description = initial_state_string  + " --> " + final_state_string + "   " + str(round(delta_E,1)) + " keV"
                    if investigated_nucleus.are_coupled(higher_key,lower_key):
                        # Add to coupled list:
                        coupled_descriptions.append(transition_description)
                    else:
                        uncoupled_descriptions.append(transition_description)

    # All matches are found.  Print them 
    print "------------------------------------------------------------------------"
    print "Matches that are currently coupled by at least one matrix element"
    print "------------------------------------------------------------------------"
    for one_description in coupled_descriptions:
        print one_description
    print "------------------------------------------------------------------------"
    print "Matches that NOT are currently coupled by at least one matrix element"
    print "------------------------------------------------------------------------"
    for one_description in uncoupled_descriptions:
        print one_description
    print "------------------------------------------------------------------------"



#def user_():
#    """User accessor (prompts) for the function
#
#    """


#def user_():
#    """User accessor (prompts) for the function
#
#    """


#def user_():
#    """User accessor (prompts) for the function
#
#    """


#def user_():
#    """User accessor (prompts) for the function
#
#    """


#
#def user_():
#    """User accessor (prompts) for the function
#
#    """


#  ^                                                               ^
#  |                                                               |
#  |                                                               |
#  ###################################################################
#  # END USER ACCESSORS FOR MATH FUNCTIONS VIA THE INTERPRETER       #
#  ###################################################################




def main():

    gtk.main()
    return 0

if __name__ == "__main__":


    global LAST_POPUP_TIP
    LAST_POPUP_TIP = None

    # Set some default values for the few command-line arguments
    nosplash = False  # show the splash credits
    recover  = False  # Don't try to recover the session from the undo files after a force-quit in the last session
    debugging_mode = False  # programmer use only.
    script_mode = False  # Not showing the script function until we have simpler method calls for the user.

    for argument in sys.argv:
        if argument == "-l":
            nosplash = True
        if argument == "-r":
            recover = True
        if argument == "-debug":
            debugging_mode = True
        if argument == "-script":
            script_mode = True
    
    # Read and process the setup file for rachel.py 
    error_code = -1
    while error_code == -1:
        error_code = read_dot_rachel_setup_file()
        if error_code == -1:
            generate_dot_rachel_setup_file()
        else:
            error_code = test_rachel_setup()

    # setup the global objects
    if recover:
        setup_globals("recover")
        block_print_with_line_breaks("\nFormer session recovered!\n\nDO NOT OPERATE THE GUI NOW.\nThe last operation you performed may have been lost.\nCheck the setup of the GUI to ensure that you want to save it in its current state.  Save the session (button \"Save session\") if desired.  Then, quit and restart the GUI, reload the session and resume operations.",60)
        # Set the RECOVERY_MODE global to True, so that the GUI knows to deactivate buttons that should not be used in recovery mode.
        RECOVERY_MODE = True
        investigated_nucleus.draw_level_scheme()
    else:
        setup_globals("new")

    if debugging_mode:
        # Set the global flag for debugging mode.
        DEBUGGING_MODE = True

    if script_mode:
        # Set the global flag for debugging mode.
        SCRIPT_MODE = True

    # Set to ignore SIGINT using the signal module.  The calls to Gosia are
    # now preceded by signal.signal(signal.SIGINT,signal.SIG_DFL) to enable
    # the user to abort a runaway Gosia calculation and followed by
    # signal.signal(signal.SIGINT, signal.SIG_IGN) to resume ignoring
    # SIGINT.
    # Unless we are in debugging mode, disable CTRL-C (def ignore_break checks
    # for debugging mode.
    ignore_break() # The def ignore_break() checks whether or not DEBUGGING_MODE is True.

    main_gui()   # Run the main gui menu
    main()

